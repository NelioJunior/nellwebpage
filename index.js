// 1.0.155
(function(){"use strict";(function(i,a){try{if(typeof document<"u"){const e=document.createElement("style");e.id="d-id-agent-style";for(const t in a.attributes)e.setAttribute(t,a.attributes[t]);e.appendChild(document.createTextNode(i)),document.head.appendChild(e)}}catch(e){console.error("vite-plugin-css-injected-by-js",e)}})('@import"https://fonts.googleapis.com/css2?family=Inter:wght@200;300;400;500;600;700;800";.didagent__info_message_agent_unavailable_container{height:100%}.didagent__info_message_agent_unavailable_danger{width:100%;height:100%;z-index:2;margin-bottom:-4px;color:#fff;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;font-weight:500;font-size:12px;opacity:.85;background-color:var(--did-secondary-main);border-radius:8px;padding:0 8px;gap:8px;overflow:auto}.didagent__info_message_agent_unavailable_danger svg{color:var(--did-danger-main);display:-webkit-box;display:-ms-flexbox;display:flex;width:16px;height:16px;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.didagent__info_message_agent_unavailable_danger pre{margin:0 0 2px;white-space:pre-wrap}.didagent__info_message_agent_unavailable_message{display:-webkit-box;display:-ms-flexbox;display:flex;margin:0;-ms-flex-negative:0;flex-shrink:0;white-space:break-spaces;word-wrap:break-word;font-size:12px;-webkit-box-sizing:border-box;box-sizing:border-box;background:var(--did-secondary-main);opacity:.8;border-radius:4px;padding:4px;color:#fff;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.didagent__info_message_indication{background:var(--did-secondary-main);display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;color:#fff;margin:0;border-radius:8px;padding-left:10px;max-width:70%}.didagent__info_message_indication pre{font-family:Inter,system-ui,Avenir,Helvetica,Arial,sans-serif;font-size:14px;white-space:pre-wrap;padding:10px 10px 10px 8px;width:90%}.didagent__info_message_indication svg{margin-left:8px}@-webkit-keyframes fadeIn{0%{opacity:0;-webkit-transform:translateY(-10px);transform:translateY(-10px)}to{opacity:.8;-webkit-transform:translateY(0);transform:translateY(0)}}@keyframes fadeIn{0%{opacity:0;-webkit-transform:translateY(-10px);transform:translateY(-10px)}to{opacity:.8;-webkit-transform:translateY(0);transform:translateY(0)}}@-webkit-keyframes fadeOut{0%{opacity:.8;-webkit-transform:translateY(0);transform:translateY(0)}to{opacity:0;-webkit-transform:translateY(-10px);transform:translateY(-10px)}}@keyframes fadeOut{0%{opacity:.8;-webkit-transform:translateY(0);transform:translateY(0)}to{opacity:0;-webkit-transform:translateY(-10px);transform:translateY(-10px)}}.fade-in{-webkit-animation:fadeIn .5s forwards;animation:fadeIn .5s forwards}.fade-out{-webkit-animation:fadeOut .5s forwards;animation:fadeOut .5s forwards}.didagent__maskedicon{-webkit-mask:var(--mask-url) no-repeat center;mask:var(--mask-url) no-repeat center;background-color:var(--color);-webkit-mask-size:contain;mask-size:contain;width:var(--width, var(--size, 24px));height:var(--size, var(--height, 24px));padding:var(--padding);margin:var(--margin);-webkit-transform:rotate(var(--rotation, 0deg));-ms-transform:rotate(var(--rotation, 0deg));transform:rotate(var(--rotation, 0deg));display:block;-webkit-transition:background-color .1s ease-in-out,-webkit-transform .2s ease-in-out;transition:background-color .1s ease-in-out,-webkit-transform .2s ease-in-out;transition:transform .2s ease-in-out,background-color .1s ease-in-out;transition:transform .2s ease-in-out,background-color .1s ease-in-out,-webkit-transform .2s ease-in-out}.didagent__banner{width:100%;height:34px;z-index:2;margin-bottom:-4px;color:#fff;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;font-weight:400;font-size:12px;opacity:.85;background-color:var(--did-secondary-main)}.didagaent__send__button{height:100%;aspect-ratio:1;color:#fff;border:none;outline:none;cursor:pointer;padding:0;background:#2b2a28;border-radius:100vmax;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-shadow:0px 3px 3px 0px rgba(0,0,0,.07);box-shadow:0 3px 3px #00000012;-webkit-transition:background-color .1s ease-out;transition:background-color .1s ease-out}.didagaent__send__button:disabled{cursor:not-allowed}.didagent__send__button__disabled{opacity:.5}.didagaent__send__button_actions:hover{background:#2b2a28;opacity:.8}.didagaent__send__button_actions:active{opacity:.5}.didagaent__send__button__loader,.didagaent__send__button__record{background:#fff9}.didagaent__send__button__record:hover{background-color:#fff}.didagaent__send__button__record:disabled{opacity:.5}.didagaent__send__button__reload{background:var(--did-secondary-main)}.didagent__header{width:100%;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-ms-flex-pack:justify;justify-content:space-between;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:0 12px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-box-flex:1;-ms-flex:1;flex:1;background:-webkit-gradient(linear,left top,left bottom,from(rgba(9,6,4,.3)),to(rgba(9,6,4,0)));background:linear-gradient(180deg,#0906044d,#09060400);z-index:2;gap:8px;max-height:54px}.didagent__header .didagent__header-bg{border-radius:100vmax;background-color:var(--did-primary-black-00050);display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;border:none;outline:none}.didagent__header .didagent__header-left{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;gap:8px;height:32px}.didagent__header .didagent__header-left>button{cursor:pointer;border:none;outline:none;aspect-ratio:1;width:32px;color:#fff;-webkit-transition:background-color .2s;transition:background-color .2s;z-index:10000;height:100%}.didagent__header .didagent__header-left>button:hover{background-color:var(--did-secondary-hover)!important}.didagent__header .didagent__header-left button.didagent__header__menu__item-active{background-color:#fff;color:var(--did-secondary-900)}.didagent__header .didagent__header-left button.didagent__header__menu__item-active:hover{background-color:#fff!important}.didagent__header .didagent__header-left .didagent__header__name{font-size:.875em;font-weight:500;margin:0;color:var(--color, white);height:100%;padding:0 8px}.didagent__header .didagent__header-left .didagent__header__name img{max-height:64px;height:100%;-o-object-fit:contain;object-fit:contain;display:block}.didagent__header .didagent__header-center{display:-webkit-box;display:-ms-flexbox;display:flex;gap:8px;height:32px;margin:0 auto}.didagent__header .didagent__header__menu__item{cursor:pointer;color:var(--did-secondary-main);height:100%;aspect-ratio:1;border:none}.didagent__header .didagent__header__menu__item:disabled{cursor:not-allowed;opacity:.5}.didagent__header .didagent__header__menu__item:active:not(:disabled){border:1px solid var(--did-primary-black-300)}.didagent__header .didagent__header__menu__item-rotate{-webkit-animation:rotate 1s linear infinite;animation:rotate 1s linear infinite}@-webkit-keyframes rotate{0%{-webkit-transform:rotate(0deg);transform:rotate(0)}to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes rotate{0%{-webkit-transform:rotate(0deg);transform:rotate(0)}to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}.didagent__thumb__container{--flip-y: 1;--hover-color: var(--did-primary-black-00030);--color: var(--did-primary-black-00012);--cursor: pointer;cursor:var(--cursor);-webkit-transform:scaleY(var(--flip-y));-ms-transform:scaleY(var(--flip-y));transform:scaleY(var(--flip-y));width:32px;height:32px;border-radius:100%;background-color:var(--color);display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;line-height:1}.didagent__thumb__container:hover{background-color:var(--hover-color)}.didagent__thumb__container:active{background-color:var(--did-primary-black-00040)}.appear-animation{opacity:1}.appear-animation span{opacity:0;-webkit-animation:character-appear .3s ease-out forwards;animation:character-appear .3s ease-out forwards}@-webkit-keyframes character-appear{0%{opacity:0}to{opacity:1}}@keyframes character-appear{0%{opacity:0}to{opacity:1}}.didagent__messages__container{display:-webkit-box;display:-ms-flexbox;display:flex;width:100%;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;gap:8px;overflow:auto;min-height:50px;max-height:200px;padding-top:80px;padding-bottom:8px;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-mask-image:-webkit-gradient(linear,left top,left bottom,from(transparent),color-stop(50%,black),color-stop(97%,black),to(transparent));-webkit-mask-image:linear-gradient(to bottom,transparent,black 50%,black 97%,transparent);mask-image:-webkit-gradient(linear,left top,left bottom,from(transparent),color-stop(50%,black),color-stop(97%,black),to(transparent));mask-image:linear-gradient(to bottom,transparent,black 50%,black 97%,transparent);z-index:2;-ms-flex-item-align:center;align-self:center}.didagent__messages__container::-webkit-scrollbar{display:none}.didagent__messages__container .didagent__message__container{position:relative;min-width:50px;max-width:75%;-webkit-user-select:auto;-moz-user-select:auto;-ms-user-select:auto;user-select:auto;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;gap:8px}.didagent__messages__container .didagent__message__container .didagent__message{-webkit-box-sizing:border-box;box-sizing:border-box;padding:10px;font-family:inherit;margin:0;-ms-flex-negative:0;flex-shrink:0;white-space:break-spaces;word-wrap:break-word;font-size:.875em;max-width:100%}.didagent__messages__container .didagent__message__container .didagent__message__user{background:#5a5a5ae6;opacity:.8;border-radius:16px 0 16px 16px;color:#fff}.didagent__messages__container .didagent__message__container .didagent__message__assistant{background:#000000e6;opacity:.8;border-radius:0 16px 16px;color:#fff}.didagent__messages__container .didagent__message__container .didagent__message__assistant__loader{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding-left:14px;gap:8px}.didagent__messages__container .didagent__message__container .didagent__message__url{color:#497cff}.didagent__messages__container .didagent__message__container:hover .didagent__message__rating{opacity:1}.didagent__messages__container .didagent__message__container .didagent__message__rating{opacity:0;display:-webkit-box;display:-ms-flexbox;display:flex;-ms-flex-item-align:end;align-self:flex-end;gap:12px;-webkit-transition:opacity .2s ease-in-out;transition:opacity .2s ease-in-out;padding-bottom:4px}.didagent__messages__container .didagent__message__container__assistant{margin-right:auto}.didagent__messages__container .didagent__message__container__user{margin-left:auto}.didagent__starter_messages__container{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;gap:8px;width:100%;padding:0 16px 8px;max-height:180px;overflow:auto;-webkit-transition:max-height .6s ease-out,margin-bottom .6s ease-out,padding-bottom .6s ease-out,opacity .6s ease-out;transition:max-height .6s ease-out,margin-bottom .6s ease-out,padding-bottom .6s ease-out,opacity .6s ease-out;z-index:2}.didagent__starter_messages__container::-webkit-scrollbar{display:none}.didagent__starter_messages__container .didagent__starter_message__container{padding:10px 16px;border-radius:8px;width:100%;height:46px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;background:var(--did-primary-black-00050);color:#fff;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;font-weight:400;-webkit-box-flex:1;-ms-flex:1 0 auto;flex:1 0 auto}.didagent__starter_messages__container .didagent__starter_message__container .didagent__starter_message__arrow{rotate:270deg;margin-left:auto}.didagent__starter_messages__container .didagent__starter_message__container:hover{background:var(--did-primary-black-00040)}.didagent__starter_messages__container .didagent__starter_message__container:active{background:var(--did-primary-black-00050)}.didagent__starter_messages__container .didagent__starter_message__container.disabled{background:#78787829;cursor:not-allowed;pointer-events:none}.didagent__starter_messages__container .didagent__starter_message__container_text{text-overflow:ellipsis;overflow:hidden;white-space:normal;padding-right:8px;-webkit-box-flex:1;-ms-flex:1;flex:1;display:-webkit-box;line-clamp:2;-webkit-line-clamp:2;-webkit-box-orient:vertical}.didagent__embedded__video__container{position:absolute;top:0;width:100%;height:100%;aspect-ratio:1/1.5;margin:0 auto}.didagent__embedded__video__container[data-blur=true]{-webkit-filter:blur(7px);filter:blur(7px)}.didagent__embedded__video__container video{-o-object-fit:cover;object-fit:cover;position:absolute;display:block;height:100%;width:100%}@media (min-width: 1280px){.didagent__embedded__video__container[data-orientation=horizontal] video{-o-object-fit:contain;object-fit:contain}}.didagent__embedded__video__container .didagent__video__skeleton{height:100%;aspect-ratio:1;margin:auto}.didagent__embedded__video__idle{opacity:1}.didagent__embedded__video__stream{opacity:0;-webkit-transition:opacity .2s ease-in-out;transition:opacity .2s ease-in-out}.didagent__embedded__video__stream[data-active=true]{opacity:1}:host{--did-primary-black-50: #f1f2f6;--did-primary-black-70: #c0bfbd;--did-primary-black-80: #5a5a5a;--did-primary-black-90: #1d1d1d;--did-primary-black-9060: #1d1d1d99;--did-primary-black-9080: #1d1d1dcc;--did-primary-black-100: #242625;--did-primary-black-10090: #242625ba;--did-primary-black-200: #ebebeb;--did-primary-black-300: #dbdbdb;--did-primary-black-400: #b8b8b8;--did-primary-black-500: #989898;--did-primary-black-700: #5c5c5c;--did-primary-black-00012: rgba(0, 0, 0, .125);--did-primary-black-00030: rgba(0, 0, 0, .3);--did-primary-black-00040: rgba(0, 0, 0, .4);--did-primary-black-00050: rgba(0, 0, 0, .5);--did-primary-50: #fffee9;--did-primary-100: #fffac7;--did-primary-200: #fff6a0;--did-primary-300: #fff17b;--did-primary-400: #ffec5c;--did-primary-500: #fee640;--did-primary-600: #ffdd45;--did-primary-700: #ffc941;--did-primary-800: #ffb13a;--did-primary-900: #ff882e;--did-primary-950: #ed7921;--did-primary-main: #ff882e;--did-primary-light: #fff6ef;--did-primary-bg: #ff882e1f;--did-primary-bgDark: #493021;--did-primary-hover: #ed7921;--did-primary-disabled: #94979c;--did-secondary-50: #f8f5f4;--did-secondary-60: #f3f3f3;--did-secondary-100: #eceae8;--did-secondary-200: #dedcda;--did-secondary-300: #c9c7c6;--did-secondary-400: #a4a1a0;--did-secondary-500: #82807e;--did-secondary-550: #707070;--did-secondary-600: #5b5958;--did-secondary-700: #494745;--did-secondary-800: #2b2a28;--did-secondary-900: #090604;--did-secondary-main: #090604;--did-secondary-hover: #2b2a28;--did-secondary-shades-800: rgba(43, 42, 40, 1);--did-success-main: #29cc6a;--did-danger-main: #ed254e;--did-danger-light: #fef2f2;--did-danger-dark: #cc0037}.didagent__embedded__container__loading{width:100%;height:100%;-webkit-backdrop-filter:var(--backdrop-filter);backdrop-filter:var(--backdrop-filter);background-color:var(--background-color);display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;pointer-events:none;opacity:1;-webkit-transition:opacity .3s ease;transition:opacity .3s ease;position:absolute;z-index:3}.didagent__embedded__container__loading>span{color:var(--did-secondary-60);font-weight:500}.didagent__fullscreen{position:fixed!important;top:0;right:0;bottom:0;left:0;z-index:99999}.didagent__embedded__container{font-family:Inter,system-ui,Avenir,Helvetica,Arial,sans-serif;width:100%;height:100%;position:relative;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;gap:4px;overflow:hidden;min-width:250px;font-size:16px;background:#373636;isolation:isolate}.didagent__embedded__container .didagent__filler{-webkit-box-flex:1;-ms-flex:1;flex:1;width:100%;pointer-events:none}.didagent__embedded__container .didagent__close__button{display:none}.didagent__embedded__container *{-webkit-box-sizing:border-box;box-sizing:border-box}.didagent__background{width:100%;height:100%;position:absolute;top:0;left:0;background-size:cover!important;-webkit-filter:blur(15px);filter:blur(15px);scale:105%}.didagent__main__container{padding-left:12px;padding-right:12px;margin:0 auto;display:-webkit-box;display:-ms-flexbox;display:flex;width:100%;max-width:450px;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}.didagent__main__input{margin-bottom:12px;width:100%;-ms-flex-item-align:center;align-self:center;margin-top:0;position:relative;height:52px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;gap:12px;background-color:var(--focus, rgba(255, 255, 255, .6));z-index:4;border-radius:8px;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:8px 16px;-webkit-transition:height .3s ease,background-color .3s ease;transition:height .3s ease,background-color .3s ease}.didagent__main__input .didagent__main__input-send{height:36px}.didagent__main__input>textarea{position:relative;border:none;outline:none;resize:none;font-family:inherit;text-align:left;width:100%;height:100%;background:transparent;font-size:16px;color:var(--did-secondary-shades-800);margin-top:10px;-webkit-transition:margin-top .2s ease;transition:margin-top .2s ease;line-height:20px}.didagent__main__input>textarea::-webkit-input-placeholder{color:var(--did-primary-black-700);opacity:1;font-size:14px}.didagent__main__input>textarea::-moz-placeholder{color:var(--did-primary-black-700);opacity:1;font-size:14px}.didagent__main__input>textarea:-ms-input-placeholder{color:var(--did-primary-black-700);opacity:1;font-size:14px}.didagent__main__input>textarea::-ms-input-placeholder{color:var(--did-primary-black-700);opacity:1;font-size:14px}.didagent__main__input>textarea::placeholder{color:var(--did-primary-black-700);opacity:1;font-size:14px}.didagent__main__input>textarea::-webkit-scrollbar{display:none}.didagent__fabio{font-family:Inter,system-ui,Avenir,Helvetica,Arial,sans-serif;position:fixed;aspect-ratio:1;-webkit-transition:opacity .6s ease-in-out,width .6s ease-in-out,height .6s ease-in-out;transition:opacity .6s ease-in-out,width .6s ease-in-out,height .6s ease-in-out;aspect-ratio:.6s ease-in-out;z-index:99999;isolation:isolate;bottom:2%}.didagent__fabio[data-enabled=false]{width:140px}.didagent__fabio[data-enabled=true]{width:120px}.didagent__fabio[data-position=left]{left:2%}.didagent__fabio[data-position=right]{right:2%}@media (max-height: 550px){.didagent__fabio{display:none}}.didagent__fabio *{-webkit-box-sizing:border-box;box-sizing:border-box}.didagent__fabio>button{width:100%;height:100%;border-radius:50%;padding:0;cursor:pointer;outline:0;position:relative;border:none;-webkit-box-shadow:1px 3px 4px 1px #bbbbbb42;box-shadow:1px 3px 4px 1px #bbbbbb42;-webkit-transition:bottom .6s ease-in-out,opacity .8s ease-in-out,scale .2s ease-in-out;transition:bottom .6s ease-in-out,opacity .8s ease-in-out,scale .2s ease-in-out;overflow:hidden}.didagent__fabio>button>video,.didagent__fabio>button img{border-radius:100%;position:absolute;top:50%;left:50%;translate:-50% -50%;-o-object-fit:cover;object-fit:cover;-webkit-transition:opacity .2s ease-in-out;transition:opacity .2s ease-in-out}.didagent__fabio>button>video{width:100%;height:100%}.didagent__fabio>button:hover{background:#494949;scale:1.1}.didagent__fabio>button:after{content:"";position:absolute;top:0;left:0;width:100%;height:100%;background:#0000001a;border-radius:50%}.didagent__fabio .didagent__fabio__speak_with{z-index:-1;position:absolute;top:50%;right:110%;background:#494949e6;font-size:14px;text-align:center;border-radius:10px 10px 0;translate:0px -50%;width:90px;-webkit-transition:all .5s ease-in-out;transition:all .5s ease-in-out;height:50px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;cursor:pointer;pointer-events:none}.didagent__fabio .didagent__fabio__speak_with>div{overflow:hidden;white-space:nowrap;text-overflow:ellipsis;font-weight:400;color:#fff}.didagent__fabio .didagent__fabio__speak_with:after{position:absolute;top:0;left:100%;width:30px;height:100%;background:inherit}.didagent__fabio .didagent__transition_out{-webkit-transition:all .4s ease-in-out;transition:all .4s ease-in-out}.didagent__fabio .didagent__fabio__container{overflow:hidden;-webkit-transition:height .2s ease-in-out,opacity .2s ease-in-out;transition:height .2s ease-in-out,opacity .2s ease-in-out;position:absolute;bottom:0;border-radius:16px}@media (max-width: 600px){.didagent__fabio .didagent__fabio__container{position:fixed;border-radius:0;width:100%;height:100%;max-height:100vh;max-width:100vw;bottom:0;left:0}}.didagent__fabio .didagent__fabio__container .didagent__close__button{display:-webkit-box;display:-ms-flexbox;display:flex}.didagent__fabio .didagent__fabio__container[data-position=left]{left:0}.didagent__fabio .didagent__fabio__container[data-position=right]{right:0}.didagent__fabio .didagent__fabio__container[data-enabled=true]{opacity:1;pointer-events:auto;z-index:100}@media (max-width: 600px){.didagent__fabio .didagent__fabio__container[data-enabled=true]{position:fixed;border-radius:0;width:100%;height:100%;max-height:100vh;max-width:100vw;bottom:0;left:0}}@media (min-width: 600px){.didagent__fabio .didagent__fabio__container[data-enabled=true]{height:80vh;max-width:100vw;max-height:700px;aspect-ratio:2 / 3.3}}@media (min-width: 1280px){.didagent__fabio .didagent__fabio__container[data-enabled=true][data-orientation=horizontal]{aspect-ratio:4 / 3}}.didagent__fabio .didagent__fabio__container[data-enabled=false]{opacity:0;pointer-events:none;z-index:-1;height:0}',{})})();
var aS = Object.defineProperty;
var cS = (t, e, n) => e in t ? aS(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n;
var Ne = (t, e, n) => (cS(t, typeof e != "symbol" ? e + "" : e, n), n);
var uS = Object.defineProperty, pS = (t, e, n) => e in t ? uS(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, Xs = (t, e, n) => (pS(t, typeof e != "symbol" ? e + "" : e, n), n);
let Eo = class extends Error {
  constructor({
    kind: e,
    description: n,
    error: r
  }) {
    super(JSON.stringify({
      kind: e,
      description: n
    })), Xs(this, "kind"), Xs(this, "description"), Xs(this, "error"), this.kind = e, this.description = n, this.error = r;
  }
};
class dS extends Eo {
  constructor(e, n) {
    super({
      kind: "ChatCreationFailed",
      description: `Failed to create ${n ? "persistent" : ""} chat, mode: ${e}`
    });
  }
}
class lS extends Eo {
  constructor(e) {
    super({
      kind: "ChatModeDowngraded",
      description: `Chat mode downgraded to ${e}`
    });
  }
}
let Nn = class extends Eo {
  constructor(e, n) {
    super({
      kind: "ValidationError",
      description: e
    }), Xs(this, "key"), this.key = n;
  }
};
class hS extends Eo {
  constructor(e) {
    super({
      kind: "WSError",
      description: e
    });
  }
}
var tt = /* @__PURE__ */ ((t) => (t.Unrated = "Unrated", t.Positive = "Positive", t.Negative = "Negative", t))(tt || {}), M = /* @__PURE__ */ ((t) => (t.Functional = "Functional", t.TextOnly = "TextOnly", t.Maintenance = "Maintenance", t.Playground = "Playground", t.DirectPlayback = "DirectPlayback", t))(M || {}), xn = /* @__PURE__ */ ((t) => (t.Embed = "embed", t.Query = "query", t.Partial = "partial", t.Answer = "answer", t.Complete = "done", t))(xn || {}), Rv = /* @__PURE__ */ ((t) => (t.Clip = "clip", t.Talk = "talk", t))(Rv || {});
const vS = (t) => {
  switch (t) {
    case "clip":
      return "clip";
    case "talk":
      return "talk";
    default:
      throw new Error(`Unknown video type: ${t}`);
  }
};
var he = /* @__PURE__ */ ((t) => (t.Start = "START", t.Stop = "STOP", t))(he || {}), Bn = /* @__PURE__ */ ((t) => (t.Strong = "STRONG", t.Weak = "WEAK", t.Unknown = "UNKNOWN", t))(Bn || {}), uo = /* @__PURE__ */ ((t) => (t.Idle = "IDLE", t.Talking = "TALKING", t))(uo || {});
const yp = {
  "stream/started": "START",
  "stream/done": "STOP"
  /* Stop */
};
var po = /* @__PURE__ */ ((t) => (t.ChatAnswer = "chat/answer", t.ChatPartial = "chat/partial", t.StreamDone = "stream/done", t.StreamStarted = "stream/started", t.StreamFailed = "stream/error", t.StreamReady = "stream/ready", t.StreamCreated = "stream/created", t.StreamVideoCreated = "stream-video/started", t.StreamVideoDone = "stream-video/done", t.StreamVideoError = "stream-video/error", t.StreamVideoRejected = "stream-video/rejected", t))(po || {}), Q = /* @__PURE__ */ ((t) => (t.New = "new", t.Fail = "fail", t.Connected = "connected", t.Connecting = "connecting", t.Closed = "closed", t.Completed = "completed", t.Disconnected = "disconnected", t))(Q || {}), dn = /* @__PURE__ */ ((t) => (t.Legacy = "legacy", t.Fluent = "fluent", t))(dn || {});
const fS = 45 * 1e3, gS = "X-Playground-Chat", To = "https://api.d-id.com", mS = "wss://notifications.d-id.com", SS = "79f81a83a67430be2bc0fd61042b8faa", Pv = (t) => new Promise((e) => setTimeout(e, t)), lo = () => Math.random().toString(16).slice(2);
function yS(t, e) {
  let n;
  return {
    promise: new Promise((r, s) => {
      n = setTimeout(() => s(new Error(e)), t);
    }),
    clear: () => clearTimeout(n)
  };
}
async function zc(t, e) {
  const n = {
    limit: (e == null ? void 0 : e.limit) ?? 3,
    delayMs: (e == null ? void 0 : e.delayMs) ?? 0,
    timeout: (e == null ? void 0 : e.timeout) ?? 3e4,
    timeoutErrorMessage: (e == null ? void 0 : e.timeoutErrorMessage) || "Timeout error",
    shouldRetryFn: (e == null ? void 0 : e.shouldRetryFn) ?? (() => !0),
    onRetry: (e == null ? void 0 : e.onRetry) ?? (() => {
    })
  };
  let r;
  for (let s = 1; s <= n.limit; s++)
    try {
      if (!n.timeout)
        return await t();
      const {
        promise: o,
        clear: a
      } = yS(n.timeout, n.timeoutErrorMessage), i = t().finally(a);
      return await Promise.race([i, o]);
    } catch (o) {
      if (r = o, !n.shouldRetryFn(o) || s >= n.limit)
        throw o;
      await Pv(n.delayMs), n.onRetry(o);
    }
  throw r;
}
function Ev() {
  let t = window.localStorage.getItem("did_external_key_id");
  return t || (t = Math.random().toString(16).slice(2), window.localStorage.setItem("did_external_key_id", t)), t;
}
let CS = lo();
function Tv(t) {
  if (t.type === "bearer")
    return `Bearer ${t.token}`;
  if (t.type === "basic")
    return `Basic ${btoa(`${t.username}:${t.password}`)}`;
  if (t.type === "key")
    return `Client-Key ${t.clientKey}.${Ev()}_${CS}`;
  throw new Error(`Unknown auth type: ${t}`);
}
const _S = (t) => zc(t, {
  limit: 3,
  delayMs: 1e3,
  timeout: 0,
  shouldRetryFn: (e) => e.status === 429
});
function Cu(t, e = To, n) {
  const r = async (s, o) => {
    const {
      skipErrorHandler: a,
      ...i
    } = o || {}, c = await _S(() => fetch(e + (s != null && s.startsWith("/") ? s : `/${s}`), {
      ...i,
      headers: {
        ...i.headers,
        Authorization: Tv(t),
        "Content-Type": "application/json"
      }
    }));
    if (!c.ok) {
      let u = await c.text().catch(() => `Failed to fetch with status ${c.status}`);
      const p = new Error(u);
      throw n && !a && n(p, {
        url: s,
        options: i,
        headers: c.headers
      }), p;
    }
    return c.json();
  };
  return {
    get(s, o) {
      return r(s, {
        ...o,
        method: "GET"
      });
    },
    post(s, o, a) {
      return r(s, {
        ...a,
        body: JSON.stringify(o),
        method: "POST"
      });
    },
    delete(s, o, a) {
      return r(s, {
        ...a,
        body: JSON.stringify(o),
        method: "DELETE"
      });
    },
    patch(s, o, a) {
      return r(s, {
        ...a,
        body: JSON.stringify(o),
        method: "PATCH"
      });
    }
  };
}
function RS(t, e = To, n) {
  const r = Cu(t, `${e}/agents`, n);
  return {
    create(s, o) {
      return r.post("/", s, o);
    },
    getAgents(s, o) {
      return r.get(`/${s ? `?tag=${s}` : ""}`, o).then((a) => a ?? []);
    },
    getById(s, o) {
      return r.get(`/${s}`, o);
    },
    delete(s, o) {
      return r.delete(`/${s}`, void 0, o);
    },
    update(s, o, a) {
      return r.patch(`/${s}`, o, a);
    },
    newChat(s, o, a) {
      return r.post(`/${s}/chat`, o, a);
    },
    chat(s, o, a, i) {
      return r.post(`/${s}/chat/${o}`, a, i);
    },
    createRating(s, o, a, i) {
      return r.post(`/${s}/chat/${o}/ratings`, a, i);
    },
    updateRating(s, o, a, i, c) {
      return r.patch(`/${s}/chat/${o}/ratings/${a}`, i, c);
    },
    deleteRating(s, o, a, i) {
      return r.delete(`/${s}/chat/${o}/ratings/${a}`, i);
    },
    getSTTToken(s, o) {
      return r.get(`/${s}/stt-token`, o);
    }
  };
}
const _u = (t) => t.type === "clip" && t.presenter_id.startsWith("v2_") ? "clip_v2" : t.type;
function PS(t) {
  var e, n, r, s;
  const o = () => /Mobi|Android/i.test(navigator.userAgent) ? "Mobile" : "Desktop", a = () => {
    const c = navigator.platform;
    return c.toLowerCase().includes("win") ? "Windows" : c.toLowerCase().includes("mac") ? "Mac OS X" : c.toLowerCase().includes("linux") ? "Linux" : "Unknown";
  }, i = t.presenter;
  return {
    $os: `${a()}`,
    isMobile: `${o() == "Mobile"}`,
    browser: navigator.userAgent,
    origin: window.location.origin,
    agentType: _u(i),
    agentVoice: {
      voiceId: (n = (e = t.presenter) == null ? void 0 : e.voice) == null ? void 0 : n.voice_id,
      provider: (s = (r = t.presenter) == null ? void 0 : r.voice) == null ? void 0 : s.type
    }
  };
}
const ES = (t) => t.reduce((e, n) => e + n, 0), TS = (t) => ES(t) / t.length;
function IS(t, e, n) {
  var r, s, o;
  const {
    event: a,
    ...i
  } = t, {
    template: c
  } = (e == null ? void 0 : e.llm) || {}, {
    language: u
  } = ((r = e == null ? void 0 : e.presenter) == null ? void 0 : r.voice) || {};
  return {
    ...i,
    llm: {
      ...i.llm,
      template: c
    },
    script: {
      ...i.script,
      provider: {
        ...(s = i == null ? void 0 : i.script) == null ? void 0 : s.provider,
        language: u
      }
    },
    stitch: (e == null ? void 0 : e.presenter.type) === "talk" ? (o = e == null ? void 0 : e.presenter) == null ? void 0 : o.stitch : void 0,
    ...n
  };
}
let ic = {};
const wS = "https://api-js.mixpanel.com/track/?verbose=1&ip=1";
function bS(t) {
  var e, n, r, s, o, a;
  const i = window != null && window.hasOwnProperty("DID_AGENTS_API") ? "agents-ui" : "agents-sdk", c = t.agent.presenter, u = (e = t.agent.llm) == null ? void 0 : e.prompt_customization, p = {
    token: t.token || "testKey",
    distinct_id: t.distinctId || Ev(),
    agentId: t.agent.id,
    agentType: _u(c),
    owner_id: t.agent.owner_id ?? "",
    promptVersion: (n = t.agent.llm) == null ? void 0 : n.prompt_version,
    behavior: {
      role: u == null ? void 0 : u.role,
      personality: u == null ? void 0 : u.personality,
      instructions: (r = t.agent.llm) == null ? void 0 : r.instructions
    },
    temperature: (s = t.agent.llm) == null ? void 0 : s.temperature,
    knowledgeSource: u == null ? void 0 : u.knowledge_source,
    starterQuestionsCount: (a = (o = t.agent.knowledge) == null ? void 0 : o.starter_message) == null ? void 0 : a.length,
    topicsToAvoid: u == null ? void 0 : u.topics_to_avoid,
    maxResponseLength: u == null ? void 0 : u.max_response_length
  };
  return {
    ...p,
    additionalProperties: {},
    isEnabled: t.isEnabled ?? !0,
    getRandom: () => Math.random().toString(16).slice(2),
    enrich(d) {
      const l = {};
      if (d && typeof d != "object")
        throw new Error("properties must be a flat json object");
      for (let h in d)
        (typeof d[h] == "string" || typeof d[h] == "number") && (l[h] = d[h]);
      this.additionalProperties = {
        ...this.additionalProperties,
        ...l
      };
    },
    async track(d, l) {
      if (!this.isEnabled)
        return Promise.resolve();
      const {
        audioPath: h,
        ...v
      } = l || {}, g = {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded"
        },
        body: new URLSearchParams({
          data: JSON.stringify([{
            event: d,
            properties: {
              ...this.additionalProperties,
              ...v,
              ...p,
              source: i,
              time: Date.now(),
              $insert_id: this.getRandom(),
              origin: window.location.href,
              "Screen Height": window.screen.height || window.innerWidth,
              "Screen Width": window.screen.width || window.innerHeight,
              "User Agent": navigator.userAgent
            }
          }])
        })
      };
      try {
        return await fetch(wS, g).then((f) => f.json());
      } catch (f) {
        return console.error(f);
      }
    },
    linkTrack(d, l, h, v) {
      ic[d] || (ic[d] = {
        events: {},
        resolvedDependencies: []
      }), v.includes(h) || v.push(h);
      const g = ic[d];
      if (g.events[h] = {
        props: l
      }, g.resolvedDependencies.push(h), v.every((f) => g.resolvedDependencies.includes(f))) {
        const f = v.reduce((m, S) => g.events[S] ? {
          ...m,
          ...g.events[S].props
        } : m, {});
        this.track(d, f), g.resolvedDependencies = g.resolvedDependencies.filter((m) => !v.includes(m)), v.forEach((m) => {
          delete g.events[m];
        });
      }
    }
  };
}
function AS() {
  let t = 0;
  return {
    reset: () => t = 0,
    update: () => t = Date.now(),
    get: (e = !1) => e ? Date.now() - t : t
  };
}
const ln = AS();
function Iv(t) {
  return t === M.Playground ? {
    headers: {
      [gS]: "true"
    }
  } : {};
}
async function wv(t, e, n, r, s = !1, o) {
  try {
    return !o && r !== M.DirectPlayback && (o = await e.newChat(t.id, {
      persist: s
    }, Iv(r)), n.track("agent-chat", {
      event: "created",
      chat_id: o.id,
      agent_id: t.id,
      mode: r
    })), {
      chat: o,
      chatMode: (o == null ? void 0 : o.chat_mode) ?? r
    };
  } catch (a) {
    try {
      const i = JSON.parse(a.message);
      if ((i == null ? void 0 : i.kind) === "InsufficientCreditsError")
        throw new Error("InsufficientCreditsError");
    } catch (i) {
      console.error("Error parsing the error message:", i);
    }
    throw new Error("Cannot create new chat");
  }
}
function MS(t) {
  var e;
  const n = ((e = t.greetings) == null ? void 0 : e.filter((r) => r.length > 0)) ?? [];
  return n.length > 0 ? n[Math.floor(Math.random() * n.length)] : `Hi! I'm ${t.preview_name || "My Agent"}. How can I help you?`;
}
function Cp(t, e) {
  return e && e.length > 0 ? e : [{
    content: t,
    id: lo(),
    role: "assistant",
    created_at: (/* @__PURE__ */ new Date()).toISOString()
  }];
}
function kS(t) {
  return new Promise((e, n) => {
    const {
      callbacks: r,
      host: s,
      auth: o
    } = t, {
      onMessage: a = null,
      onOpen: i = null,
      onClose: c = null,
      onError: u = null
    } = r || {}, p = new WebSocket(`${s}?authorization=${Tv(o)}`);
    p.onmessage = a, p.onclose = c, p.onerror = (d) => {
      console.error(d), u == null || u("Websocket failed to connect", d), n(d);
    }, p.onopen = (d) => {
      i == null || i(d), e(p);
    };
  });
}
async function OS(t) {
  const {
    retries: e = 1
  } = t;
  let n = null;
  for (let r = 0; (n == null ? void 0 : n.readyState) !== WebSocket.OPEN; r++)
    try {
      n = await kS(t);
    } catch (s) {
      if (r === e)
        throw s;
      await Pv(r * 500);
    }
  return n;
}
async function DS(t, e, n) {
  const r = n != null && n.onMessage ? [n.onMessage] : [], s = await OS({
    auth: t,
    host: e,
    callbacks: {
      onError: (o) => {
        var a;
        return (a = n.onError) == null ? void 0 : a.call(n, new hS(o));
      },
      onMessage(o) {
        const a = JSON.parse(o.data);
        r.forEach((i) => i(a.event, a));
      }
    }
  });
  return {
    socket: s,
    disconnect: () => s.close(),
    subscribeToEvents: (o) => r.push(o)
  };
}
function NS(t) {
  if (t.answer !== void 0)
    return t.answer;
  let e = 0, n = "";
  for (; e in t; )
    n += t[e++];
  return n;
}
function LS(t, e, n, r, s) {
  const o = r.messages[r.messages.length - 1];
  if (!(t === xn.Partial || t === xn.Answer) || (o == null ? void 0 : o.role) !== "assistant")
    return;
  const {
    content: a,
    sequence: i
  } = e;
  t === xn.Partial ? n[i] = a : n.answer = a;
  const c = NS(n);
  (o.content !== c || t === xn.Answer) && (o.content = c, s == null || s([...r.messages], t));
}
function zS(t, e, n, r, s) {
  let o = {};
  return {
    clearQueue: () => o = {},
    onMessage: (a, i) => {
      var c, u;
      if ("content" in i)
        LS(a, i, o, e, n.callbacks.onNewMessage), a === xn.Answer && t.track("agent-message-received", {
          messages: e.messages.length,
          mode: e.chatMode
        });
      else {
        const p = po, d = [p.StreamVideoDone, p.StreamVideoError, p.StreamVideoRejected], l = [p.StreamFailed, p.StreamVideoError, p.StreamVideoRejected], h = IS(i, r, {
          mode: e.chatMode
        });
        if (a = a, a === p.StreamVideoCreated)
          t.linkTrack("agent-video", h, p.StreamVideoCreated, ["start"]);
        else if (d.includes(a)) {
          const v = a.split("/")[1];
          l.includes(a) ? t.track("agent-video", {
            ...h,
            event: v
          }) : t.linkTrack("agent-video", {
            ...h,
            event: v
          }, a, ["done"]);
        }
        l.includes(a) && ((u = (c = n.callbacks).onError) == null || u.call(c, new Error(`Stream failed with event ${a}`), {
          data: i
        })), i.event === p.StreamDone && s();
      }
    }
  };
}
function jS(t, e, n, r) {
  const s = Cu(t, `${e}/agents/${n}`, r);
  return {
    createStream(o) {
      return s.post("/streams", {
        output_resolution: o.output_resolution,
        compatibility_mode: o.compatibility_mode,
        stream_warmup: o.stream_warmup,
        session_timeout: o.session_timeout,
        stream_greeting: o.stream_greeting
      });
    },
    startConnection(o, a, i) {
      return s.post(`/streams/${o}/sdp`, {
        session_id: i,
        answer: a
      });
    },
    addIceCandidate(o, a, i) {
      return s.post(`/streams/${o}/ice`, {
        session_id: i,
        ...a
      });
    },
    sendStreamRequest(o, a, i) {
      return s.post(`/streams/${o}`, {
        session_id: a,
        ...i
      });
    },
    close(o, a) {
      return s.delete(`/streams/${o}`, {
        session_id: a
      });
    }
  };
}
function xS(t, e, n, r) {
  const s = Cu(t, `${e}/agents/${n}`, r);
  return {
    createStream(o, a) {
      return s.post("/streams", {
        driver_url: o.driver_url,
        face: o.face,
        config: o.config,
        output_resolution: o.output_resolution,
        compatibility_mode: o.compatibility_mode,
        stream_warmup: o.stream_warmup,
        session_timeout: o.session_timeout,
        stream_greeting: o.stream_greeting
      }, a);
    },
    startConnection(o, a, i, c) {
      return s.post(`/streams/${o}/sdp`, {
        session_id: i,
        answer: a
      }, c);
    },
    addIceCandidate(o, a, i, c) {
      return s.post(`/streams/${o}/ice`, {
        session_id: i,
        ...a
      }, c);
    },
    sendStreamRequest(o, a, i, c) {
      return s.post(`/streams/${o}`, {
        session_id: a,
        ...i
      }, c);
    },
    close(o, a, i) {
      return s.delete(`/streams/${o}`, {
        session_id: a
      }, i);
    }
  };
}
function BS(t, e, n) {
  const r = (e.timestamp - t.timestamp) / 1e3;
  return {
    duration: r,
    bytesReceived: e.bytesReceived - t.bytesReceived,
    bitrate: Math.round((e.bytesReceived - t.bytesReceived) * 8 / r),
    packetsReceived: e.packetsReceived - t.packetsReceived,
    packetsLost: e.packetsLost - t.packetsLost,
    framesDropped: e.framesDropped - t.framesDropped,
    framesDecoded: e.framesDecoded - t.framesDecoded,
    jitter: e.jitter,
    avgJitterDelayInInterval: (e.jitterBufferDelay - t.jitterBufferDelay) / (e.jitterBufferEmittedCount - t.jitterBufferEmittedCount),
    jitterBufferEmittedCount: e.jitterBufferEmittedCount - t.jitterBufferEmittedCount,
    jitterBufferDelay: (e.jitterBufferDelay - t.jitterBufferDelay) / r,
    framesPerSecond: e.framesPerSecond,
    freezeCount: e.freezeCount - t.freezeCount,
    freezeDuration: e.freezeDuration - t.freezeDuration,
    lowFpsCount: n
  };
}
function qS(t) {
  return t.filter((e) => e.freezeCount > 0 || e.framesPerSecond < 21 || e.framesDropped > 0 || e.packetsLost > 0).map((e) => {
    const {
      timestamp: n,
      ...r
    } = e, s = [];
    return e.freezeCount > 0 && s.push("freeze"), e.framesPerSecond < 21 && s.push("low fps"), e.framesDropped > 0 && s.push("frames dropped"), e.packetsLost > 0 && s.push("packet loss"), {
      ...r,
      causes: s
    };
  });
}
function FS(t) {
  let e = "";
  for (const n of t.values())
    if (n && n.type === "codec" && n.mimeType.startsWith("video") && (e = n.mimeType.split("/")[1]), n && n.type === "inbound-rtp" && n.kind === "video")
      return {
        codec: e,
        timestamp: n.timestamp,
        bytesReceived: n.bytesReceived,
        packetsReceived: n.packetsReceived,
        packetsLost: n.packetsLost,
        framesDropped: n.framesDropped,
        framesDecoded: n.framesDecoded,
        jitter: n.jitter,
        jitterBufferDelay: n.jitterBufferDelay,
        jitterBufferEmittedCount: n.jitterBufferEmittedCount,
        avgJitterDelayInInterval: n.jitterBufferDelay / n.jitterBufferEmittedCount,
        frameWidth: n.frameWidth,
        frameHeight: n.frameHeight,
        framesPerSecond: n.framesPerSecond,
        freezeCount: n.freezeCount,
        freezeDuration: n.totalFreezesDuration
      };
  return {};
}
function $S(t, e, n) {
  const r = t.map((i, c) => c === 0 ? n ? {
    timestamp: i.timestamp,
    duration: 0,
    bytesReceived: i.bytesReceived - n.bytesReceived,
    bitrate: (i.bytesReceived - n.bytesReceived) * 8 / (e / 1e3),
    packetsReceived: i.packetsReceived - n.packetsReceived,
    packetsLost: i.packetsLost - n.packetsLost,
    framesDropped: i.framesDropped - n.framesDropped,
    framesDecoded: i.framesDecoded - n.framesDecoded,
    jitter: i.jitter,
    jitterBufferDelay: i.jitterBufferDelay - n.jitterBufferDelay,
    jitterBufferEmittedCount: i.jitterBufferEmittedCount - n.jitterBufferEmittedCount,
    avgJitterDelayInInterval: (i.jitterBufferDelay - n.jitterBufferDelay) / (i.jitterBufferEmittedCount - n.jitterBufferEmittedCount),
    framesPerSecond: i.framesPerSecond,
    freezeCount: i.freezeCount - n.freezeCount,
    freezeDuration: i.freezeDuration - n.freezeDuration
  } : {
    timestamp: i.timestamp,
    duration: 0,
    bytesReceived: i.bytesReceived,
    bitrate: i.bytesReceived * 8 / (e / 1e3),
    packetsReceived: i.packetsReceived,
    packetsLost: i.packetsLost,
    framesDropped: i.framesDropped,
    framesDecoded: i.framesDecoded,
    jitter: i.jitter,
    jitterBufferDelay: i.jitterBufferDelay,
    jitterBufferEmittedCount: i.jitterBufferEmittedCount,
    avgJitterDelayInInterval: i.jitterBufferDelay / i.jitterBufferEmittedCount,
    framesPerSecond: i.framesPerSecond,
    freezeCount: i.freezeCount,
    freezeDuration: i.freezeDuration
  } : {
    timestamp: i.timestamp,
    duration: e * c / 1e3,
    bytesReceived: i.bytesReceived - t[c - 1].bytesReceived,
    bitrate: (i.bytesReceived - t[c - 1].bytesReceived) * 8 / (e / 1e3),
    packetsReceived: i.packetsReceived - t[c - 1].packetsReceived,
    packetsLost: i.packetsLost - t[c - 1].packetsLost,
    framesDropped: i.framesDropped - t[c - 1].framesDropped,
    framesDecoded: i.framesDecoded - t[c - 1].framesDecoded,
    jitter: i.jitter,
    jitterBufferDelay: i.jitterBufferDelay - t[c - 1].jitterBufferDelay,
    jitterBufferEmittedCount: i.jitterBufferEmittedCount - t[c - 1].jitterBufferEmittedCount,
    avgJitterDelayInInterval: (i.jitterBufferDelay - t[c - 1].jitterBufferDelay) / (i.jitterBufferEmittedCount - t[c - 1].jitterBufferEmittedCount),
    framesPerSecond: i.framesPerSecond,
    freezeCount: i.freezeCount - t[c - 1].freezeCount,
    freezeDuration: i.freezeDuration - t[c - 1].freezeDuration
  }), s = qS(r), o = s.reduce((i, c) => i + (c.causes.includes("low fps") ? 1 : 0), 0), a = r.map((i) => i.avgJitterDelayInInterval);
  return {
    webRTCStats: {
      anomalies: s,
      aggregateReport: BS(t[0], t[t.length - 1], o),
      minJitterDelayInInterval: Math.min(...a),
      maxJitterDelayInInterval: Math.max(...a),
      avgJitterDelayInInterval: TS(a)
    },
    codec: t[0].codec,
    resolution: `${t[0].frameWidth}x${t[0].frameHeight}`
  };
}
const jc = 100, US = Math.max(Math.ceil(400 / jc), 1), HS = 0.25, WS = 0.28;
function VS() {
  let t = 0, e, n, r = 0;
  return (s) => {
    for (const o of s.values())
      if (o && o.type === "inbound-rtp" && o.kind === "video") {
        const a = o.jitterBufferDelay, i = o.jitterBufferEmittedCount;
        if (n && i > n) {
          const p = a - e, d = i - n;
          r = p / d;
        }
        e = a, n = i;
        const c = o.framesDecoded, u = c - t > 0;
        return t = c, {
          isReceiving: u,
          avgJitterDelayInInterval: r,
          freezeCount: o.freezeCount
        };
      }
    return {
      isReceiving: !1,
      avgJitterDelayInInterval: r
    };
  };
}
function KS(t, e, n, r, s, o = !1, a = !1) {
  const i = o ? 1 : 0;
  let c = [], u, p = 0, d = !1, l = 0, h = Bn.Unknown, v = Bn.Unknown, g = 0, f = 0;
  const m = VS();
  return setInterval(async () => {
    const S = await t.getStats(), {
      isReceiving: y,
      avgJitterDelayInInterval: P,
      freezeCount: C
    } = m(S), _ = FS(S);
    if (y)
      p = 0, g = C - f, v = P < HS ? Bn.Strong : P > WS && g > 1 ? Bn.Weak : h, v !== h && (s == null || s(v), h = v, f += g, g = 0), d || (r == null || r(he.Start), a && l >= i && !e() && n(), u = c[c.length - 1], c = [], l++, d = !0), c.push(_);
    else if (d && (p++, p >= US)) {
      const w = $S(c, jc, u);
      r == null || r(he.Stop, w), !a && !e() && n(), d = !1;
    }
  }, jc);
}
let bv = !1;
const At = (t, e) => bv && console.log(t, e), JS = (window.RTCPeerConnection || window.webkitRTCPeerConnection || window.mozRTCPeerConnection).bind(window);
function _p(t) {
  switch (t) {
    case "connected":
      return Q.Connected;
    case "checking":
      return Q.Connecting;
    case "failed":
      return Q.Fail;
    case "new":
      return Q.New;
    case "closed":
      return Q.Closed;
    case "disconnected":
      return Q.Disconnected;
    case "completed":
      return Q.Completed;
    default:
      return Q.New;
  }
}
function GS({
  statsSignal: t,
  dataChannelSignal: e,
  onVideoStateChange: n,
  report: r
}) {
  t === he.Start && e === he.Start ? n == null || n(he.Start) : t === he.Stop && e === he.Stop && (n == null || n(he.Stop, r));
}
function QS({
  statsSignal: t,
  dataChannelSignal: e,
  onVideoStateChange: n,
  onAgentActivityStateChange: r,
  report: s
}) {
  t === he.Start ? n == null || n(he.Start) : t === he.Stop && (n == null || n(he.Stop, s)), e === he.Start ? r == null || r(uo.Talking) : e === he.Stop && (r == null || r(uo.Idle));
}
function Rp({
  statsSignal: t,
  dataChannelSignal: e,
  onVideoStateChange: n,
  onAgentActivityStateChange: r,
  streamType: s,
  report: o
}) {
  s === dn.Legacy ? GS({
    statsSignal: t,
    dataChannelSignal: e,
    onVideoStateChange: n,
    report: o
  }) : s === dn.Fluent && QS({
    statsSignal: t,
    dataChannelSignal: e,
    onVideoStateChange: n,
    onAgentActivityStateChange: r,
    report: o
  });
}
async function YS(t, e, {
  debug: n = !1,
  callbacks: r,
  auth: s,
  baseURL: o = To
}) {
  bv = n;
  let a = !1, i = !1, c = he.Stop, u = he.Stop, p = Bn.Unknown;
  const {
    startConnection: d,
    sendStreamRequest: l,
    close: h,
    createStream: v,
    addIceCandidate: g
  } = e.videoType === Rv.Clip ? jS(s, o, t, r.onError) : xS(s, o, t, r.onError), {
    id: f,
    offer: m,
    ice_servers: S,
    session_id: y,
    fluent: P
  } = await v(e), C = new JS({
    iceServers: S
  }), _ = C.createDataChannel("JanusDataChannel");
  if (!y)
    throw new Error("Could not create session_id");
  const w = P ? dn.Fluent : dn.Legacy, T = e.stream_warmup && !P, O = () => a, G = () => {
    var b;
    a = !0, i && ((b = r.onConnectionStateChange) == null || b.call(r, Q.Connected));
  }, X = KS(C, O, G, (b, x) => Rp({
    statsSignal: u = b,
    dataChannelSignal: w === dn.Legacy ? c : void 0,
    onVideoStateChange: r.onVideoStateChange,
    onAgentActivityStateChange: r.onAgentActivityStateChange,
    report: x,
    streamType: w
  }), (b) => {
    var x;
    return (x = r.onConnectivityStateChange) == null ? void 0 : x.call(r, p);
  }, T, !!e.stream_greeting);
  C.onicecandidate = (b) => {
    var x;
    At("peerConnection.onicecandidate", b);
    try {
      b.candidate && b.candidate.sdpMid && b.candidate.sdpMLineIndex !== null ? g(f, {
        candidate: b.candidate.candidate,
        sdpMid: b.candidate.sdpMid,
        sdpMLineIndex: b.candidate.sdpMLineIndex
      }, y) : g(f, {
        candidate: null
      }, y);
    } catch (ee) {
      (x = r.onError) == null || x.call(r, ee, {
        streamId: f
      });
    }
  }, _.onopen = () => {
    i = !0, (!T && !e.stream_greeting || a) && G();
  }, _.onmessage = (b) => {
    b.data in yp && (c = yp[b.data], Rp({
      statsSignal: w === dn.Legacy ? u : void 0,
      dataChannelSignal: c,
      onVideoStateChange: r.onVideoStateChange,
      onAgentActivityStateChange: r.onAgentActivityStateChange,
      streamType: w
    }));
  }, C.oniceconnectionstatechange = () => {
    var b;
    At("peerConnection.oniceconnectionstatechange => " + C.iceConnectionState);
    const x = _p(C.iceConnectionState);
    x !== Q.Connected && ((b = r.onConnectionStateChange) == null || b.call(r, x));
  }, C.ontrack = (b) => {
    var x;
    At("peerConnection.ontrack", b), (x = r.onSrcObjectReady) == null || x.call(r, b.streams[0]);
  }, await C.setRemoteDescription(m), At("set remote description OK");
  const q = await C.createAnswer();
  return At("create answer OK"), await C.setLocalDescription(q), At("set local description OK"), await d(f, q, y), At("start connection OK"), {
    /**
     * Method to send request to server to get clip or talk depend on you payload
     * @param payload
     */
    speak(b) {
      return l(f, y, b);
    },
    /**
     * Method to close RTC connection
     */
    async disconnect() {
      var b, x, ee;
      if (f) {
        const Z = _p(C.iceConnectionState);
        if (C) {
          if (Z === Q.New) {
            (b = r.onVideoStateChange) == null || b.call(r, he.Stop), clearInterval(X);
            return;
          }
          C.close(), C.oniceconnectionstatechange = null, C.onnegotiationneeded = null, C.onicecandidate = null, C.ontrack = null;
        }
        try {
          Z === Q.Connected && await h(f, y).catch((L) => {
          });
        } catch (L) {
          At("Error on close stream connection", L);
        }
        (x = r.onVideoStateChange) == null || x.call(r, he.Stop), (ee = r.onAgentActivityStateChange) == null || ee.call(r, uo.Idle), clearInterval(X);
      }
    },
    /**
     * Session identifier information, should be returned in the body of all streaming requests
     */
    sessionId: y,
    /**
     * Id of current RTC stream
     */
    streamId: f,
    streamType: w
  };
}
function ZS(t, e, n) {
  var r;
  const {
    streamOptions: s
  } = e ?? {};
  return {
    videoType: vS(t.presenter.type),
    output_resolution: s == null ? void 0 : s.outputResolution,
    session_timeout: s == null ? void 0 : s.sessionTimeout,
    stream_warmup: s == null ? void 0 : s.streamWarmup,
    compatibility_mode: s == null ? void 0 : s.compatibilityMode,
    stream_greeting: _u(t.presenter) !== "clip" && (r = e == null ? void 0 : e.streamOptions) != null && r.streamGreeting ? n : void 0
  };
}
function XS(t, e, n, r) {
  ln.get() > 0 && (t === he.Start ? r.linkTrack("agent-video", {
    event: "start",
    latency: ln.get(!0)
  }, "start", [po.StreamVideoCreated]) : t === he.Stop && r.linkTrack("agent-video", {
    event: "stop",
    is_greenscreen: e.presenter.type === "clip" && e.presenter.is_greenscreen,
    background: e.presenter.type === "clip" && e.presenter.background,
    ...n
  }, "done", [po.StreamVideoDone]));
}
function ey(t, e, n, r) {
  return ln.reset(), new Promise(async (s, o) => {
    try {
      const a = await YS(t.id, ZS(t, e, r), {
        ...e,
        analytics: n,
        callbacks: {
          ...e.callbacks,
          onConnectionStateChange: (i) => {
            var c, u;
            (u = (c = e.callbacks).onConnectionStateChange) == null || u.call(c, i), i === Q.Connected && s(a);
          },
          onVideoStateChange: (i, c) => {
            var u, p;
            (p = (u = e.callbacks).onVideoStateChange) == null || p.call(u, i), XS(i, t, c, n);
          }
        }
      });
    } catch (a) {
      o(a);
    }
  });
}
async function ty(t, e, n, r, s, o) {
  var a, i, c, u;
  const {
    chat: p,
    chatMode: d
  } = await wv(t, n, r, e.mode, e.persistentChat, s);
  if (d && d !== e.mode && (e.mode = d, (i = (a = e.callbacks).onModeChange) == null || i.call(a, d), d === M.TextOnly))
    return (u = (c = e.callbacks).onError) == null || u.call(c, new lS(d)), {
      chat: p
    };
  const l = await ey(t, e, r, o);
  return {
    chat: p,
    streamingManager: l
  };
}
async function ny(t, e) {
  var n, r, s;
  let o = !0;
  const a = e.mixpanelKey || SS, i = e.wsURL || mS, c = e.baseURL || To, u = {
    messages: [],
    chatMode: e.mode || M.Functional
  }, p = RS(e.auth, c, e.callbacks.onError), d = await p.getById(t), l = MS(d), h = bS({
    token: a,
    agent: d,
    isEnabled: e.enableAnalitics,
    distinctId: e.distinctId
  }), {
    onMessage: v,
    clearQueue: g
  } = zS(h, u, e, d, () => {
    var y;
    return (y = u.socketManager) == null ? void 0 : y.disconnect();
  });
  u.messages = Cp(l, e.initialMessages), (r = (n = e.callbacks).onNewMessage) == null || r.call(n, [...u.messages], "answer"), h.track("agent-sdk", {
    event: "loaded",
    ...PS(d)
  });
  async function f(y) {
    var P, C, _, w, T, O, G;
    (C = (P = e.callbacks).onConnectionStateChange) == null || C.call(P, Q.Connecting), ln.reset(), y && !o && (delete u.chat, u.messages = Cp(l), (w = (_ = e.callbacks).onNewMessage) == null || w.call(_, [...u.messages], "answer"));
    const X = e.mode === M.DirectPlayback ? Promise.resolve(void 0) : DS(e.auth, i, {
      onMessage: v,
      onError: e.callbacks.onError
    }), q = zc(() => ty(d, e, p, h, u.chat, y ? l : void 0), {
      limit: 3,
      timeout: fS,
      timeoutErrorMessage: "Timeout initializing the stream",
      // Retry on all errors except for connection errors and rate limit errors, these are already handled in client level.
      shouldRetryFn: (Z) => (Z == null ? void 0 : Z.message) !== "Could not connect" && Z.status !== 429,
      delayMs: 1e3
    }).catch((Z) => {
      var L, re;
      throw S(M.Maintenance), (re = (L = e.callbacks).onConnectionStateChange) == null || re.call(L, Q.Fail), Z;
    }), [b, {
      streamingManager: x,
      chat: ee
    }] = await Promise.all([X, q]);
    ee && ee.id !== ((T = u.chat) == null ? void 0 : T.id) && ((G = (O = e.callbacks).onNewChat) == null || G.call(O, ee.id)), u.streamingManager = x, u.socketManager = b, u.chat = ee, o = !1, S((ee == null ? void 0 : ee.chat_mode) ?? e.mode ?? M.Functional);
  }
  async function m() {
    var y, P, C, _;
    (y = u.socketManager) == null || y.disconnect(), await ((P = u.streamingManager) == null ? void 0 : P.disconnect()), delete u.streamingManager, delete u.socketManager, (_ = (C = e.callbacks).onConnectionStateChange) == null || _.call(C, Q.Disconnected);
  }
  async function S(y) {
    var P, C;
    y !== u.chatMode && (h.track("agent-mode-change", {
      mode: y
    }), u.chatMode = y, u.chatMode !== M.Functional && await m(), (C = (P = e.callbacks).onModeChange) == null || C.call(P, y));
  }
  return {
    agent: d,
    getStreamType: () => {
      var y;
      return (y = u.streamingManager) == null ? void 0 : y.streamType;
    },
    starterMessages: ((s = d.knowledge) == null ? void 0 : s.starter_message) || [],
    getSTTToken: () => p.getSTTToken(d.id),
    changeMode: S,
    enrichAnalytics: h.enrich,
    async connect() {
      var y;
      await f(!0), h.track("agent-chat", {
        event: "connect",
        chatId: (y = u.chat) == null ? void 0 : y.id,
        agentId: d.id,
        mode: u.chatMode
      });
    },
    async reconnect() {
      var y;
      await m(), await f(!1), h.track("agent-chat", {
        event: "reconnect",
        chatId: (y = u.chat) == null ? void 0 : y.id,
        agentId: d.id,
        mode: u.chatMode
      });
    },
    async disconnect() {
      var y;
      await m(), h.track("agent-chat", {
        event: "disconnect",
        chatId: (y = u.chat) == null ? void 0 : y.id,
        agentId: d.id,
        mode: u.chatMode
      });
    },
    async chat(y) {
      var P, C, _, w, T;
      const O = () => {
        if (e.mode === M.DirectPlayback)
          throw new Nn("Direct playback is enabled, chat is disabled");
        if (y.length >= 800)
          throw new Nn("Message cannot be more than 800 characters");
        if (y.length === 0)
          throw new Nn("Message cannot be empty");
        if (u.chatMode === M.Maintenance)
          throw new Nn("Chat is in maintenance mode");
        if (![M.TextOnly, M.Playground].includes(u.chatMode)) {
          if (!u.streamingManager)
            throw new Nn("Streaming manager is not initialized");
          if (!u.chat)
            throw new Nn("Chat is not initialized");
        }
      }, G = async () => {
        var q, b;
        if (!u.chat) {
          const x = await wv(d, p, h, u.chatMode, e.persistentChat);
          if (!x.chat)
            throw new dS(u.chatMode, !!e.persistentChat);
          u.chat = x.chat, (b = (q = e.callbacks).onNewChat) == null || b.call(q, u.chat.id);
        }
        return u.chat.id;
      }, X = async (q, b) => zc(() => {
        var x, ee;
        return p.chat(d.id, b, {
          chatMode: u.chatMode,
          streamId: (x = u.streamingManager) == null ? void 0 : x.streamId,
          sessionId: (ee = u.streamingManager) == null ? void 0 : ee.sessionId,
          messages: q.map(({
            matches: Z,
            ...L
          }) => L)
        }, {
          ...Iv(u.chatMode),
          skipErrorHandler: !0
        });
      }, {
        limit: 2,
        shouldRetryFn: (x) => {
          var ee, Z, L, re;
          const ce = (ee = x == null ? void 0 : x.message) == null ? void 0 : ee.includes("missing or invalid session_id");
          return !((Z = x == null ? void 0 : x.message) != null && Z.includes("Stream Error")) && !ce ? ((re = (L = e.callbacks).onError) == null || re.call(L, x), !1) : !0;
        },
        onRetry: async () => {
          await m(), await f(!1);
        }
      });
      try {
        g(), O(), u.messages.push({
          id: lo(),
          role: "user",
          content: y,
          created_at: new Date(ln.update()).toISOString()
        }), (C = (P = e.callbacks).onNewMessage) == null || C.call(P, [...u.messages], "user");
        const q = await G(), b = await X([...u.messages], q);
        return u.messages.push({
          id: lo(),
          role: "assistant",
          content: b.result || "",
          created_at: (/* @__PURE__ */ new Date()).toISOString(),
          context: b.context,
          matches: b.matches
        }), h.track("agent-message-send", {
          event: "success",
          mode: u.chatMode,
          messages: u.messages.length + 1
        }), b.result && ((w = (_ = e.callbacks).onNewMessage) == null || w.call(_, [...u.messages], "answer"), h.track("agent-message-received", {
          latency: ln.get(!0),
          mode: u.chatMode,
          messages: u.messages.length
        })), b;
      } catch (q) {
        throw ((T = u.messages[u.messages.length - 1]) == null ? void 0 : T.role) === "assistant" && u.messages.pop(), h.track("agent-message-send", {
          event: "error",
          mode: u.chatMode,
          messages: u.messages.length
        }), q;
      }
    },
    rate(y, P, C) {
      var _, w, T, O;
      const G = u.messages.find((q) => q.id === y);
      if (u.chat) {
        if (!G)
          throw new Error("Message not found");
      } else
        throw new Error("Chat is not initialized");
      const X = ((_ = G.matches) == null ? void 0 : _.map((q) => [q.document_id, q.id])) ?? [];
      return h.track("agent-rate", {
        event: C ? "update" : "create",
        thumb: P === 1 ? "up" : "down",
        knowledge_id: ((w = d.knowledge) == null ? void 0 : w.id) ?? "",
        mode: u.chatMode,
        matches: X,
        score: P
      }), C ? p.updateRating(d.id, u.chat.id, C, {
        knowledge_id: ((T = d.knowledge) == null ? void 0 : T.id) ?? "",
        message_id: y,
        matches: X,
        score: P
      }) : p.createRating(d.id, u.chat.id, {
        knowledge_id: ((O = d.knowledge) == null ? void 0 : O.id) ?? "",
        message_id: y,
        matches: X,
        score: P
      });
    },
    deleteRate(y) {
      var P;
      if (!u.chat)
        throw new Error("Chat is not initialized");
      return h.track("agent-rate-delete", {
        type: "text",
        chat_id: (P = u.chat) == null ? void 0 : P.id,
        id: y,
        mode: u.chatMode
      }), p.deleteRating(d.id, u.chat.id, y);
    },
    speak(y) {
      var P;
      if (!u.streamingManager)
        throw new Error("Please connect to the agent first");
      function C() {
        if (typeof y == "string") {
          if (!d.presenter.voice)
            throw new Error("Presenter voice is not initialized");
          return {
            type: "text",
            provider: d.presenter.voice,
            input: y,
            ssml: !1
          };
        }
        if (y.type === "text" && !y.provider) {
          if (!d.presenter.voice)
            throw new Error("Presenter voice is not initialized");
          return {
            type: "text",
            provider: d.presenter.voice,
            input: y.input,
            ssml: y.ssml
          };
        }
        return y;
      }
      const _ = C();
      return h.track("agent-speak", _), ln.update(), u.streamingManager.speak({
        script: _,
        metadata: {
          chat_id: (P = u.chat) == null ? void 0 : P.id,
          agent_id: d.id
        }
      });
    }
  };
}
var Io, U, Av, un, Pp, Mv, xc, Ru, Bc, qc, kv, ns = {}, Ov = [], ry = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i, wo = Array.isArray;
function Dt(t, e) {
  for (var n in e)
    t[n] = e[n];
  return t;
}
function Dv(t) {
  var e = t.parentNode;
  e && e.removeChild(t);
}
function rs(t, e, n) {
  var r, s, o, a = {};
  for (o in e)
    o == "key" ? r = e[o] : o == "ref" ? s = e[o] : a[o] = e[o];
  if (arguments.length > 2 && (a.children = arguments.length > 3 ? Io.call(arguments, 2) : n), typeof t == "function" && t.defaultProps != null)
    for (o in t.defaultProps)
      a[o] === void 0 && (a[o] = t.defaultProps[o]);
  return eo(t, a, r, s, null);
}
function eo(t, e, n, r, s) {
  var o = { type: t, props: e, key: n, ref: r, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: s ?? ++Av, __i: -1, __u: 0 };
  return s == null && U.vnode != null && U.vnode(o), o;
}
function xt(t) {
  return t.children;
}
function _t(t, e) {
  this.props = t, this.context = e;
}
function gn(t, e) {
  if (e == null)
    return t.__ ? gn(t.__, t.__i + 1) : null;
  for (var n; e < t.__k.length; e++)
    if ((n = t.__k[e]) != null && n.__e != null)
      return n.__e;
  return typeof t.type == "function" ? gn(t) : null;
}
function Nv(t) {
  var e, n;
  if ((t = t.__) != null && t.__c != null) {
    for (t.__e = t.__c.base = null, e = 0; e < t.__k.length; e++)
      if ((n = t.__k[e]) != null && n.__e != null) {
        t.__e = t.__c.base = n.__e;
        break;
      }
    return Nv(t);
  }
}
function Fc(t) {
  (!t.__d && (t.__d = !0) && un.push(t) && !ho.__r++ || Pp !== U.debounceRendering) && ((Pp = U.debounceRendering) || Mv)(ho);
}
function ho() {
  var t, e, n, r, s, o, a, i;
  for (un.sort(xc); t = un.shift(); )
    t.__d && (e = un.length, r = void 0, o = (s = (n = t).__v).__e, a = [], i = [], n.__P && ((r = Dt({}, s)).__v = s.__v + 1, U.vnode && U.vnode(r), Pu(n.__P, r, s, n.__n, n.__P.namespaceURI, 32 & s.__u ? [o] : null, a, o ?? gn(s), !!(32 & s.__u), i), r.__v = s.__v, r.__.__k[r.__i] = r, jv(a, r, i), r.__e != o && Nv(r)), un.length > e && un.sort(xc));
  ho.__r = 0;
}
function Lv(t, e, n, r, s, o, a, i, c, u, p) {
  var d, l, h, v, g, f = r && r.__k || Ov, m = e.length;
  for (n.__d = c, iy(n, e, f), c = n.__d, d = 0; d < m; d++)
    (h = n.__k[d]) != null && typeof h != "boolean" && typeof h != "function" && (l = h.__i === -1 ? ns : f[h.__i] || ns, h.__i = d, Pu(t, h, l, s, o, a, i, c, u, p), v = h.__e, h.ref && l.ref != h.ref && (l.ref && Eu(l.ref, null, h), p.push(h.ref, h.__c || v, h)), g == null && v != null && (g = v), 65536 & h.__u || l.__k === h.__k ? (c && !c.isConnected && (c = gn(l)), c = zv(h, c, t)) : typeof h.type == "function" && h.__d !== void 0 ? c = h.__d : v && (c = v.nextSibling), h.__d = void 0, h.__u &= -196609);
  n.__d = c, n.__e = g;
}
function iy(t, e, n) {
  var r, s, o, a, i, c = e.length, u = n.length, p = u, d = 0;
  for (t.__k = [], r = 0; r < c; r++)
    a = r + d, (s = t.__k[r] = (s = e[r]) == null || typeof s == "boolean" || typeof s == "function" ? null : typeof s == "string" || typeof s == "number" || typeof s == "bigint" || s.constructor == String ? eo(null, s, null, null, null) : wo(s) ? eo(xt, { children: s }, null, null, null) : s.constructor === void 0 && s.__b > 0 ? eo(s.type, s.props, s.key, s.ref ? s.ref : null, s.__v) : s) != null ? (s.__ = t, s.__b = t.__b + 1, i = sy(s, n, a, p), s.__i = i, o = null, i !== -1 && (p--, (o = n[i]) && (o.__u |= 131072)), o == null || o.__v === null ? (i == -1 && d--, typeof s.type != "function" && (s.__u |= 65536)) : i !== a && (i === a + 1 ? d++ : i > a ? p > c - a ? d += i - a : d-- : i < a ? i == a - 1 && (d = i - a) : d = 0, i !== r + d && (s.__u |= 65536))) : (o = n[a]) && o.key == null && o.__e && !(131072 & o.__u) && (o.__e == t.__d && (t.__d = gn(o)), $c(o, o, !1), n[a] = null, p--);
  if (p)
    for (r = 0; r < u; r++)
      (o = n[r]) != null && !(131072 & o.__u) && (o.__e == t.__d && (t.__d = gn(o)), $c(o, o));
}
function zv(t, e, n) {
  var r, s;
  if (typeof t.type == "function") {
    for (r = t.__k, s = 0; r && s < r.length; s++)
      r[s] && (r[s].__ = t, e = zv(r[s], e, n));
    return e;
  }
  t.__e != e && (n.insertBefore(t.__e, e || null), e = t.__e);
  do
    e = e && e.nextSibling;
  while (e != null && e.nodeType === 8);
  return e;
}
function vo(t, e) {
  return e = e || [], t == null || typeof t == "boolean" || (wo(t) ? t.some(function(n) {
    vo(n, e);
  }) : e.push(t)), e;
}
function sy(t, e, n, r) {
  var s = t.key, o = t.type, a = n - 1, i = n + 1, c = e[n];
  if (c === null || c && s == c.key && o === c.type && !(131072 & c.__u))
    return n;
  if (r > (c != null && !(131072 & c.__u) ? 1 : 0))
    for (; a >= 0 || i < e.length; ) {
      if (a >= 0) {
        if ((c = e[a]) && !(131072 & c.__u) && s == c.key && o === c.type)
          return a;
        a--;
      }
      if (i < e.length) {
        if ((c = e[i]) && !(131072 & c.__u) && s == c.key && o === c.type)
          return i;
        i++;
      }
    }
  return -1;
}
function Ep(t, e, n) {
  e[0] === "-" ? t.setProperty(e, n ?? "") : t[e] = n == null ? "" : typeof n != "number" || ry.test(e) ? n : n + "px";
}
function Fs(t, e, n, r, s) {
  var o;
  e:
    if (e === "style")
      if (typeof n == "string")
        t.style.cssText = n;
      else {
        if (typeof r == "string" && (t.style.cssText = r = ""), r)
          for (e in r)
            n && e in n || Ep(t.style, e, "");
        if (n)
          for (e in n)
            r && n[e] === r[e] || Ep(t.style, e, n[e]);
      }
    else if (e[0] === "o" && e[1] === "n")
      o = e !== (e = e.replace(/(PointerCapture)$|Capture$/i, "$1")), e = e.toLowerCase() in t || e === "onFocusOut" || e === "onFocusIn" ? e.toLowerCase().slice(2) : e.slice(2), t.l || (t.l = {}), t.l[e + o] = n, n ? r ? n.u = r.u : (n.u = Ru, t.addEventListener(e, o ? qc : Bc, o)) : t.removeEventListener(e, o ? qc : Bc, o);
    else {
      if (s == "http://www.w3.org/2000/svg")
        e = e.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
      else if (e != "width" && e != "height" && e != "href" && e != "list" && e != "form" && e != "tabIndex" && e != "download" && e != "rowSpan" && e != "colSpan" && e != "role" && e in t)
        try {
          t[e] = n ?? "";
          break e;
        } catch {
        }
      typeof n == "function" || (n == null || n === !1 && e[4] !== "-" ? t.removeAttribute(e) : t.setAttribute(e, n));
    }
}
function Tp(t) {
  return function(e) {
    if (this.l) {
      var n = this.l[e.type + t];
      if (e.t == null)
        e.t = Ru++;
      else if (e.t < n.u)
        return;
      return n(U.event ? U.event(e) : e);
    }
  };
}
function Pu(t, e, n, r, s, o, a, i, c, u) {
  var p, d, l, h, v, g, f, m, S, y, P, C, _, w, T, O = e.type;
  if (e.constructor !== void 0)
    return null;
  128 & n.__u && (c = !!(32 & n.__u), o = [i = e.__e = n.__e]), (p = U.__b) && p(e);
  e:
    if (typeof O == "function")
      try {
        if (m = e.props, S = (p = O.contextType) && r[p.__c], y = p ? S ? S.props.value : p.__ : r, n.__c ? f = (d = e.__c = n.__c).__ = d.__E : ("prototype" in O && O.prototype.render ? e.__c = d = new O(m, y) : (e.__c = d = new _t(m, y), d.constructor = O, d.render = ay), S && S.sub(d), d.props = m, d.state || (d.state = {}), d.context = y, d.__n = r, l = d.__d = !0, d.__h = [], d._sb = []), d.__s == null && (d.__s = d.state), O.getDerivedStateFromProps != null && (d.__s == d.state && (d.__s = Dt({}, d.__s)), Dt(d.__s, O.getDerivedStateFromProps(m, d.__s))), h = d.props, v = d.state, d.__v = e, l)
          O.getDerivedStateFromProps == null && d.componentWillMount != null && d.componentWillMount(), d.componentDidMount != null && d.__h.push(d.componentDidMount);
        else {
          if (O.getDerivedStateFromProps == null && m !== h && d.componentWillReceiveProps != null && d.componentWillReceiveProps(m, y), !d.__e && (d.shouldComponentUpdate != null && d.shouldComponentUpdate(m, d.__s, y) === !1 || e.__v === n.__v)) {
            for (e.__v !== n.__v && (d.props = m, d.state = d.__s, d.__d = !1), e.__e = n.__e, e.__k = n.__k, e.__k.forEach(function(G) {
              G && (G.__ = e);
            }), P = 0; P < d._sb.length; P++)
              d.__h.push(d._sb[P]);
            d._sb = [], d.__h.length && a.push(d);
            break e;
          }
          d.componentWillUpdate != null && d.componentWillUpdate(m, d.__s, y), d.componentDidUpdate != null && d.__h.push(function() {
            d.componentDidUpdate(h, v, g);
          });
        }
        if (d.context = y, d.props = m, d.__P = t, d.__e = !1, C = U.__r, _ = 0, "prototype" in O && O.prototype.render) {
          for (d.state = d.__s, d.__d = !1, C && C(e), p = d.render(d.props, d.state, d.context), w = 0; w < d._sb.length; w++)
            d.__h.push(d._sb[w]);
          d._sb = [];
        } else
          do
            d.__d = !1, C && C(e), p = d.render(d.props, d.state, d.context), d.state = d.__s;
          while (d.__d && ++_ < 25);
        d.state = d.__s, d.getChildContext != null && (r = Dt(Dt({}, r), d.getChildContext())), l || d.getSnapshotBeforeUpdate == null || (g = d.getSnapshotBeforeUpdate(h, v)), Lv(t, wo(T = p != null && p.type === xt && p.key == null ? p.props.children : p) ? T : [T], e, n, r, s, o, a, i, c, u), d.base = e.__e, e.__u &= -161, d.__h.length && a.push(d), f && (d.__E = d.__ = null);
      } catch (G) {
        e.__v = null, c || o != null ? (e.__e = i, e.__u |= c ? 160 : 32, o[o.indexOf(i)] = null) : (e.__e = n.__e, e.__k = n.__k), U.__e(G, e, n);
      }
    else
      o == null && e.__v === n.__v ? (e.__k = n.__k, e.__e = n.__e) : e.__e = oy(n.__e, e, n, r, s, o, a, c, u);
  (p = U.diffed) && p(e);
}
function jv(t, e, n) {
  e.__d = void 0;
  for (var r = 0; r < n.length; r++)
    Eu(n[r], n[++r], n[++r]);
  U.__c && U.__c(e, t), t.some(function(s) {
    try {
      t = s.__h, s.__h = [], t.some(function(o) {
        o.call(s);
      });
    } catch (o) {
      U.__e(o, s.__v);
    }
  });
}
function oy(t, e, n, r, s, o, a, i, c) {
  var u, p, d, l, h, v, g, f = n.props, m = e.props, S = e.type;
  if (S === "svg" ? s = "http://www.w3.org/2000/svg" : S === "math" ? s = "http://www.w3.org/1998/Math/MathML" : s || (s = "http://www.w3.org/1999/xhtml"), o != null) {
    for (u = 0; u < o.length; u++)
      if ((h = o[u]) && "setAttribute" in h == !!S && (S ? h.localName === S : h.nodeType === 3)) {
        t = h, o[u] = null;
        break;
      }
  }
  if (t == null) {
    if (S === null)
      return document.createTextNode(m);
    t = document.createElementNS(s, S, m.is && m), o = null, i = !1;
  }
  if (S === null)
    f === m || i && t.data === m || (t.data = m);
  else {
    if (o = o && Io.call(t.childNodes), f = n.props || ns, !i && o != null)
      for (f = {}, u = 0; u < t.attributes.length; u++)
        f[(h = t.attributes[u]).name] = h.value;
    for (u in f)
      if (h = f[u], u != "children") {
        if (u == "dangerouslySetInnerHTML")
          d = h;
        else if (u !== "key" && !(u in m)) {
          if (u == "value" && "defaultValue" in m || u == "checked" && "defaultChecked" in m)
            continue;
          Fs(t, u, null, h, s);
        }
      }
    for (u in m)
      h = m[u], u == "children" ? l = h : u == "dangerouslySetInnerHTML" ? p = h : u == "value" ? v = h : u == "checked" ? g = h : u === "key" || i && typeof h != "function" || f[u] === h || Fs(t, u, h, f[u], s);
    if (p)
      i || d && (p.__html === d.__html || p.__html === t.innerHTML) || (t.innerHTML = p.__html), e.__k = [];
    else if (d && (t.innerHTML = ""), Lv(t, wo(l) ? l : [l], e, n, r, S === "foreignObject" ? "http://www.w3.org/1999/xhtml" : s, o, a, o ? o[0] : n.__k && gn(n, 0), i, c), o != null)
      for (u = o.length; u--; )
        o[u] != null && Dv(o[u]);
    i || (u = "value", v !== void 0 && (v !== t[u] || S === "progress" && !v || S === "option" && v !== f[u]) && Fs(t, u, v, f[u], s), u = "checked", g !== void 0 && g !== t[u] && Fs(t, u, g, f[u], s));
  }
  return t;
}
function Eu(t, e, n) {
  try {
    typeof t == "function" ? t(e) : t.current = e;
  } catch (r) {
    U.__e(r, n);
  }
}
function $c(t, e, n) {
  var r, s;
  if (U.unmount && U.unmount(t), (r = t.ref) && (r.current && r.current !== t.__e || Eu(r, null, e)), (r = t.__c) != null) {
    if (r.componentWillUnmount)
      try {
        r.componentWillUnmount();
      } catch (o) {
        U.__e(o, e);
      }
    r.base = r.__P = null;
  }
  if (r = t.__k)
    for (s = 0; s < r.length; s++)
      r[s] && $c(r[s], e, n || typeof t.type != "function");
  n || t.__e == null || Dv(t.__e), t.__c = t.__ = t.__e = t.__d = void 0;
}
function ay(t, e, n) {
  return this.constructor(t, n);
}
function fo(t, e, n) {
  var r, s, o, a;
  U.__ && U.__(t, e), s = (r = typeof n == "function") ? null : e.__k, o = [], a = [], Pu(e, t = (!r && n || e).__k = rs(xt, null, [t]), s || ns, ns, e.namespaceURI, !r && n ? [n] : s ? null : e.firstChild ? Io.call(e.childNodes) : null, o, !r && n ? n : s ? s.__e : e.firstChild, r, a), jv(o, t, a);
}
function Tu(t, e) {
  var n = { __c: e = "__cC" + kv++, __: t, Consumer: function(r, s) {
    return r.children(s);
  }, Provider: function(r) {
    var s, o;
    return this.getChildContext || (s = [], (o = {})[e] = this, this.getChildContext = function() {
      return o;
    }, this.shouldComponentUpdate = function(a) {
      this.props.value !== a.value && s.some(function(i) {
        i.__e = !0, Fc(i);
      });
    }, this.sub = function(a) {
      s.push(a);
      var i = a.componentWillUnmount;
      a.componentWillUnmount = function() {
        s.splice(s.indexOf(a), 1), i && i.call(a);
      };
    }), r.children;
  } };
  return n.Provider.__ = n.Consumer.contextType = n;
}
Io = Ov.slice, U = { __e: function(t, e, n, r) {
  for (var s, o, a; e = e.__; )
    if ((s = e.__c) && !s.__)
      try {
        if ((o = s.constructor) && o.getDerivedStateFromError != null && (s.setState(o.getDerivedStateFromError(t)), a = s.__d), s.componentDidCatch != null && (s.componentDidCatch(t, r || {}), a = s.__d), a)
          return s.__E = s;
      } catch (i) {
        t = i;
      }
  throw t;
} }, Av = 0, _t.prototype.setState = function(t, e) {
  var n;
  n = this.__s != null && this.__s !== this.state ? this.__s : this.__s = Dt({}, this.state), typeof t == "function" && (t = t(Dt({}, n), this.props)), t && Dt(n, t), t != null && this.__v && (e && this._sb.push(e), Fc(this));
}, _t.prototype.forceUpdate = function(t) {
  this.__v && (this.__e = !0, t && this.__h.push(t), Fc(this));
}, _t.prototype.render = xt, un = [], Mv = typeof Promise == "function" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, xc = function(t, e) {
  return t.__v.__b - e.__v.__b;
}, ho.__r = 0, Ru = 0, Bc = Tp(!1), qc = Tp(!0), kv = 0;
const cy = "https://a4cf74d1408b08300392573972263164@o226878.ingest.us.sentry.io/4507283201064960", uy = "prod", py = "https://api.d-id.com", dy = "wss://notifications.d-id.com", ly = "1.0.155", Uc = {
  mixpanelKey: "79f81a83a67430be2bc0fd61042b8faa"
};
function xv() {
  return Math.random().toString(16).slice(2);
}
function hy() {
  const t = localStorage.getItem("tracking_id") ?? xv();
  return localStorage.setItem("tracking_id", t), t;
}
const Bv = {
  token: Uc.mixpanelKey,
  $insert_id: xv(),
  origin: window.location.href,
  "Screen Height": window.screen.height || window.innerWidth,
  "Screen Width": window.screen.width || window.innerHeight,
  "User Agent": navigator.userAgent
};
function Ip(t) {
  Object.assign(Bv, t);
}
function lt(t, e) {
  if (window.localStorage.getItem("track_enabled") === "false")
    return;
  const n = {
    method: "POST",
    headers: {
      "Content-Type": "application/x-www-form-urlencoded"
    },
    body: new URLSearchParams({
      data: JSON.stringify([{
        event: t,
        properties: {
          ...e,
          time: Date.now(),
          distinct_id: hy(),
          ...Bv,
          agent_ui_version: ly
        }
      }])
    })
  };
  return fetch("https://api-js.mixpanel.com/track/?verbose=1&ip=1", n).then((r) => r.json()).catch((r) => console.error(r));
}
var Bt, ie, sc, wp, is = 0, qv = [], to = [], ve = U, bp = ve.__b, Ap = ve.__r, Mp = ve.diffed, kp = ve.__c, Op = ve.unmount, Dp = ve.__;
function Xn(t, e) {
  ve.__h && ve.__h(ie, t, is || e), is = 0;
  var n = ie.__H || (ie.__H = { __: [], __h: [] });
  return t >= n.__.length && n.__.push({ __V: to }), n.__[t];
}
function H(t) {
  return is = 1, vy(Fv, t);
}
function vy(t, e, n) {
  var r = Xn(Bt++, 2);
  if (r.t = t, !r.__c && (r.__ = [n ? n(e) : Fv(void 0, e), function(i) {
    var c = r.__N ? r.__N[0] : r.__[0], u = r.t(c, i);
    c !== u && (r.__N = [u, r.__[1]], r.__c.setState({}));
  }], r.__c = ie, !ie.u)) {
    var s = function(i, c, u) {
      if (!r.__c.__H)
        return !0;
      var p = r.__c.__H.__.filter(function(l) {
        return !!l.__c;
      });
      if (p.every(function(l) {
        return !l.__N;
      }))
        return !o || o.call(this, i, c, u);
      var d = !1;
      return p.forEach(function(l) {
        if (l.__N) {
          var h = l.__[0];
          l.__ = l.__N, l.__N = void 0, h !== l.__[0] && (d = !0);
        }
      }), !(!d && r.__c.props === i) && (!o || o.call(this, i, c, u));
    };
    ie.u = !0;
    var o = ie.shouldComponentUpdate, a = ie.componentWillUpdate;
    ie.componentWillUpdate = function(i, c, u) {
      if (this.__e) {
        var p = o;
        o = void 0, s(i, c, u), o = p;
      }
      a && a.call(this, i, c, u);
    }, ie.shouldComponentUpdate = s;
  }
  return r.__N || r.__;
}
function oe(t, e) {
  var n = Xn(Bt++, 3);
  !ve.__s && Iu(n.__H, e) && (n.__ = t, n.i = e, ie.__H.__h.push(n));
}
function fy(t, e) {
  var n = Xn(Bt++, 4);
  !ve.__s && Iu(n.__H, e) && (n.__ = t, n.i = e, ie.__h.push(n));
}
function pt(t) {
  return is = 5, bo(function() {
    return { current: t };
  }, []);
}
function bo(t, e) {
  var n = Xn(Bt++, 7);
  return Iu(n.__H, e) ? (n.__V = t(), n.i = e, n.__h = t, n.__V) : n.__;
}
function mn(t, e) {
  return is = 8, bo(function() {
    return t;
  }, e);
}
function je(t) {
  var e = ie.context[t.__c], n = Xn(Bt++, 9);
  return n.c = t, e ? (n.__ == null && (n.__ = !0, e.sub(ie)), e.props.value) : t.__;
}
function gy(t) {
  var e = Xn(Bt++, 10), n = H();
  return e.__ = t, ie.componentDidCatch || (ie.componentDidCatch = function(r, s) {
    e.__ && e.__(r, s), n[1](r);
  }), [n[0], function() {
    n[1](void 0);
  }];
}
function my() {
  for (var t; t = qv.shift(); )
    if (t.__P && t.__H)
      try {
        t.__H.__h.forEach(no), t.__H.__h.forEach(Hc), t.__H.__h = [];
      } catch (e) {
        t.__H.__h = [], ve.__e(e, t.__v);
      }
}
ve.__b = function(t) {
  ie = null, bp && bp(t);
}, ve.__ = function(t, e) {
  t && e.__k && e.__k.__m && (t.__m = e.__k.__m), Dp && Dp(t, e);
}, ve.__r = function(t) {
  Ap && Ap(t), Bt = 0;
  var e = (ie = t.__c).__H;
  e && (sc === ie ? (e.__h = [], ie.__h = [], e.__.forEach(function(n) {
    n.__N && (n.__ = n.__N), n.__V = to, n.__N = n.i = void 0;
  })) : (e.__h.forEach(no), e.__h.forEach(Hc), e.__h = [], Bt = 0)), sc = ie;
}, ve.diffed = function(t) {
  Mp && Mp(t);
  var e = t.__c;
  e && e.__H && (e.__H.__h.length && (qv.push(e) !== 1 && wp === ve.requestAnimationFrame || ((wp = ve.requestAnimationFrame) || Sy)(my)), e.__H.__.forEach(function(n) {
    n.i && (n.__H = n.i), n.__V !== to && (n.__ = n.__V), n.i = void 0, n.__V = to;
  })), sc = ie = null;
}, ve.__c = function(t, e) {
  e.some(function(n) {
    try {
      n.__h.forEach(no), n.__h = n.__h.filter(function(r) {
        return !r.__ || Hc(r);
      });
    } catch (r) {
      e.some(function(s) {
        s.__h && (s.__h = []);
      }), e = [], ve.__e(r, n.__v);
    }
  }), kp && kp(t, e);
}, ve.unmount = function(t) {
  Op && Op(t);
  var e, n = t.__c;
  n && n.__H && (n.__H.__.forEach(function(r) {
    try {
      no(r);
    } catch (s) {
      e = s;
    }
  }), n.__H = void 0, e && ve.__e(e, n.__v));
};
var Np = typeof requestAnimationFrame == "function";
function Sy(t) {
  var e, n = function() {
    clearTimeout(r), Np && cancelAnimationFrame(e), setTimeout(t);
  }, r = setTimeout(n, 100);
  Np && (e = requestAnimationFrame(n));
}
function no(t) {
  var e = ie, n = t.__c;
  typeof n == "function" && (t.__c = void 0, n()), ie = e;
}
function Hc(t) {
  var e = ie;
  t.__c = t.__(), ie = e;
}
function Iu(t, e) {
  return !t || t.length !== e.length || e.some(function(n, r) {
    return n !== t[r];
  });
}
function Fv(t, e) {
  return typeof e == "function" ? e(t) : e;
}
var yy = 0;
function E(t, e, n, r, s, o) {
  e || (e = {});
  var a, i, c = e;
  if ("ref" in c)
    for (i in c = {}, e)
      i == "ref" ? a = e[i] : c[i] = e[i];
  var u = { type: t, props: c, key: n, ref: a, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: --yy, __i: -1, __u: 0, __source: s, __self: o };
  if (typeof t == "function" && (a = t.defaultProps))
    for (i in a)
      c[i] === void 0 && (c[i] = a[i]);
  return U.vnode && U.vnode(u), u;
}
const $v = {
  mode: "fabio",
  visible: !0,
  agentId: "",
  track: !0,
  chatMode: M.Functional,
  loaderConfig: {
    show: !0,
    style: "opaque",
    text: "Loading..."
  },
  orientation: "vertical",
  position: "right"
}, $t = Tu({
  configure: () => {
  },
  configurations: $v
}), Cy = ({
  children: t,
  initialConfigurations: e
}) => {
  const [n, r] = H({
    ...$v,
    ...e
  }), s = mn((o) => r((a) => ({
    ...a,
    ...o
  })), [r]);
  return oe(() => {
    window.DID_AGENTS_API.configure = s;
  }, [s]), oe(() => {
    window.DID_AGENTS_API.showLoader = (o, a) => {
      const i = {
        ...n.loaderConfig,
        show: !0
      };
      a && (i.style = a), o !== void 0 && (i.text = o), s({
        loaderConfig: i
      });
    }, window.DID_AGENTS_API.hideLoader = () => {
      s({
        loaderConfig: {
          ...n.loaderConfig,
          show: !1
        }
      });
    };
  }, [s, n.loaderConfig]), E($t.Provider, {
    value: {
      configurations: n,
      configure: s
    },
    children: t
  });
};
var ue = /* @__PURE__ */ ((t) => (t[t.New = 0] = "New", t[t.Loading = 1] = "Loading", t[t.Buffering = 2] = "Buffering", t[t.Start = 3] = "Start", t[t.Fail = 4] = "Fail", t))(ue || {});
const ls = Tu({
  authenticate: () => {
  },
  auth: {},
  host: "",
  wsHost: "",
  isAuthenticated: !1
});
ls.displayName = "DidFetch";
function _y({
  children: t,
  auth: e,
  didApiUrl: n,
  didSocketApiUrl: r
}) {
  const [s, o] = H(e), a = async (i) => {
    o((c) => JSON.stringify(i) === JSON.stringify(c) ? c : i);
  };
  return E(ls.Provider, {
    value: {
      auth: s,
      host: n,
      wsHost: r,
      authenticate: a,
      isAuthenticated: !!s
    },
    children: t
  });
}
const Pn = Tu({
  connectionState: Q.New,
  streamState: ue.New,
  connect: async () => {
  },
  reconnect: async () => {
  },
  disconnect: async () => {
  },
  setStreamState: () => {
  },
  streamedMessage: "",
  messages: [],
  error: "",
  chatId: void 0,
  setError: () => {
  },
  terminating: !1,
  enabled: !1
});
Pn.displayName = "Streaming Manager";
const Ry = ["TooManyRequestsError", "InsufficientCreditsError"];
function Py({
  agentId: t,
  children: e,
  enabled: n,
  onAgentReady: r,
  onError: s
}) {
  const [o, a] = H(Q.New), [i, c] = H(ue.New), [u, p] = H(), [d, l] = H(""), [h, v] = H(), [g, f] = H(""), [m, S] = H(!1), [y, P] = H([]), [C, _] = H(void 0), {
    configurations: w,
    configure: T
  } = je($t), {
    auth: O,
    host: G,
    wsHost: X
  } = je(ls), q = mn((Z, L) => {
    s == null || s(Z, L);
    try {
      const {
        kind: re
      } = JSON.parse(Z.message);
      Ry.includes(re) && T({
        chatMode: M.Maintenance
      });
    } catch {
    }
  }, [s, T]), b = mn(async () => {
    h && (S(!0), await h.disconnect().catch(), S(!1));
  }, [h]);
  async function x() {
    var Z;
    if (h && ![M.TextOnly, M.Playground].includes(w.chatMode))
      return h;
    if (O && G && X) {
      let L;
      try {
        f(""), L = await ny(t, {
          mode: w.chatMode,
          auth: O,
          baseURL: G,
          wsURL: X,
          streamOptions: {
            streamWarmup: !0
          },
          callbacks: {
            onVideoStateChange(ce) {
              const et = ce === he.Start ? ue.Start : ue.New;
              c(et);
            },
            onConnectionStateChange: (ce) => {
              a((et) => ce === Q.Disconnected ? et === Q.Connected ? ce : et : ce);
            },
            onNewMessage: P,
            onSrcObjectReady: p,
            onModeChange: (ce) => T({
              chatMode: ce
            }),
            onNewChat: (ce) => {
              _(ce), Ip({
                chat_id: ce
              });
            },
            onError: q
          },
          initialMessages: w.chatMode === M.Playground ? [] : y,
          persistentChat: !0,
          enableAnalitics: w.track
        }), Ip({
          agentId: L.agent.id,
          agentType: L.agent.presenter.type
        });
        const re = {
          ...L,
          chat: async (ce) => {
            var et;
            if (window.dataLayer.push({
              event: "agent_interaction",
              message: ce
            }), !L)
              throw new Error("Manager is not initialized");
            return [M.TextOnly, M.Playground].includes(w.chatMode) ? (l(""), L.chat(ce).catch((We) => {
              throw (We == null ? void 0 : We.kind) === "InsufficientCreditsError" && (L == null || L.changeMode(M.TextOnly)), We;
            })) : (et = L.agent.presenter) != null && et.voice ? (l(""), await L.chat(ce).catch((We) => {
              throw (We == null ? void 0 : We.kind) === "InsufficientCreditsError" && (L == null || L.changeMode(M.TextOnly)), We;
            })) : Promise.reject(new Error("Agent has no voice, can not chat"));
          }
        };
        return (Z = re.agent.presenter) != null && Z.idle_video || (w.chatMode === M.Playground ? re.changeMode(w.chatMode) : re.changeMode(M.TextOnly)), v(re), r == null || r(re.agent), re;
      } catch (re) {
        console.error(re), re instanceof TypeError && c(ue.Fail), L == null || L.changeMode(M.Maintenance), f("Agent is unavailable at the moment");
      }
    }
  }
  async function ee(Z = !1) {
    l("");
    const L = await x();
    if (L && w.chatMode !== M.Playground)
      return w.chatMode === M.Maintenance && L.changeMode(M.Functional), Z ? L.reconnect() : L.connect();
  }
  return oe(() => {
    const Z = x();
    window.DID_AGENTS_API.updateAgent = () => {
      [M.TextOnly, M.Playground].includes(w.chatMode) && x();
    }, n && [M.Functional, M.Maintenance].includes(w.chatMode) && Z.then(async (L) => {
      L && o !== Q.Connected && await L.reconnect();
    });
  }, [O, G, X, n, w.chatMode]), oe(() => (window.addEventListener("beforeunload", () => {
    b();
  }), () => b()), [b]), E(Pn.Provider, {
    value: {
      streamedMessage: d,
      srcObject: u,
      streamState: i,
      connectionState: o,
      setStreamState: c,
      disconnect: b,
      connect: () => ee(!1),
      reconnect: () => ee(!0),
      error: g,
      setError: f,
      chatId: C,
      agentManager: h,
      messages: y,
      terminating: m,
      enabled: n
    },
    children: e
  });
}
const Uv = "data:image/svg+xml,%3csvg%20version='1.1'%20id='L9'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20x='0px'%20y='0px'%20viewBox='0%200%20100%20100'%20enable-background='new%200%200%200%200'%20xml:space='preserve'%3e%3cpath%20fill='%23fff'%20d='M73,50c0-12.7-10.3-23-23-23S27,37.3,27,50%20M30.9,50c0-10.5,8.5-19.1,19.1-19.1S69.1,39.5,69.1,50'%3e%3canimateTransform%20attributeName='transform'%20attributeType='XML'%20type='rotate'%20dur='1s'%20from='0%2050%2050'%20to='360%2050%2050'%20repeatCount='indefinite'%20/%3e%3c/path%3e%3c/svg%3e", Wc = [Q.Fail, Q.Disconnected, Q.Completed], Ey = "#e6e6e6";
function Ty(t) {
  const e = t.style.height;
  t.style.height = "0";
  const n = t.scrollHeight / parseInt(getComputedStyle(t).lineHeight);
  return t.style.height = e, parseInt(n + "");
}
function Iy() {
  try {
    return /iPhone|iPad|iPod/i.test(navigator.userAgent);
  } catch (t) {
    console.error("Error occurred while detecting iOS:", t);
  }
  return !1;
}
function wy() {
  const t = navigator.userAgent.match(/OS (\d+)_\d+(_\d+)? like Mac OS X/i);
  return t ? parseInt(t[1], 10) : void 0;
}
const by = (t, e) => new Promise((n) => {
  const r = document.createElement("canvas"), s = r.getContext("2d");
  if (!r || !s) {
    console.error("Failed adding background to presenter poster - could not create canvas or context"), n(t);
    return;
  }
  const o = new Image();
  o.src = t, o.onload = () => {
    r.width = o.width, r.height = o.height, s.fillStyle = e, s.fillRect(0, 0, r.width, r.height), s.drawImage(o, 0, 0), n(r.toDataURL());
  }, o.onerror = () => {
    console.error("Failed adding background to presenter poster - could not load image"), n(t);
  };
}), Hv = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='iso-8859-1'?%3e%3c!--%20Uploaded%20to:%20SVG%20Repo,%20www.svgrepo.com,%20Generator:%20SVG%20Repo%20Mixer%20Tools%20--%3e%3csvg%20height='800px'%20width='800px'%20version='1.1'%20id='Capa_1'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20viewBox='0%200%20199.943%20199.943'%20xml:space='preserve'%3e%3cg%3e%3cg%3e%3cpath%20style='fill:%23010002;'%20d='M99.972,0.004C44.85,0.004,0,44.847,0,99.968c0,55.125,44.847,99.972,99.972,99.972%20s99.972-44.847,99.972-99.972C199.943,44.847,155.093,0.004,99.972,0.004z%20M99.972,190.957c-50.168,0-90.996-40.813-90.996-90.989%20c0-50.172,40.828-90.992,90.996-90.992c50.175,0,91.003,40.817,91.003,90.992S150.147,190.957,99.972,190.957z'/%3e%3cpath%20style='fill:%23010002;'%20d='M99.324,67.354c-3.708,0-6.725,3.01-6.725,6.728v75.979c0,3.722,3.017,6.739,6.725,6.739%20c3.722,0,6.739-3.017,6.739-6.739V74.082C106.063,70.364,103.042,67.354,99.324,67.354z'/%3e%3ccircle%20style='fill:%23010002;'%20cx='99.746'%20cy='48.697'%20r='8.178'/%3e%3c/g%3e%3c/g%3e%3c/svg%3e";
function Qe({
  src: t,
  size: e,
  color: n = "currentcolor",
  padding: r = "0",
  rotated: s,
  margin: o = "0",
  width: a,
  className: i = ""
}) {
  return E("svg", {
    className: "didagent__maskedicon " + i,
    style: {
      "--mask-url": `url("${t}")`,
      "--color": n,
      "--width": a,
      "--size": e,
      "--padding": r,
      "--margin": o,
      "--rotation": s ? "180deg" : "0deg"
    }
  });
}
const Ay = ({
  text: t,
  hide: e
}) => e ? null : E("div", {
  className: "didagent__info_message_agent_unavailable_container",
  children: E("div", {
    className: "didagent__info_message_agent_unavailable_danger",
    children: [E(Qe, {
      src: Hv,
      size: "20px"
    }), E("div", {
      children: t
    })]
  })
});
function My({
  content: t,
  display: e
}) {
  const [n, r] = H(!1), [s, o] = H("");
  return oe(() => {
    if (!e)
      r(!1);
    else {
      r(!0), o("fade-in");
      const a = setTimeout(() => {
        o("fade-out");
        const i = setTimeout(() => r(!1), 500);
        return () => clearTimeout(i);
      }, 3e3);
      return () => clearTimeout(a);
    }
  }, [e]), n ? E("div", {
    className: `didagent__info_message_indication ${s}`,
    children: [E(Qe, {
      src: Hv,
      size: "16px"
    }), E("pre", {
      className: "didagent__info_message_agent_unavailable_message",
      children: t
    })]
  }) : null;
}
function ky({
  content: t,
  hide: e
}) {
  return e || !t ? null : E("div", {
    className: "didagent__banner",
    children: t
  });
}
const Oy = "data:image/svg+xml,%3csvg%20width='32'%20height='32'%20viewBox='0%200%2032%2032'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M10.4453%2011.5556C10.4453%208.48731%2012.9326%206%2016.0009%206C19.0691%206%2021.5564%208.48731%2021.5564%2011.5556V14.8889C21.5564%2017.9571%2019.0691%2020.4444%2016.0009%2020.4444C12.9326%2020.4444%2010.4453%2017.9571%2010.4453%2014.8889V11.5556Z'%20fill='white'%20stroke='white'%20stroke-width='1.66667'/%3e%3cpath%20d='M24.8911%2013.7812V14.8924C24.8911%2019.8016%2020.9114%2023.7813%2016.0022%2023.7813C11.093%2023.7813%207.11328%2019.8016%207.11328%2014.8924V13.7812'%20stroke='white'%20stroke-width='1.66667'%20stroke-linecap='round'/%3e%3cpath%20d='M16%2023.7812V27.1146'%20stroke='white'%20stroke-width='1.66667'%20stroke-linecap='round'/%3e%3c/svg%3e", Dy = "data:image/svg+xml,%3csvg%20width='23'%20height='24'%20viewBox='0%200%2023%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M9.68322%2018.9259L14.3358%2016.4985C18.4002%2014.3779%2020.4324%2013.3176%2020.4324%2011.6386C20.4324%209.95953%2018.4002%208.89925%2014.3358%206.77869L9.68324%204.35127C6.40287%202.63977%204.76268%201.78403%203.81181%202.0467C2.90723%202.29659%202.20074%203.0338%201.96126%203.97771C1.70953%204.96992%202.52962%206.68142%204.1698%2010.1044C4.37307%2010.5286%204.78866%2010.8108%205.24318%2010.813L12.6703%2010.8491C13.0882%2010.8511%2013.4253%2011.2062%2013.4234%2011.6423C13.4214%2012.0783%2013.0811%2012.4301%2012.6633%2012.428L5.35607%2012.3926C4.8551%2012.3901%204.39385%2012.7052%204.1698%2013.1728C2.52963%2016.5957%201.70953%2018.3072%201.96126%2019.2994C2.20074%2020.2434%202.90723%2020.9806%203.81181%2021.2305C4.76268%2021.4931%206.40287%2020.6374%209.68322%2018.9259Z'%20fill='white'/%3e%3c/svg%3e", Ny = "data:image/svg+xml,%3csvg%20id='wave'%20data-name='Layer%201'%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%2050%2038.05'%3e%3cstyle%3e%20%23Line_1%20{%20animation:%20pulse%201s%20infinite;%20animation-delay:%200.15s;%20}%20%23Line_2%20{%20animation:%20pulse%201s%20infinite;%20animation-delay:%200.3s;%20}%20%23Line_3%20{%20animation:%20pulse%201s%20infinite;%20animation-delay:%200.45s;%20}%20%23Line_4%20{%20animation:%20pulse%201s%20infinite;%20animation-delay:%200.6s;%20}%20%23Line_5%20{%20animation:%20pulse%201s%20infinite;%20animation-delay:%200.75s;%20}%20%23Line_6%20{%20animation:%20pulse%201s%20infinite;%20animation-delay:%200.9s;%20}%20%23Line_7%20{%20animation:%20pulse%201s%20infinite;%20animation-delay:%201.05s;%20}%20%23Line_8%20{%20animation:%20pulse%201s%20infinite;%20animation-delay:%201.2s;%20}%20%23Line_9%20{%20animation:%20pulse%201s%20infinite;%20animation-delay:%201.35s;%20}%20@keyframes%20pulse%20{%200%25%20{%20transform:%20scaleY(1);%20transform-origin:%2050%25%2050%25;%20}%2050%25%20{%20transform:%20scaleY(0.7);%20transform-origin:%2050%25%2050%25;%20}%20100%25%20{%20transform:%20scaleY(1);%20transform-origin:%2050%25%2050%25;%20}%20}%20%3c/style%3e%3cpath%20id='Line_1'%20data-name='Line%201'%20d='M0.91,15L0.78,15A1,1,0,0,0,0,16v6a1,1,0,1,0,2,0s0,0,0,0V16a1,1,0,0,0-1-1H0.91Z'%20/%3e%3cpath%20id='Line_2'%20data-name='Line%202'%20d='M6.91,9L6.78,9A1,1,0,0,0,6,10V28a1,1,0,1,0,2,0s0,0,0,0V10A1,1,0,0,0,7,9H6.91Z'%20/%3e%3cpath%20id='Line_3'%20data-name='Line%203'%20d='M12.91,0L12.78,0A1,1,0,0,0,12,1V37a1,1,0,1,0,2,0s0,0,0,0V1a1,1,0,0,0-1-1H12.91Z'%20/%3e%3cpath%20id='Line_4'%20data-name='Line%204'%20d='M18.91,10l-0.12,0A1,1,0,0,0,18,11V27a1,1,0,1,0,2,0s0,0,0,0V11a1,1,0,0,0-1-1H18.91Z'%20/%3e%3cpath%20id='Line_5'%20data-name='Line%205'%20d='M24.91,15l-0.12,0A1,1,0,0,0,24,16v6a1,1,0,0,0,2,0s0,0,0,0V16a1,1,0,0,0-1-1H24.91Z'%20/%3e%3cpath%20id='Line_6'%20data-name='Line%206'%20d='M30.91,10l-0.12,0A1,1,0,0,0,30,11V27a1,1,0,1,0,2,0s0,0,0,0V11a1,1,0,0,0-1-1H30.91Z'%20/%3e%3cpath%20id='Line_7'%20data-name='Line%207'%20d='M36.91,0L36.78,0A1,1,0,0,0,36,1V37a1,1,0,1,0,2,0s0,0,0,0V1a1,1,0,0,0-1-1H36.91Z'%20/%3e%3cpath%20id='Line_8'%20data-name='Line%208'%20d='M42.91,9L42.78,9A1,1,0,0,0,42,10V28a1,1,0,1,0,2,0s0,0,0,0V10a1,1,0,0,0-1-1H42.91Z'%20/%3e%3cpath%20id='Line_9'%20data-name='Line%209'%20d='M48.91,15l-0.12,0A1,1,0,0,0,48,16v6a1,1,0,1,0,2,0s0,0,0,0V16a1,1,0,0,0-1-1H48.91Z'%20/%3e%3c/svg%3e", Wv = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M16.9399%206.96684L6.87207%2017.0347M6.87203%206.9668L16.9399%2017.0346'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'/%3e%3c/svg%3e";
var W = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Ly(t) {
  if (t.__esModule)
    return t;
  var e = t.default;
  if (typeof e == "function") {
    var n = function r() {
      return this instanceof r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    n.prototype = e.prototype;
  } else
    n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(t).forEach(function(r) {
    var s = Object.getOwnPropertyDescriptor(t, r);
    Object.defineProperty(n, r, s.get ? s : {
      enumerable: !0,
      get: function() {
        return t[r];
      }
    });
  }), n;
}
var jn = {}, oc = {}, Ao = {}, ac = {}, le = {}, er = {}, Ye = {}, Vv = {}, Mo = {}, ko = {};
Object.defineProperty(ko, "__esModule", {
  value: !0
});
ko.default = jy;
let $s;
const zy = new Uint8Array(16);
function jy() {
  if (!$s && ($s = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !$s))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return $s(zy);
}
var Ut = {}, En = {}, Oo = {};
Object.defineProperty(Oo, "__esModule", {
  value: !0
});
Oo.default = void 0;
var xy = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
Oo.default = xy;
Object.defineProperty(En, "__esModule", {
  value: !0
});
En.default = void 0;
var By = qy(Oo);
function qy(t) {
  return t && t.__esModule ? t : { default: t };
}
function Fy(t) {
  return typeof t == "string" && By.default.test(t);
}
var $y = Fy;
En.default = $y;
Object.defineProperty(Ut, "__esModule", {
  value: !0
});
Ut.default = void 0;
Ut.unsafeStringify = Kv;
var Uy = Hy(En);
function Hy(t) {
  return t && t.__esModule ? t : { default: t };
}
const _e = [];
for (let t = 0; t < 256; ++t)
  _e.push((t + 256).toString(16).slice(1));
function Kv(t, e = 0) {
  return _e[t[e + 0]] + _e[t[e + 1]] + _e[t[e + 2]] + _e[t[e + 3]] + "-" + _e[t[e + 4]] + _e[t[e + 5]] + "-" + _e[t[e + 6]] + _e[t[e + 7]] + "-" + _e[t[e + 8]] + _e[t[e + 9]] + "-" + _e[t[e + 10]] + _e[t[e + 11]] + _e[t[e + 12]] + _e[t[e + 13]] + _e[t[e + 14]] + _e[t[e + 15]];
}
function Wy(t, e = 0) {
  const n = Kv(t, e);
  if (!(0, Uy.default)(n))
    throw TypeError("Stringified UUID is invalid");
  return n;
}
var Vy = Wy;
Ut.default = Vy;
Object.defineProperty(Mo, "__esModule", {
  value: !0
});
Mo.default = void 0;
var Ky = Gy(ko), Jy = Ut;
function Gy(t) {
  return t && t.__esModule ? t : { default: t };
}
let Lp, cc, uc = 0, pc = 0;
function Qy(t, e, n) {
  let r = e && n || 0;
  const s = e || new Array(16);
  t = t || {};
  let o = t.node || Lp, a = t.clockseq !== void 0 ? t.clockseq : cc;
  if (o == null || a == null) {
    const l = t.random || (t.rng || Ky.default)();
    o == null && (o = Lp = [l[0] | 1, l[1], l[2], l[3], l[4], l[5]]), a == null && (a = cc = (l[6] << 8 | l[7]) & 16383);
  }
  let i = t.msecs !== void 0 ? t.msecs : Date.now(), c = t.nsecs !== void 0 ? t.nsecs : pc + 1;
  const u = i - uc + (c - pc) / 1e4;
  if (u < 0 && t.clockseq === void 0 && (a = a + 1 & 16383), (u < 0 || i > uc) && t.nsecs === void 0 && (c = 0), c >= 1e4)
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  uc = i, pc = c, cc = a, i += 122192928e5;
  const p = ((i & 268435455) * 1e4 + c) % 4294967296;
  s[r++] = p >>> 24 & 255, s[r++] = p >>> 16 & 255, s[r++] = p >>> 8 & 255, s[r++] = p & 255;
  const d = i / 4294967296 * 1e4 & 268435455;
  s[r++] = d >>> 8 & 255, s[r++] = d & 255, s[r++] = d >>> 24 & 15 | 16, s[r++] = d >>> 16 & 255, s[r++] = a >>> 8 | 128, s[r++] = a & 255;
  for (let l = 0; l < 6; ++l)
    s[r + l] = o[l];
  return e || (0, Jy.unsafeStringify)(s);
}
var Yy = Qy;
Mo.default = Yy;
var Do = {}, qt = {}, hs = {};
Object.defineProperty(hs, "__esModule", {
  value: !0
});
hs.default = void 0;
var Zy = Xy(En);
function Xy(t) {
  return t && t.__esModule ? t : { default: t };
}
function eC(t) {
  if (!(0, Zy.default)(t))
    throw TypeError("Invalid UUID");
  let e;
  const n = new Uint8Array(16);
  return n[0] = (e = parseInt(t.slice(0, 8), 16)) >>> 24, n[1] = e >>> 16 & 255, n[2] = e >>> 8 & 255, n[3] = e & 255, n[4] = (e = parseInt(t.slice(9, 13), 16)) >>> 8, n[5] = e & 255, n[6] = (e = parseInt(t.slice(14, 18), 16)) >>> 8, n[7] = e & 255, n[8] = (e = parseInt(t.slice(19, 23), 16)) >>> 8, n[9] = e & 255, n[10] = (e = parseInt(t.slice(24, 36), 16)) / 1099511627776 & 255, n[11] = e / 4294967296 & 255, n[12] = e >>> 24 & 255, n[13] = e >>> 16 & 255, n[14] = e >>> 8 & 255, n[15] = e & 255, n;
}
var tC = eC;
hs.default = tC;
Object.defineProperty(qt, "__esModule", {
  value: !0
});
qt.URL = qt.DNS = void 0;
qt.default = oC;
var nC = Ut, rC = iC(hs);
function iC(t) {
  return t && t.__esModule ? t : { default: t };
}
function sC(t) {
  t = unescape(encodeURIComponent(t));
  const e = [];
  for (let n = 0; n < t.length; ++n)
    e.push(t.charCodeAt(n));
  return e;
}
const Jv = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
qt.DNS = Jv;
const Gv = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
qt.URL = Gv;
function oC(t, e, n) {
  function r(s, o, a, i) {
    var c;
    if (typeof s == "string" && (s = sC(s)), typeof o == "string" && (o = (0, rC.default)(o)), ((c = o) === null || c === void 0 ? void 0 : c.length) !== 16)
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    let u = new Uint8Array(16 + s.length);
    if (u.set(o), u.set(s, o.length), u = n(u), u[6] = u[6] & 15 | e, u[8] = u[8] & 63 | 128, a) {
      i = i || 0;
      for (let p = 0; p < 16; ++p)
        a[i + p] = u[p];
      return a;
    }
    return (0, nC.unsafeStringify)(u);
  }
  try {
    r.name = t;
  } catch {
  }
  return r.DNS = Jv, r.URL = Gv, r;
}
var No = {};
Object.defineProperty(No, "__esModule", {
  value: !0
});
No.default = void 0;
function aC(t) {
  if (typeof t == "string") {
    const e = unescape(encodeURIComponent(t));
    t = new Uint8Array(e.length);
    for (let n = 0; n < e.length; ++n)
      t[n] = e.charCodeAt(n);
  }
  return cC(uC(pC(t), t.length * 8));
}
function cC(t) {
  const e = [], n = t.length * 32, r = "0123456789abcdef";
  for (let s = 0; s < n; s += 8) {
    const o = t[s >> 5] >>> s % 32 & 255, a = parseInt(r.charAt(o >>> 4 & 15) + r.charAt(o & 15), 16);
    e.push(a);
  }
  return e;
}
function Qv(t) {
  return (t + 64 >>> 9 << 4) + 14 + 1;
}
function uC(t, e) {
  t[e >> 5] |= 128 << e % 32, t[Qv(e) - 1] = e;
  let n = 1732584193, r = -271733879, s = -1732584194, o = 271733878;
  for (let a = 0; a < t.length; a += 16) {
    const i = n, c = r, u = s, p = o;
    n = we(n, r, s, o, t[a], 7, -680876936), o = we(o, n, r, s, t[a + 1], 12, -389564586), s = we(s, o, n, r, t[a + 2], 17, 606105819), r = we(r, s, o, n, t[a + 3], 22, -1044525330), n = we(n, r, s, o, t[a + 4], 7, -176418897), o = we(o, n, r, s, t[a + 5], 12, 1200080426), s = we(s, o, n, r, t[a + 6], 17, -1473231341), r = we(r, s, o, n, t[a + 7], 22, -45705983), n = we(n, r, s, o, t[a + 8], 7, 1770035416), o = we(o, n, r, s, t[a + 9], 12, -1958414417), s = we(s, o, n, r, t[a + 10], 17, -42063), r = we(r, s, o, n, t[a + 11], 22, -1990404162), n = we(n, r, s, o, t[a + 12], 7, 1804603682), o = we(o, n, r, s, t[a + 13], 12, -40341101), s = we(s, o, n, r, t[a + 14], 17, -1502002290), r = we(r, s, o, n, t[a + 15], 22, 1236535329), n = be(n, r, s, o, t[a + 1], 5, -165796510), o = be(o, n, r, s, t[a + 6], 9, -1069501632), s = be(s, o, n, r, t[a + 11], 14, 643717713), r = be(r, s, o, n, t[a], 20, -373897302), n = be(n, r, s, o, t[a + 5], 5, -701558691), o = be(o, n, r, s, t[a + 10], 9, 38016083), s = be(s, o, n, r, t[a + 15], 14, -660478335), r = be(r, s, o, n, t[a + 4], 20, -405537848), n = be(n, r, s, o, t[a + 9], 5, 568446438), o = be(o, n, r, s, t[a + 14], 9, -1019803690), s = be(s, o, n, r, t[a + 3], 14, -187363961), r = be(r, s, o, n, t[a + 8], 20, 1163531501), n = be(n, r, s, o, t[a + 13], 5, -1444681467), o = be(o, n, r, s, t[a + 2], 9, -51403784), s = be(s, o, n, r, t[a + 7], 14, 1735328473), r = be(r, s, o, n, t[a + 12], 20, -1926607734), n = Ae(n, r, s, o, t[a + 5], 4, -378558), o = Ae(o, n, r, s, t[a + 8], 11, -2022574463), s = Ae(s, o, n, r, t[a + 11], 16, 1839030562), r = Ae(r, s, o, n, t[a + 14], 23, -35309556), n = Ae(n, r, s, o, t[a + 1], 4, -1530992060), o = Ae(o, n, r, s, t[a + 4], 11, 1272893353), s = Ae(s, o, n, r, t[a + 7], 16, -155497632), r = Ae(r, s, o, n, t[a + 10], 23, -1094730640), n = Ae(n, r, s, o, t[a + 13], 4, 681279174), o = Ae(o, n, r, s, t[a], 11, -358537222), s = Ae(s, o, n, r, t[a + 3], 16, -722521979), r = Ae(r, s, o, n, t[a + 6], 23, 76029189), n = Ae(n, r, s, o, t[a + 9], 4, -640364487), o = Ae(o, n, r, s, t[a + 12], 11, -421815835), s = Ae(s, o, n, r, t[a + 15], 16, 530742520), r = Ae(r, s, o, n, t[a + 2], 23, -995338651), n = Me(n, r, s, o, t[a], 6, -198630844), o = Me(o, n, r, s, t[a + 7], 10, 1126891415), s = Me(s, o, n, r, t[a + 14], 15, -1416354905), r = Me(r, s, o, n, t[a + 5], 21, -57434055), n = Me(n, r, s, o, t[a + 12], 6, 1700485571), o = Me(o, n, r, s, t[a + 3], 10, -1894986606), s = Me(s, o, n, r, t[a + 10], 15, -1051523), r = Me(r, s, o, n, t[a + 1], 21, -2054922799), n = Me(n, r, s, o, t[a + 8], 6, 1873313359), o = Me(o, n, r, s, t[a + 15], 10, -30611744), s = Me(s, o, n, r, t[a + 6], 15, -1560198380), r = Me(r, s, o, n, t[a + 13], 21, 1309151649), n = Me(n, r, s, o, t[a + 4], 6, -145523070), o = Me(o, n, r, s, t[a + 11], 10, -1120210379), s = Me(s, o, n, r, t[a + 2], 15, 718787259), r = Me(r, s, o, n, t[a + 9], 21, -343485551), n = Nt(n, i), r = Nt(r, c), s = Nt(s, u), o = Nt(o, p);
  }
  return [n, r, s, o];
}
function pC(t) {
  if (t.length === 0)
    return [];
  const e = t.length * 8, n = new Uint32Array(Qv(e));
  for (let r = 0; r < e; r += 8)
    n[r >> 5] |= (t[r / 8] & 255) << r % 32;
  return n;
}
function Nt(t, e) {
  const n = (t & 65535) + (e & 65535);
  return (t >> 16) + (e >> 16) + (n >> 16) << 16 | n & 65535;
}
function dC(t, e) {
  return t << e | t >>> 32 - e;
}
function Lo(t, e, n, r, s, o) {
  return Nt(dC(Nt(Nt(e, t), Nt(r, o)), s), n);
}
function we(t, e, n, r, s, o, a) {
  return Lo(e & n | ~e & r, t, e, s, o, a);
}
function be(t, e, n, r, s, o, a) {
  return Lo(e & r | n & ~r, t, e, s, o, a);
}
function Ae(t, e, n, r, s, o, a) {
  return Lo(e ^ n ^ r, t, e, s, o, a);
}
function Me(t, e, n, r, s, o, a) {
  return Lo(n ^ (e | ~r), t, e, s, o, a);
}
var lC = aC;
No.default = lC;
Object.defineProperty(Do, "__esModule", {
  value: !0
});
Do.default = void 0;
var hC = Yv(qt), vC = Yv(No);
function Yv(t) {
  return t && t.__esModule ? t : { default: t };
}
const fC = (0, hC.default)("v3", 48, vC.default);
var gC = fC;
Do.default = gC;
var zo = {}, jo = {};
Object.defineProperty(jo, "__esModule", {
  value: !0
});
jo.default = void 0;
const mC = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var SC = {
  randomUUID: mC
};
jo.default = SC;
Object.defineProperty(zo, "__esModule", {
  value: !0
});
zo.default = void 0;
var zp = Zv(jo), yC = Zv(ko), CC = Ut;
function Zv(t) {
  return t && t.__esModule ? t : { default: t };
}
function _C(t, e, n) {
  if (zp.default.randomUUID && !e && !t)
    return zp.default.randomUUID();
  t = t || {};
  const r = t.random || (t.rng || yC.default)();
  if (r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, e) {
    n = n || 0;
    for (let s = 0; s < 16; ++s)
      e[n + s] = r[s];
    return e;
  }
  return (0, CC.unsafeStringify)(r);
}
var RC = _C;
zo.default = RC;
var xo = {}, Bo = {};
Object.defineProperty(Bo, "__esModule", {
  value: !0
});
Bo.default = void 0;
function PC(t, e, n, r) {
  switch (t) {
    case 0:
      return e & n ^ ~e & r;
    case 1:
      return e ^ n ^ r;
    case 2:
      return e & n ^ e & r ^ n & r;
    case 3:
      return e ^ n ^ r;
  }
}
function dc(t, e) {
  return t << e | t >>> 32 - e;
}
function EC(t) {
  const e = [1518500249, 1859775393, 2400959708, 3395469782], n = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof t == "string") {
    const a = unescape(encodeURIComponent(t));
    t = [];
    for (let i = 0; i < a.length; ++i)
      t.push(a.charCodeAt(i));
  } else
    Array.isArray(t) || (t = Array.prototype.slice.call(t));
  t.push(128);
  const r = t.length / 4 + 2, s = Math.ceil(r / 16), o = new Array(s);
  for (let a = 0; a < s; ++a) {
    const i = new Uint32Array(16);
    for (let c = 0; c < 16; ++c)
      i[c] = t[a * 64 + c * 4] << 24 | t[a * 64 + c * 4 + 1] << 16 | t[a * 64 + c * 4 + 2] << 8 | t[a * 64 + c * 4 + 3];
    o[a] = i;
  }
  o[s - 1][14] = (t.length - 1) * 8 / Math.pow(2, 32), o[s - 1][14] = Math.floor(o[s - 1][14]), o[s - 1][15] = (t.length - 1) * 8 & 4294967295;
  for (let a = 0; a < s; ++a) {
    const i = new Uint32Array(80);
    for (let h = 0; h < 16; ++h)
      i[h] = o[a][h];
    for (let h = 16; h < 80; ++h)
      i[h] = dc(i[h - 3] ^ i[h - 8] ^ i[h - 14] ^ i[h - 16], 1);
    let c = n[0], u = n[1], p = n[2], d = n[3], l = n[4];
    for (let h = 0; h < 80; ++h) {
      const v = Math.floor(h / 20), g = dc(c, 5) + PC(v, u, p, d) + l + e[v] + i[h] >>> 0;
      l = d, d = p, p = dc(u, 30) >>> 0, u = c, c = g;
    }
    n[0] = n[0] + c >>> 0, n[1] = n[1] + u >>> 0, n[2] = n[2] + p >>> 0, n[3] = n[3] + d >>> 0, n[4] = n[4] + l >>> 0;
  }
  return [n[0] >> 24 & 255, n[0] >> 16 & 255, n[0] >> 8 & 255, n[0] & 255, n[1] >> 24 & 255, n[1] >> 16 & 255, n[1] >> 8 & 255, n[1] & 255, n[2] >> 24 & 255, n[2] >> 16 & 255, n[2] >> 8 & 255, n[2] & 255, n[3] >> 24 & 255, n[3] >> 16 & 255, n[3] >> 8 & 255, n[3] & 255, n[4] >> 24 & 255, n[4] >> 16 & 255, n[4] >> 8 & 255, n[4] & 255];
}
var TC = EC;
Bo.default = TC;
Object.defineProperty(xo, "__esModule", {
  value: !0
});
xo.default = void 0;
var IC = Xv(qt), wC = Xv(Bo);
function Xv(t) {
  return t && t.__esModule ? t : { default: t };
}
const bC = (0, IC.default)("v5", 80, wC.default);
var AC = bC;
xo.default = AC;
var qo = {};
Object.defineProperty(qo, "__esModule", {
  value: !0
});
qo.default = void 0;
var MC = "00000000-0000-0000-0000-000000000000";
qo.default = MC;
var Fo = {};
Object.defineProperty(Fo, "__esModule", {
  value: !0
});
Fo.default = void 0;
var kC = OC(En);
function OC(t) {
  return t && t.__esModule ? t : { default: t };
}
function DC(t) {
  if (!(0, kC.default)(t))
    throw TypeError("Invalid UUID");
  return parseInt(t.slice(14, 15), 16);
}
var NC = DC;
Fo.default = NC;
(function(t) {
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), Object.defineProperty(t, "NIL", {
    enumerable: !0,
    get: function() {
      return o.default;
    }
  }), Object.defineProperty(t, "parse", {
    enumerable: !0,
    get: function() {
      return u.default;
    }
  }), Object.defineProperty(t, "stringify", {
    enumerable: !0,
    get: function() {
      return c.default;
    }
  }), Object.defineProperty(t, "v1", {
    enumerable: !0,
    get: function() {
      return e.default;
    }
  }), Object.defineProperty(t, "v3", {
    enumerable: !0,
    get: function() {
      return n.default;
    }
  }), Object.defineProperty(t, "v4", {
    enumerable: !0,
    get: function() {
      return r.default;
    }
  }), Object.defineProperty(t, "v5", {
    enumerable: !0,
    get: function() {
      return s.default;
    }
  }), Object.defineProperty(t, "validate", {
    enumerable: !0,
    get: function() {
      return i.default;
    }
  }), Object.defineProperty(t, "version", {
    enumerable: !0,
    get: function() {
      return a.default;
    }
  });
  var e = p(Mo), n = p(Do), r = p(zo), s = p(xo), o = p(qo), a = p(Fo), i = p(En), c = p(Ut), u = p(hs);
  function p(d) {
    return d && d.__esModule ? d : { default: d };
  }
})(Vv);
Object.defineProperty(Ye, "__esModule", { value: !0 });
Ye.createNoDashGuid = Ye.createGuid = void 0;
const LC = Vv, ef = () => LC.v4();
Ye.createGuid = ef;
const zC = () => ef().replace(new RegExp("-", "g"), "").toUpperCase();
Ye.createNoDashGuid = zC;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.PlatformEvent = t.EventType = void 0;
  const e = Ye;
  (function(r) {
    r[r.Debug = 0] = "Debug", r[r.Info = 1] = "Info", r[r.Warning = 2] = "Warning", r[r.Error = 3] = "Error", r[r.None = 4] = "None";
  })(t.EventType || (t.EventType = {}));
  class n {
    constructor(s, o) {
      this.privName = s, this.privEventId = e.createNoDashGuid(), this.privEventTime = (/* @__PURE__ */ new Date()).toISOString(), this.privEventType = o, this.privMetadata = {};
    }
    get name() {
      return this.privName;
    }
    get eventId() {
      return this.privEventId;
    }
    get eventTime() {
      return this.privEventTime;
    }
    get eventType() {
      return this.privEventType;
    }
    get metadata() {
      return this.privMetadata;
    }
  }
  t.PlatformEvent = n;
})(er);
Object.defineProperty(le, "__esModule", { value: !0 });
le.AudioStreamNodeErrorEvent = le.AudioStreamNodeDetachedEvent = le.AudioStreamNodeAttachedEvent = le.AudioStreamNodeAttachingEvent = le.AudioStreamNodeEvent = le.AudioSourceErrorEvent = le.AudioSourceOffEvent = le.AudioSourceReadyEvent = le.AudioSourceInitializingEvent = le.AudioSourceEvent = void 0;
const Vc = er;
class tr extends Vc.PlatformEvent {
  constructor(e, n, r = Vc.EventType.Info) {
    super(e, r), this.privAudioSourceId = n;
  }
  get audioSourceId() {
    return this.privAudioSourceId;
  }
}
le.AudioSourceEvent = tr;
class jC extends tr {
  constructor(e) {
    super("AudioSourceInitializingEvent", e);
  }
}
le.AudioSourceInitializingEvent = jC;
class xC extends tr {
  constructor(e) {
    super("AudioSourceReadyEvent", e);
  }
}
le.AudioSourceReadyEvent = xC;
class BC extends tr {
  constructor(e) {
    super("AudioSourceOffEvent", e);
  }
}
le.AudioSourceOffEvent = BC;
class qC extends tr {
  constructor(e, n) {
    super("AudioSourceErrorEvent", e, Vc.EventType.Error), this.privError = n;
  }
  get error() {
    return this.privError;
  }
}
le.AudioSourceErrorEvent = qC;
class vs extends tr {
  constructor(e, n, r) {
    super(e, n), this.privAudioNodeId = r;
  }
  get audioNodeId() {
    return this.privAudioNodeId;
  }
}
le.AudioStreamNodeEvent = vs;
class FC extends vs {
  constructor(e, n) {
    super("AudioStreamNodeAttachingEvent", e, n);
  }
}
le.AudioStreamNodeAttachingEvent = FC;
class $C extends vs {
  constructor(e, n) {
    super("AudioStreamNodeAttachedEvent", e, n);
  }
}
le.AudioStreamNodeAttachedEvent = $C;
class UC extends vs {
  constructor(e, n) {
    super("AudioStreamNodeDetachedEvent", e, n);
  }
}
le.AudioStreamNodeDetachedEvent = UC;
class HC extends vs {
  constructor(e, n, r) {
    super("AudioStreamNodeErrorEvent", e, n), this.privError = r;
  }
  get error() {
    return this.privError;
  }
}
le.AudioStreamNodeErrorEvent = HC;
var fe = {};
Object.defineProperty(fe, "__esModule", { value: !0 });
fe.ConnectionMessageSentEvent = fe.ConnectionMessageReceivedEvent = fe.ConnectionEstablishErrorEvent = fe.ConnectionErrorEvent = fe.ConnectionClosedEvent = fe.ConnectionEstablishedEvent = fe.ConnectionStartEvent = fe.ConnectionEvent = fe.ServiceEvent = void 0;
const Sn = er;
class WC extends Sn.PlatformEvent {
  constructor(e, n, r = Sn.EventType.Info) {
    super(e, r), this.privJsonResult = n;
  }
  get jsonString() {
    return this.privJsonResult;
  }
}
fe.ServiceEvent = WC;
class Ht extends Sn.PlatformEvent {
  constructor(e, n, r = Sn.EventType.Info) {
    super(e, r), this.privConnectionId = n;
  }
  get connectionId() {
    return this.privConnectionId;
  }
}
fe.ConnectionEvent = Ht;
class VC extends Ht {
  constructor(e, n, r) {
    super("ConnectionStartEvent", e), this.privUri = n, this.privHeaders = r;
  }
  get uri() {
    return this.privUri;
  }
  get headers() {
    return this.privHeaders;
  }
}
fe.ConnectionStartEvent = VC;
class KC extends Ht {
  constructor(e) {
    super("ConnectionEstablishedEvent", e);
  }
}
fe.ConnectionEstablishedEvent = KC;
class JC extends Ht {
  constructor(e, n, r) {
    super("ConnectionClosedEvent", e, Sn.EventType.Debug), this.privReason = r, this.privStatusCode = n;
  }
  get reason() {
    return this.privReason;
  }
  get statusCode() {
    return this.privStatusCode;
  }
}
fe.ConnectionClosedEvent = JC;
class GC extends Ht {
  constructor(e, n, r) {
    super("ConnectionErrorEvent", e, Sn.EventType.Debug), this.privMessage = n, this.privType = r;
  }
  get message() {
    return this.privMessage;
  }
  get type() {
    return this.privType;
  }
}
fe.ConnectionErrorEvent = GC;
class QC extends Ht {
  constructor(e, n, r) {
    super("ConnectionEstablishErrorEvent", e, Sn.EventType.Error), this.privStatusCode = n, this.privReason = r;
  }
  get reason() {
    return this.privReason;
  }
  get statusCode() {
    return this.privStatusCode;
  }
}
fe.ConnectionEstablishErrorEvent = QC;
class YC extends Ht {
  constructor(e, n, r) {
    super("ConnectionMessageReceivedEvent", e), this.privNetworkReceivedTime = n, this.privMessage = r;
  }
  get networkReceivedTime() {
    return this.privNetworkReceivedTime;
  }
  get message() {
    return this.privMessage;
  }
}
fe.ConnectionMessageReceivedEvent = YC;
class ZC extends Ht {
  constructor(e, n, r) {
    super("ConnectionMessageSentEvent", e), this.privNetworkSentTime = n, this.privMessage = r;
  }
  get networkSentTime() {
    return this.privNetworkSentTime;
  }
  get message() {
    return this.privMessage;
  }
}
fe.ConnectionMessageSentEvent = ZC;
var wu = {}, Ee = {};
Object.defineProperty(Ee, "__esModule", { value: !0 });
Ee.ObjectDisposedError = Ee.InvalidOperationError = Ee.ArgumentNullError = void 0;
class XC extends Error {
  /**
   * Creates an instance of ArgumentNullError.
   *
   * @param {string} argumentName - Name of the argument that is null
   *
   * @memberOf ArgumentNullError
   */
  constructor(e) {
    super(e), this.name = "ArgumentNull", this.message = e;
  }
}
Ee.ArgumentNullError = XC;
class e_ extends Error {
  /**
   * Creates an instance of InvalidOperationError.
   *
   * @param {string} error - The error
   *
   * @memberOf InvalidOperationError
   */
  constructor(e) {
    super(e), this.name = "InvalidOperation", this.message = e;
  }
}
Ee.InvalidOperationError = e_;
class t_ extends Error {
  /**
   * Creates an instance of ObjectDisposedError.
   *
   * @param {string} objectName - The object that is disposed
   * @param {string} error - The error
   *
   * @memberOf ObjectDisposedError
   */
  constructor(e, n) {
    super(n), this.name = e + "ObjectDisposed", this.message = n;
  }
}
Ee.ObjectDisposedError = t_;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.ConnectionMessage = t.MessageType = void 0;
  const e = Ee, n = Ye;
  var r;
  (function(o) {
    o[o.Text = 0] = "Text", o[o.Binary = 1] = "Binary";
  })(r = t.MessageType || (t.MessageType = {}));
  class s {
    constructor(a, i, c, u) {
      if (this.privBody = null, a === r.Text && i && typeof i != "string")
        throw new e.InvalidOperationError("Payload must be a string");
      if (a === r.Binary && i && !(i instanceof ArrayBuffer))
        throw new e.InvalidOperationError("Payload must be ArrayBuffer");
      switch (this.privMessageType = a, this.privBody = i, this.privHeaders = c || {}, this.privId = u || n.createNoDashGuid(), this.messageType) {
        case r.Binary:
          this.privSize = this.binaryBody !== null ? this.binaryBody.byteLength : 0;
          break;
        case r.Text:
          this.privSize = this.textBody.length;
      }
    }
    get messageType() {
      return this.privMessageType;
    }
    get headers() {
      return this.privHeaders;
    }
    get body() {
      return this.privBody;
    }
    get textBody() {
      if (this.privMessageType === r.Binary)
        throw new e.InvalidOperationError("Not supported for binary message");
      return this.privBody;
    }
    get binaryBody() {
      if (this.privMessageType === r.Text)
        throw new e.InvalidOperationError("Not supported for text message");
      return this.privBody;
    }
    get id() {
      return this.privId;
    }
  }
  t.ConnectionMessage = s;
})(wu);
var $o = {};
Object.defineProperty($o, "__esModule", { value: !0 });
$o.ConnectionOpenResponse = void 0;
class n_ {
  constructor(e, n) {
    this.privStatusCode = e, this.privReason = n;
  }
  get statusCode() {
    return this.privStatusCode;
  }
  get reason() {
    return this.privReason;
  }
}
$o.ConnectionOpenResponse = n_;
var Uo = {};
Object.defineProperty(Uo, "__esModule", { value: !0 });
Uo.DeferralMap = void 0;
class r_ {
  constructor() {
    this.privMap = {};
  }
  add(e, n) {
    this.privMap[e] = n;
  }
  getId(e) {
    return this.privMap[e];
  }
  complete(e, n) {
    try {
      this.privMap[e].resolve(n);
    } catch (r) {
      this.privMap[e].reject(r);
    } finally {
      this.privMap[e] = void 0;
    }
  }
}
Uo.DeferralMap = r_;
var yn = {};
Object.defineProperty(yn, "__esModule", { value: !0 });
yn.SendingAgentContextMessageEvent = yn.DialogEvent = void 0;
const jp = er;
class tf extends jp.PlatformEvent {
  constructor(e, n = jp.EventType.Info) {
    super(e, n);
  }
}
yn.DialogEvent = tf;
class i_ extends tf {
  constructor(e) {
    super("SendingAgentContextMessageEvent"), this.privAgentConfig = e;
  }
  get agentConfig() {
    return this.privAgentConfig;
  }
}
yn.SendingAgentContextMessageEvent = i_;
var Ho = {}, fs = {};
Object.defineProperty(fs, "__esModule", { value: !0 });
fs.EventSource = void 0;
const s_ = Ee, o_ = Ye;
class a_ {
  constructor(e) {
    this.privEventListeners = {}, this.privIsDisposed = !1, this.privConsoleListener = void 0, this.privMetadata = e;
  }
  onEvent(e) {
    if (this.isDisposed())
      throw new s_.ObjectDisposedError("EventSource");
    if (this.metadata)
      for (const n in this.metadata)
        n && e.metadata && (e.metadata[n] || (e.metadata[n] = this.metadata[n]));
    for (const n in this.privEventListeners)
      n && this.privEventListeners[n] && this.privEventListeners[n](e);
  }
  attach(e) {
    const n = o_.createNoDashGuid();
    return this.privEventListeners[n] = e, {
      detach: () => (delete this.privEventListeners[n], Promise.resolve())
    };
  }
  attachListener(e) {
    return this.attach((n) => e.onEvent(n));
  }
  attachConsoleListener(e) {
    return this.privConsoleListener && this.privConsoleListener.detach(), this.privConsoleListener = this.attach((n) => e.onEvent(n)), this.privConsoleListener;
  }
  isDisposed() {
    return this.privIsDisposed;
  }
  dispose() {
    this.privEventListeners = null, this.privIsDisposed = !0;
  }
  get metadata() {
    return this.privMetadata;
  }
}
fs.EventSource = a_;
Object.defineProperty(Ho, "__esModule", { value: !0 });
Ho.Events = void 0;
const c_ = Ee, u_ = fs;
class ss {
  static setEventSource(e) {
    if (!e)
      throw new c_.ArgumentNullError("eventSource");
    ss.privInstance = e;
  }
  static get instance() {
    return ss.privInstance;
  }
}
Ho.Events = ss;
ss.privInstance = new u_.EventSource();
var nf = {};
Object.defineProperty(nf, "__esModule", { value: !0 });
var rf = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.ConnectionState = void 0, function(e) {
    e[e.None = 0] = "None", e[e.Connected = 1] = "Connected", e[e.Connecting = 2] = "Connecting", e[e.Disconnected = 3] = "Disconnected";
  }(t.ConnectionState || (t.ConnectionState = {}));
})(rf);
var sf = {};
Object.defineProperty(sf, "__esModule", { value: !0 });
var of = {};
Object.defineProperty(of, "__esModule", { value: !0 });
var af = {};
Object.defineProperty(af, "__esModule", { value: !0 });
var cf = {};
Object.defineProperty(cf, "__esModule", { value: !0 });
var uf = {};
Object.defineProperty(uf, "__esModule", { value: !0 });
var pf = {};
Object.defineProperty(pf, "__esModule", { value: !0 });
var df = {};
Object.defineProperty(df, "__esModule", { value: !0 });
var lf = {};
Object.defineProperty(lf, "__esModule", { value: !0 });
var gs = {};
Object.defineProperty(gs, "__esModule", { value: !0 });
gs.List = void 0;
const p_ = Ee;
class Mt {
  constructor(e) {
    if (this.privSubscriptionIdCounter = 0, this.privAddSubscriptions = {}, this.privRemoveSubscriptions = {}, this.privDisposedSubscriptions = {}, this.privDisposeReason = null, this.privList = [], e)
      for (const n of e)
        this.privList.push(n);
  }
  get(e) {
    return this.throwIfDisposed(), this.privList[e];
  }
  first() {
    return this.get(0);
  }
  last() {
    return this.get(this.length() - 1);
  }
  add(e) {
    this.throwIfDisposed(), this.insertAt(this.privList.length, e);
  }
  insertAt(e, n) {
    this.throwIfDisposed(), e === 0 ? this.privList.unshift(n) : e === this.privList.length ? this.privList.push(n) : this.privList.splice(e, 0, n), this.triggerSubscriptions(this.privAddSubscriptions);
  }
  removeFirst() {
    return this.throwIfDisposed(), this.removeAt(0);
  }
  removeLast() {
    return this.throwIfDisposed(), this.removeAt(this.length() - 1);
  }
  removeAt(e) {
    return this.throwIfDisposed(), this.remove(e, 1)[0];
  }
  remove(e, n) {
    this.throwIfDisposed();
    const r = this.privList.splice(e, n);
    return this.triggerSubscriptions(this.privRemoveSubscriptions), r;
  }
  clear() {
    this.throwIfDisposed(), this.remove(0, this.length());
  }
  length() {
    return this.throwIfDisposed(), this.privList.length;
  }
  onAdded(e) {
    this.throwIfDisposed();
    const n = this.privSubscriptionIdCounter++;
    return this.privAddSubscriptions[n] = e, {
      detach: () => (delete this.privAddSubscriptions[n], Promise.resolve())
    };
  }
  onRemoved(e) {
    this.throwIfDisposed();
    const n = this.privSubscriptionIdCounter++;
    return this.privRemoveSubscriptions[n] = e, {
      detach: () => (delete this.privRemoveSubscriptions[n], Promise.resolve())
    };
  }
  onDisposed(e) {
    this.throwIfDisposed();
    const n = this.privSubscriptionIdCounter++;
    return this.privDisposedSubscriptions[n] = e, {
      detach: () => (delete this.privDisposedSubscriptions[n], Promise.resolve())
    };
  }
  join(e) {
    return this.throwIfDisposed(), this.privList.join(e);
  }
  toArray() {
    const e = Array();
    return this.privList.forEach((n) => {
      e.push(n);
    }), e;
  }
  any(e) {
    return this.throwIfDisposed(), e ? this.where(e).length() > 0 : this.length() > 0;
  }
  all(e) {
    return this.throwIfDisposed(), this.where(e).length() === this.length();
  }
  forEach(e) {
    this.throwIfDisposed();
    for (let n = 0; n < this.length(); n++)
      e(this.privList[n], n);
  }
  select(e) {
    this.throwIfDisposed();
    const n = [];
    for (let r = 0; r < this.privList.length; r++)
      n.push(e(this.privList[r], r));
    return new Mt(n);
  }
  where(e) {
    this.throwIfDisposed();
    const n = new Mt();
    for (let r = 0; r < this.privList.length; r++)
      e(this.privList[r], r) && n.add(this.privList[r]);
    return n;
  }
  orderBy(e) {
    this.throwIfDisposed();
    const r = this.toArray().sort(e);
    return new Mt(r);
  }
  orderByDesc(e) {
    return this.throwIfDisposed(), this.orderBy((n, r) => e(r, n));
  }
  clone() {
    return this.throwIfDisposed(), new Mt(this.toArray());
  }
  concat(e) {
    return this.throwIfDisposed(), new Mt(this.privList.concat(e.toArray()));
  }
  concatArray(e) {
    return this.throwIfDisposed(), new Mt(this.privList.concat(e));
  }
  isDisposed() {
    return this.privList == null;
  }
  dispose(e) {
    this.isDisposed() || (this.privDisposeReason = e, this.privList = null, this.privAddSubscriptions = null, this.privRemoveSubscriptions = null, this.triggerSubscriptions(this.privDisposedSubscriptions));
  }
  throwIfDisposed() {
    if (this.isDisposed())
      throw new p_.ObjectDisposedError("List", this.privDisposeReason);
  }
  triggerSubscriptions(e) {
    if (e)
      for (const n in e)
        n && e[n]();
  }
}
gs.List = Mt;
var bu = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.marshalPromiseToCallbacks = t.Sink = t.Deferred = t.PromiseResultEventSource = t.PromiseResult = t.PromiseState = void 0;
  var e;
  (function(i) {
    i[i.None = 0] = "None", i[i.Resolved = 1] = "Resolved", i[i.Rejected = 2] = "Rejected";
  })(e = t.PromiseState || (t.PromiseState = {}));
  class n {
    constructor(c) {
      this.throwIfError = () => {
        if (this.isError)
          throw this.error;
      }, c.on((u) => {
        this.privIsCompleted || (this.privIsCompleted = !0, this.privIsError = !1, this.privResult = u);
      }, (u) => {
        this.privIsCompleted || (this.privIsCompleted = !0, this.privIsError = !0, this.privError = u);
      });
    }
    get isCompleted() {
      return this.privIsCompleted;
    }
    get isError() {
      return this.privIsError;
    }
    get error() {
      return this.privError;
    }
    get result() {
      return this.privResult;
    }
  }
  t.PromiseResult = n;
  class r {
    constructor() {
      this.setResult = (c) => {
        this.privOnSetResult(c);
      }, this.setError = (c) => {
        this.privOnSetError(c);
      }, this.on = (c, u) => {
        this.privOnSetResult = c, this.privOnSetError = u;
      };
    }
  }
  t.PromiseResultEventSource = r;
  class s {
    constructor() {
      this.resolve = (c) => (this.privResolve(c), this), this.reject = (c) => (this.privReject(c), this), this.privPromise = new Promise((c, u) => {
        this.privResolve = c, this.privReject = u;
      });
    }
    get promise() {
      return this.privPromise;
    }
  }
  t.Deferred = s;
  class o {
    constructor() {
      this.privState = e.None, this.privPromiseResult = null, this.privPromiseResultEvents = null, this.privSuccessHandlers = [], this.privErrorHandlers = [], this.privPromiseResultEvents = new r(), this.privPromiseResult = new n(this.privPromiseResultEvents);
    }
    get state() {
      return this.privState;
    }
    get result() {
      return this.privPromiseResult;
    }
    resolve(c) {
      if (this.privState !== e.None)
        throw new Error("'Cannot resolve a completed promise'");
      this.privState = e.Resolved, this.privPromiseResultEvents.setResult(c);
      for (let u = 0; u < this.privSuccessHandlers.length; u++)
        this.executeSuccessCallback(c, this.privSuccessHandlers[u], this.privErrorHandlers[u]);
      this.detachHandlers();
    }
    reject(c) {
      if (this.privState !== e.None)
        throw new Error("'Cannot reject a completed promise'");
      this.privState = e.Rejected, this.privPromiseResultEvents.setError(c);
      for (const u of this.privErrorHandlers)
        this.executeErrorCallback(c, u);
      this.detachHandlers();
    }
    on(c, u) {
      c == null && (c = () => {
      }), this.privState === e.None ? (this.privSuccessHandlers.push(c), this.privErrorHandlers.push(u)) : (this.privState === e.Resolved ? this.executeSuccessCallback(this.privPromiseResult.result, c, u) : this.privState === e.Rejected && this.executeErrorCallback(this.privPromiseResult.error, u), this.detachHandlers());
    }
    executeSuccessCallback(c, u, p) {
      try {
        u(c);
      } catch (d) {
        this.executeErrorCallback(`'Unhandled callback error: ${d}'`, p);
      }
    }
    executeErrorCallback(c, u) {
      if (u)
        try {
          u(c);
        } catch (p) {
          throw new Error(`'Unhandled callback error: ${p}. InnerError: ${c}'`);
        }
      else
        throw new Error(`'Unhandled error: ${c}'`);
    }
    detachHandlers() {
      this.privErrorHandlers = [], this.privSuccessHandlers = [];
    }
  }
  t.Sink = o;
  function a(i, c, u) {
    i.then((p) => {
      try {
        c && c(p);
      } catch (d) {
        if (u)
          try {
            if (d instanceof Error) {
              const l = d;
              u(l.name + ": " + l.message);
            } else
              u(d);
          } catch {
          }
      }
    }, (p) => {
      if (u)
        try {
          if (p instanceof Error) {
            const d = p;
            u(d.name + ": " + d.message);
          } else
            u(p);
        } catch {
        }
    });
  }
  t.marshalPromiseToCallbacks = a;
})(bu);
var ms = {};
Object.defineProperty(ms, "__esModule", { value: !0 });
ms.Queue = void 0;
const lc = Ee, hc = gs, xp = bu;
var Xi;
(function(t) {
  t[t.Dequeue = 0] = "Dequeue", t[t.Peek = 1] = "Peek";
})(Xi || (Xi = {}));
class d_ {
  constructor(e) {
    this.privPromiseStore = new hc.List(), this.privIsDrainInProgress = !1, this.privIsDisposing = !1, this.privDisposeReason = null, this.privList = e || new hc.List(), this.privDetachables = [], this.privSubscribers = new hc.List(), this.privDetachables.push(this.privList.onAdded(() => this.drain()));
  }
  enqueue(e) {
    this.throwIfDispose(), this.enqueueFromPromise(new Promise((n) => n(e)));
  }
  enqueueFromPromise(e) {
    this.throwIfDispose(), e.then((n) => {
      this.privList.add(n);
    }, () => {
    });
  }
  dequeue() {
    this.throwIfDispose();
    const e = new xp.Deferred();
    return this.privSubscribers && (this.privSubscribers.add({ deferral: e, type: Xi.Dequeue }), this.drain()), e.promise;
  }
  peek() {
    this.throwIfDispose();
    const e = new xp.Deferred();
    return this.privSubscribers && (this.privSubscribers.add({ deferral: e, type: Xi.Peek }), this.drain()), e.promise;
  }
  length() {
    return this.throwIfDispose(), this.privList.length();
  }
  isDisposed() {
    return this.privSubscribers == null;
  }
  async drainAndDispose(e, n) {
    if (!this.isDisposed() && !this.privIsDisposing) {
      this.privDisposeReason = n, this.privIsDisposing = !0;
      const r = this.privSubscribers;
      if (r) {
        for (; r.length() > 0; )
          r.removeFirst().deferral.resolve(void 0);
        this.privSubscribers === r && (this.privSubscribers = r);
      }
      for (const s of this.privDetachables)
        await s.detach();
      if (this.privPromiseStore.length() > 0 && e) {
        const s = [];
        return this.privPromiseStore.toArray().forEach((o) => {
          s.push(o);
        }), Promise.all(s).finally(() => {
          this.privSubscribers = null, this.privList.forEach((o) => {
            e(o);
          }), this.privList = null;
        }).then();
      } else
        this.privSubscribers = null, this.privList = null;
    }
  }
  async dispose(e) {
    await this.drainAndDispose(null, e);
  }
  drain() {
    if (!this.privIsDrainInProgress && !this.privIsDisposing) {
      this.privIsDrainInProgress = !0;
      const e = this.privSubscribers, n = this.privList;
      if (e && n) {
        for (; n.length() > 0 && e.length() > 0 && !this.privIsDisposing; ) {
          const r = e.removeFirst();
          if (r.type === Xi.Peek)
            r.deferral.resolve(n.first());
          else {
            const s = n.removeFirst();
            r.deferral.resolve(s);
          }
        }
        this.privSubscribers === e && (this.privSubscribers = e), this.privList === n && (this.privList = n);
      }
      this.privIsDrainInProgress = !1;
    }
  }
  throwIfDispose() {
    if (this.isDisposed())
      throw this.privDisposeReason ? new lc.InvalidOperationError(this.privDisposeReason) : new lc.ObjectDisposedError("Queue");
    if (this.privIsDisposing)
      throw new lc.InvalidOperationError("Queue disposing");
  }
}
ms.Queue = d_;
var Wo = {};
Object.defineProperty(Wo, "__esModule", { value: !0 });
Wo.RawWebsocketMessage = void 0;
const Us = wu, hr = Ee, l_ = Ye;
class h_ {
  constructor(e, n, r) {
    if (this.privPayload = null, !n)
      throw new hr.ArgumentNullError("payload");
    if (e === Us.MessageType.Binary && Object.getPrototypeOf(n).constructor.name !== "ArrayBuffer")
      throw new hr.InvalidOperationError("Payload must be ArrayBuffer");
    if (e === Us.MessageType.Text && typeof n != "string")
      throw new hr.InvalidOperationError("Payload must be a string");
    this.privMessageType = e, this.privPayload = n, this.privId = r || l_.createNoDashGuid();
  }
  get messageType() {
    return this.privMessageType;
  }
  get payload() {
    return this.privPayload;
  }
  get textContent() {
    if (this.privMessageType === Us.MessageType.Binary)
      throw new hr.InvalidOperationError("Not supported for binary message");
    return this.privPayload;
  }
  get binaryContent() {
    if (this.privMessageType === Us.MessageType.Text)
      throw new hr.InvalidOperationError("Not supported for text message");
    return this.privPayload;
  }
  get id() {
    return this.privId;
  }
}
Wo.RawWebsocketMessage = h_;
var Vo = {};
Object.defineProperty(Vo, "__esModule", { value: !0 });
Vo.RiffPcmEncoder = void 0;
class v_ {
  constructor(e, n) {
    this.privActualSampleRate = e, this.privDesiredSampleRate = n;
  }
  encode(e) {
    const n = this.downSampleAudioFrame(e, this.privActualSampleRate, this.privDesiredSampleRate);
    if (!n)
      return null;
    const r = n.length * 2, s = new ArrayBuffer(r), o = new DataView(s);
    return this.floatTo16BitPCM(o, 0, n), s;
  }
  setString(e, n, r) {
    for (let s = 0; s < r.length; s++)
      e.setUint8(n + s, r.charCodeAt(s));
  }
  floatTo16BitPCM(e, n, r) {
    for (let s = 0; s < r.length; s++, n += 2) {
      const o = Math.max(-1, Math.min(1, r[s]));
      e.setInt16(n, o < 0 ? o * 32768 : o * 32767, !0);
    }
  }
  downSampleAudioFrame(e, n, r) {
    if (!e)
      return null;
    if (r === n || r > n)
      return e;
    const s = n / r, o = Math.round(e.length / s), a = new Float32Array(o);
    let i = 0, c = 0;
    for (; c < o; ) {
      const u = Math.round((c + 1) * s);
      let p = 0, d = 0;
      for (; i < u && i < e.length; )
        p += e[i++], d++;
      a[c++] = p / d;
    }
    return a;
  }
}
Vo.RiffPcmEncoder = v_;
var Ko = {};
Object.defineProperty(Ko, "__esModule", { value: !0 });
Ko.Stream = void 0;
const Bp = Ee, f_ = Ye, qp = ms;
class g_ {
  constructor(e) {
    this.privIsWriteEnded = !1, this.privIsReadEnded = !1, this.privId = e || f_.createNoDashGuid(), this.privReaderQueue = new qp.Queue();
  }
  get isClosed() {
    return this.privIsWriteEnded;
  }
  get isReadEnded() {
    return this.privIsReadEnded;
  }
  get id() {
    return this.privId;
  }
  close() {
    this.privIsWriteEnded || (this.writeStreamChunk({
      buffer: null,
      isEnd: !0,
      timeReceived: Date.now()
    }), this.privIsWriteEnded = !0);
  }
  writeStreamChunk(e) {
    if (this.throwIfClosed(), !this.privReaderQueue.isDisposed())
      try {
        this.privReaderQueue.enqueue(e);
      } catch {
      }
  }
  read() {
    if (this.privIsReadEnded)
      throw new Bp.InvalidOperationError("Stream read has already finished");
    return this.privReaderQueue.dequeue().then(async (e) => ((e === void 0 || e.isEnd) && await this.privReaderQueue.dispose("End of stream reached"), e));
  }
  readEnded() {
    this.privIsReadEnded || (this.privIsReadEnded = !0, this.privReaderQueue = new qp.Queue());
  }
  throwIfClosed() {
    if (this.privIsWriteEnded)
      throw new Bp.InvalidOperationError("Stream closed");
  }
}
Ko.Stream = g_;
var Jo = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.TranslationStatus = void 0, function(e) {
    e[e.Success = 0] = "Success", e[e.Error = 1] = "Error";
  }(t.TranslationStatus || (t.TranslationStatus = {}));
})(Jo);
var vr = {}, Fp;
function m_() {
  if (Fp)
    return vr;
  Fp = 1, Object.defineProperty(vr, "__esModule", { value: !0 }), vr.ChunkedArrayBufferStream = void 0;
  const t = k();
  let e = class extends t.Stream {
    constructor(r, s) {
      super(s), this.privTargetChunkSize = Math.round(r), this.privNextBufferReadyBytes = 0;
    }
    writeStreamChunk(r) {
      if (r.isEnd || this.privNextBufferReadyBytes === 0 && r.buffer.byteLength === this.privTargetChunkSize) {
        super.writeStreamChunk(r);
        return;
      }
      let s = 0;
      for (; s < r.buffer.byteLength; ) {
        this.privNextBufferToWrite === void 0 && (this.privNextBufferToWrite = new ArrayBuffer(this.privTargetChunkSize), this.privNextBufferStartTime = r.timeReceived);
        const o = Math.min(r.buffer.byteLength - s, this.privTargetChunkSize - this.privNextBufferReadyBytes), a = new Uint8Array(this.privNextBufferToWrite), i = new Uint8Array(r.buffer.slice(s, o + s));
        a.set(i, this.privNextBufferReadyBytes), this.privNextBufferReadyBytes += o, s += o, this.privNextBufferReadyBytes === this.privTargetChunkSize && (super.writeStreamChunk({
          buffer: this.privNextBufferToWrite,
          isEnd: !1,
          timeReceived: this.privNextBufferStartTime
        }), this.privNextBufferReadyBytes = 0, this.privNextBufferToWrite = void 0);
      }
    }
    close() {
      this.privNextBufferReadyBytes !== 0 && !this.isClosed && super.writeStreamChunk({
        buffer: this.privNextBufferToWrite.slice(0, this.privNextBufferReadyBytes),
        isEnd: !1,
        timeReceived: this.privNextBufferStartTime
      }), super.close();
    }
  };
  return vr.ChunkedArrayBufferStream = e, vr;
}
var hf = {};
Object.defineProperty(hf, "__esModule", { value: !0 });
var Go = {};
Object.defineProperty(Go, "__esModule", { value: !0 });
Go.Timeout = void 0;
class ke {
  static load() {
    const e = /* @__PURE__ */ new Map([[0, () => {
    }]]), n = /* @__PURE__ */ new Map(), s = "data:text/javascript;base64," + btoa(`!function(e){var t={};function n(r){if(t[r])return t[r].exports;var o=t[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,n),o.l=!0,o.exports}n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)n.d(r,o,function(t){return e[t]}.bind(null,o));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=14)}([function(e,t,n){"use strict";n.d(t,"a",(function(){return i})),n.d(t,"b",(function(){return u})),n.d(t,"c",(function(){return a})),n.d(t,"d",(function(){return d}));const r=new Map,o=new Map,i=e=>{const t=r.get(e);if(void 0===t)throw new Error('There is no interval scheduled with the given id "'.concat(e,'".'));clearTimeout(t),r.delete(e)},u=e=>{const t=o.get(e);if(void 0===t)throw new Error('There is no timeout scheduled with the given id "'.concat(e,'".'));clearTimeout(t),o.delete(e)},f=(e,t)=>{let n,r;if("performance"in self){const o=performance.now();n=o,r=e-Math.max(0,o-t)}else n=Date.now(),r=e;return{expected:n+r,remainingDelay:r}},c=(e,t,n,r)=>{const o="performance"in self?performance.now():Date.now();o>n?postMessage({id:null,method:"call",params:{timerId:t}}):e.set(t,setTimeout(c,n-o,e,t,n))},a=(e,t,n)=>{const{expected:o,remainingDelay:i}=f(e,n);r.set(t,setTimeout(c,i,r,t,o))},d=(e,t,n)=>{const{expected:r,remainingDelay:i}=f(e,n);o.set(t,setTimeout(c,i,o,t,r))}},function(e,t,n){"use strict";n.r(t);var r=n(2);for(var o in r)"default"!==o&&function(e){n.d(t,e,(function(){return r[e]}))}(o);var i=n(3);for(var o in i)"default"!==o&&function(e){n.d(t,e,(function(){return i[e]}))}(o);var u=n(4);for(var o in u)"default"!==o&&function(e){n.d(t,e,(function(){return u[e]}))}(o);var f=n(5);for(var o in f)"default"!==o&&function(e){n.d(t,e,(function(){return f[e]}))}(o);var c=n(6);for(var o in c)"default"!==o&&function(e){n.d(t,e,(function(){return c[e]}))}(o);var a=n(7);for(var o in a)"default"!==o&&function(e){n.d(t,e,(function(){return a[e]}))}(o);var d=n(8);for(var o in d)"default"!==o&&function(e){n.d(t,e,(function(){return d[e]}))}(o);var s=n(9);for(var o in s)"default"!==o&&function(e){n.d(t,e,(function(){return s[e]}))}(o)},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t,n){"use strict";n.r(t);var r=n(11);for(var o in r)"default"!==o&&function(e){n.d(t,e,(function(){return r[e]}))}(o);var i=n(12);for(var o in i)"default"!==o&&function(e){n.d(t,e,(function(){return i[e]}))}(o);var u=n(13);for(var o in u)"default"!==o&&function(e){n.d(t,e,(function(){return u[e]}))}(o)},function(e,t){},function(e,t){},function(e,t){},function(e,t,n){"use strict";n.r(t);var r=n(0),o=n(1);for(var i in o)"default"!==i&&function(e){n.d(t,e,(function(){return o[e]}))}(i);var u=n(10);for(var i in u)"default"!==i&&function(e){n.d(t,e,(function(){return u[e]}))}(i);addEventListener("message",({data:e})=>{try{if("clear"===e.method){const{id:t,params:{timerId:n}}=e;Object(r.b)(n),postMessage({error:null,id:t})}else{if("set"!==e.method)throw new Error('The given method "'.concat(e.method,'" is not supported'));{const{params:{delay:t,now:n,timerId:o}}=e;Object(r.d)(t,o,n)}}}catch(t){postMessage({error:{message:t.message},id:e.id,result:null})}})}]);`), o = new Worker(s);
    return o.addEventListener("message", ({ data: c }) => {
      if (ke.isCallNotification(c)) {
        const { params: { timerId: u } } = c, p = e.get(u);
        if (typeof p == "number") {
          const d = n.get(p);
          if (d === void 0 || d !== u)
            throw new Error("The timer is in an undefined state.");
        } else if (typeof p < "u")
          p(), e.delete(u);
        else
          throw new Error("The timer is in an undefined state.");
      } else if (ke.isClearResponse(c)) {
        const { id: u } = c, p = n.get(u);
        if (p === void 0)
          throw new Error("The timer is in an undefined state.");
        n.delete(u), e.delete(p);
      } else {
        const { error: { message: u } } = c;
        throw new Error(u);
      }
    }), {
      clearTimeout: (c) => {
        const u = Math.random();
        n.set(u, c), e.set(c, u), o.postMessage({
          id: u,
          method: "clear",
          params: { timerId: c }
        });
      },
      setTimeout: (c, u) => {
        const p = Math.random();
        return e.set(p, c), o.postMessage({
          id: null,
          method: "set",
          params: {
            delay: u,
            now: performance.now(),
            timerId: p
          }
        }), p;
      }
    };
  }
  static loadWorkerTimers() {
    return () => (ke.workerTimers !== null || (ke.workerTimers = ke.load()), ke.workerTimers);
  }
  static isCallNotification(e) {
    return e.method !== void 0 && e.method === "call";
  }
  static isClearResponse(e) {
    return e.error === null && typeof e.id == "number";
  }
}
Go.Timeout = ke;
ke.workerTimers = null;
ke.clearTimeout = (t) => ke.timers().clearTimeout(t);
ke.setTimeout = (t, e) => ke.timers().setTimeout(t, e);
ke.timers = ke.loadWorkerTimers();
var V = {};
Object.defineProperty(V, "__esModule", { value: !0 });
V.OCSPCacheUpdateErrorEvent = V.OCSPResponseRetrievedEvent = V.OCSPCacheFetchErrorEvent = V.OCSPVerificationFailedEvent = V.OCSPCacheHitEvent = V.OCSPCacheEntryNeedsRefreshEvent = V.OCSPCacheEntryExpiredEvent = V.OCSPWSUpgradeStartedEvent = V.OCSPStapleReceivedEvent = V.OCSPCacheUpdateCompleteEvent = V.OCSPDiskCacheStoreEvent = V.OCSPMemoryCacheStoreEvent = V.OCSPCacheUpdateNeededEvent = V.OCSPDiskCacheHitEvent = V.OCSPCacheMissEvent = V.OCSPMemoryCacheHitEvent = V.OCSPEvent = void 0;
const Te = er;
class Ie extends Te.PlatformEvent {
  constructor(e, n, r) {
    super(e, n), this.privSignature = r;
  }
}
V.OCSPEvent = Ie;
class S_ extends Ie {
  constructor(e) {
    super("OCSPMemoryCacheHitEvent", Te.EventType.Debug, e);
  }
}
V.OCSPMemoryCacheHitEvent = S_;
class y_ extends Ie {
  constructor(e) {
    super("OCSPCacheMissEvent", Te.EventType.Debug, e);
  }
}
V.OCSPCacheMissEvent = y_;
class C_ extends Ie {
  constructor(e) {
    super("OCSPDiskCacheHitEvent", Te.EventType.Debug, e);
  }
}
V.OCSPDiskCacheHitEvent = C_;
class __ extends Ie {
  constructor(e) {
    super("OCSPCacheUpdateNeededEvent", Te.EventType.Debug, e);
  }
}
V.OCSPCacheUpdateNeededEvent = __;
class R_ extends Ie {
  constructor(e) {
    super("OCSPMemoryCacheStoreEvent", Te.EventType.Debug, e);
  }
}
V.OCSPMemoryCacheStoreEvent = R_;
class P_ extends Ie {
  constructor(e) {
    super("OCSPDiskCacheStoreEvent", Te.EventType.Debug, e);
  }
}
V.OCSPDiskCacheStoreEvent = P_;
class E_ extends Ie {
  constructor(e) {
    super("OCSPCacheUpdateCompleteEvent", Te.EventType.Debug, e);
  }
}
V.OCSPCacheUpdateCompleteEvent = E_;
class T_ extends Ie {
  constructor() {
    super("OCSPStapleReceivedEvent", Te.EventType.Debug, "");
  }
}
V.OCSPStapleReceivedEvent = T_;
class I_ extends Ie {
  constructor(e) {
    super("OCSPWSUpgradeStartedEvent", Te.EventType.Debug, e);
  }
}
V.OCSPWSUpgradeStartedEvent = I_;
class w_ extends Ie {
  constructor(e, n) {
    super("OCSPCacheEntryExpiredEvent", Te.EventType.Debug, e), this.privExpireTime = n;
  }
}
V.OCSPCacheEntryExpiredEvent = w_;
class b_ extends Ie {
  constructor(e, n, r) {
    super("OCSPCacheEntryNeedsRefreshEvent", Te.EventType.Debug, e), this.privExpireTime = r, this.privStartTime = n;
  }
}
V.OCSPCacheEntryNeedsRefreshEvent = b_;
class A_ extends Ie {
  constructor(e, n, r) {
    super("OCSPCacheHitEvent", Te.EventType.Debug, e), this.privExpireTime = r, this.privExpireTimeString = new Date(r).toLocaleDateString(), this.privStartTime = n, this.privStartTimeString = new Date(n).toLocaleTimeString();
  }
}
V.OCSPCacheHitEvent = A_;
class M_ extends Ie {
  constructor(e, n) {
    super("OCSPVerificationFailedEvent", Te.EventType.Debug, e), this.privError = n;
  }
}
V.OCSPVerificationFailedEvent = M_;
class k_ extends Ie {
  constructor(e, n) {
    super("OCSPCacheFetchErrorEvent", Te.EventType.Debug, e), this.privError = n;
  }
}
V.OCSPCacheFetchErrorEvent = k_;
class O_ extends Ie {
  constructor(e) {
    super("OCSPResponseRetrievedEvent", Te.EventType.Debug, e);
  }
}
V.OCSPResponseRetrievedEvent = O_;
class D_ extends Ie {
  constructor(e, n) {
    super("OCSPCacheUpdateErrorEvent", Te.EventType.Debug, e), this.privError = n;
  }
}
V.OCSPCacheUpdateErrorEvent = D_;
var fr = {}, $p;
function N_() {
  if ($p)
    return fr;
  $p = 1, Object.defineProperty(fr, "__esModule", { value: !0 }), fr.BackgroundEvent = void 0;
  const t = k();
  class e extends t.PlatformEvent {
    constructor(r) {
      super("BackgroundEvent", t.EventType.Error), this.privError = r;
    }
    get error() {
      return this.privError;
    }
  }
  return fr.BackgroundEvent = e, fr;
}
var Up;
function k() {
  return Up || (Up = 1, function(t) {
    var e = W && W.__createBinding || (Object.create ? function(s, o, a, i) {
      i === void 0 && (i = a), Object.defineProperty(s, i, { enumerable: !0, get: function() {
        return o[a];
      } });
    } : function(s, o, a, i) {
      i === void 0 && (i = a), s[i] = o[a];
    }), n = W && W.__exportStar || function(s, o) {
      for (var a in s)
        a !== "default" && !o.hasOwnProperty(a) && e(o, s, a);
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), n(le, t), n(fe, t), n(wu, t), n($o, t), n(Uo, t), n(yn, t), n(Ee, t), n(Ho, t), n(fs, t), n(Ye, t), n(nf, t), n(rf, t), n(sf, t), n(of, t), n(af, t), n(cf, t), n(uf, t), n(pf, t), n(df, t), n(lf, t), n(gs, t), n(er, t), n(bu, t), n(ms, t), n(Wo, t), n(Vo, t), n(Ko, t);
    var r = Jo;
    Object.defineProperty(t, "TranslationStatus", { enumerable: !0, get: function() {
      return r.TranslationStatus;
    } }), n(m_(), t), n(hf, t), n(Go, t), n(V, t), n(N_(), t);
  }(ac)), ac;
}
var Se = {};
Object.defineProperty(Se, "__esModule", { value: !0 });
Se.HeaderNames = void 0;
class it {
}
Se.HeaderNames = it;
it.AuthKey = "Ocp-Apim-Subscription-Key";
it.Authorization = "Authorization";
it.SpIDAuthKey = "Apim-Subscription-Id";
it.ConnectionId = "X-ConnectionId";
it.ContentType = "Content-Type";
it.CustomCommandsAppId = "X-CommandsAppId";
it.Path = "Path";
it.RequestId = "X-RequestId";
it.RequestStreamId = "X-StreamId";
it.RequestTimestamp = "X-Timestamp";
var nr = {};
Object.defineProperty(nr, "__esModule", { value: !0 });
nr.AuthInfo = void 0;
class L_ {
  constructor(e, n) {
    this.privHeaderName = e, this.privToken = n;
  }
  get headerName() {
    return this.privHeaderName;
  }
  get token() {
    return this.privToken;
  }
}
nr.AuthInfo = L_;
Object.defineProperty(Ao, "__esModule", { value: !0 });
Ao.CognitiveSubscriptionKeyAuthentication = void 0;
const z_ = k(), j_ = Se, x_ = nr;
class B_ {
  /**
   * Creates and initializes an instance of the CognitiveSubscriptionKeyAuthentication class.
   * @constructor
   * @param {string} subscriptionKey - The subscription key
   */
  constructor(e) {
    if (!e)
      throw new z_.ArgumentNullError("subscriptionKey");
    this.privAuthInfo = new x_.AuthInfo(j_.HeaderNames.AuthKey, e);
  }
  /**
   * Fetches the subscription key.
   * @member
   * @function
   * @public
   * @param {string} authFetchEventId - The id to fetch.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  fetch(e) {
    return Promise.resolve(this.privAuthInfo);
  }
  /**
   * Fetches the subscription key.
   * @member
   * @function
   * @public
   * @param {string} authFetchEventId - The id to fetch.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  fetchOnExpiry(e) {
    return Promise.resolve(this.privAuthInfo);
  }
}
Ao.CognitiveSubscriptionKeyAuthentication = B_;
var Qo = {};
Object.defineProperty(Qo, "__esModule", { value: !0 });
Qo.CognitiveTokenAuthentication = void 0;
const Hp = k(), Wp = nr, Vp = Se;
class os {
  constructor(e, n) {
    if (!e)
      throw new Hp.ArgumentNullError("fetchCallback");
    if (!n)
      throw new Hp.ArgumentNullError("fetchOnExpiryCallback");
    this.privFetchCallback = e, this.privFetchOnExpiryCallback = n;
  }
  fetch(e) {
    return this.privFetchCallback(e).then((n) => new Wp.AuthInfo(Vp.HeaderNames.Authorization, n === void 0 ? void 0 : os.privTokenPrefix + n));
  }
  fetchOnExpiry(e) {
    return this.privFetchOnExpiryCallback(e).then((n) => new Wp.AuthInfo(Vp.HeaderNames.Authorization, n === void 0 ? void 0 : os.privTokenPrefix + n));
  }
}
Qo.CognitiveTokenAuthentication = os;
os.privTokenPrefix = "Bearer ";
var vf = {};
Object.defineProperty(vf, "__esModule", { value: !0 });
var ff = {};
Object.defineProperty(ff, "__esModule", { value: !0 });
var gr = {}, vc = {}, Yo = {};
const q_ = {}, F_ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: q_
}, Symbol.toStringTag, { value: "Module" })), Tn = /* @__PURE__ */ Ly(F_);
var Au = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.LogLevel = void 0;
  const e = k();
  Object.defineProperty(t, "LogLevel", { enumerable: !0, get: function() {
    return e.EventType;
  } });
})(Au);
var N = {};
Object.defineProperty(N, "__esModule", { value: !0 });
N.Contracts = void 0;
class kt {
  static throwIfNullOrUndefined(e, n) {
    if (e == null)
      throw new Error("throwIfNullOrUndefined:" + n);
  }
  static throwIfNull(e, n) {
    if (e === null)
      throw new Error("throwIfNull:" + n);
  }
  static throwIfNullOrWhitespace(e, n) {
    if (kt.throwIfNullOrUndefined(e, n), ("" + e).trim().length < 1)
      throw new Error("throwIfNullOrWhitespace:" + n);
  }
  static throwIfNullOrTooLong(e, n, r) {
    if (kt.throwIfNullOrUndefined(e, n), ("" + e).length > r)
      throw new Error("throwIfNullOrTooLong:" + n + " (more than " + r.toString() + " characters)");
  }
  static throwIfNullOrTooShort(e, n, r) {
    if (kt.throwIfNullOrUndefined(e, n), ("" + e).length < r)
      throw new Error("throwIfNullOrTooShort:" + n + " (less than " + r.toString() + " characters)");
  }
  static throwIfDisposed(e) {
    if (e)
      throw new Error("the object is already disposed");
  }
  static throwIfArrayEmptyOrWhitespace(e, n) {
    if (kt.throwIfNullOrUndefined(e, n), e.length === 0)
      throw new Error("throwIfArrayEmptyOrWhitespace:" + n);
    for (const r of e)
      kt.throwIfNullOrWhitespace(r, n);
  }
  static throwIfFileDoesNotExist(e, n) {
    kt.throwIfNullOrWhitespace(e, n);
  }
  static throwIfNotUndefined(e, n) {
    if (e !== void 0)
      throw new Error("throwIfNotUndefined:" + n);
  }
}
N.Contracts = kt;
var $_ = W && W.__createBinding || (Object.create ? function(t, e, n, r) {
  r === void 0 && (r = n), Object.defineProperty(t, r, { enumerable: !0, get: function() {
    return e[n];
  } });
} : function(t, e, n, r) {
  r === void 0 && (r = n), t[r] = e[n];
}), U_ = W && W.__setModuleDefault || (Object.create ? function(t, e) {
  Object.defineProperty(t, "default", { enumerable: !0, value: e });
} : function(t, e) {
  t.default = e;
}), H_ = W && W.__importStar || function(t) {
  if (t && t.__esModule)
    return t;
  var e = {};
  if (t != null)
    for (var n in t)
      n !== "default" && Object.hasOwnProperty.call(t, n) && $_(e, t, n);
  return U_(e, t), e;
};
Object.defineProperty(Yo, "__esModule", { value: !0 });
Yo.ConsoleLoggingListener = void 0;
const Kp = H_(Tn), mr = Au, W_ = N;
class V_ {
  constructor(e = mr.LogLevel.None) {
    this.privLogPath = void 0, this.privEnableConsoleOutput = !0, this.privLogLevelFilter = e;
  }
  set logPath(e) {
    W_.Contracts.throwIfNullOrUndefined(Kp.openSync, `
File System access not available`), this.privLogPath = e;
  }
  set enableConsoleOutput(e) {
    this.privEnableConsoleOutput = e;
  }
  onEvent(e) {
    if (e.eventType >= this.privLogLevelFilter) {
      const n = this.toString(e);
      if (this.logCallback && this.logCallback(n), this.privLogPath && Kp.writeFileSync(this.privLogPath, n + `
`, { flag: "a+" }), this.privEnableConsoleOutput)
        switch (e.eventType) {
          case mr.LogLevel.Debug:
            console.debug(n);
            break;
          case mr.LogLevel.Info:
            console.info(n);
            break;
          case mr.LogLevel.Warning:
            console.warn(n);
            break;
          case mr.LogLevel.Error:
            console.error(n);
            break;
          default:
            console.log(n);
            break;
        }
    }
  }
  toString(e) {
    const n = [
      `${e.eventTime}`,
      `${e.name}`
    ], r = e;
    for (const s in r)
      if (s && e.hasOwnProperty(s) && s !== "eventTime" && s !== "eventType" && s !== "eventId" && s !== "name" && s !== "constructor") {
        const o = r[s];
        let a = "<NULL>";
        o != null && (typeof o == "number" || typeof o == "string" ? a = o.toString() : a = JSON.stringify(o)), n.push(`${s}: ${a}`);
      }
    return n.join(" | ");
  }
}
Yo.ConsoleLoggingListener = V_;
var gf = {};
Object.defineProperty(gf, "__esModule", { value: !0 });
var fc = {}, Wt = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.AudioStreamFormatImpl = t.AudioStreamFormat = t.AudioFormatTag = void 0;
  var e;
  (function(s) {
    s[s.PCM = 1] = "PCM", s[s.MuLaw = 2] = "MuLaw", s[s.Siren = 3] = "Siren", s[s.MP3 = 4] = "MP3", s[s.SILKSkype = 5] = "SILKSkype", s[s.OGG_OPUS = 6] = "OGG_OPUS", s[s.WEBM_OPUS = 7] = "WEBM_OPUS", s[s.ALaw = 8] = "ALaw", s[s.FLAC = 9] = "FLAC", s[s.OPUS = 10] = "OPUS", s[s.AMR_WB = 11] = "AMR_WB", s[s.G722 = 12] = "G722";
  })(e = t.AudioFormatTag || (t.AudioFormatTag = {}));
  class n {
    /**
     * Creates an audio stream format object representing the default audio stream
     * format (16KHz 16bit mono PCM).
     * @member AudioStreamFormat.getDefaultInputFormat
     * @function
     * @public
     * @returns {AudioStreamFormat} The audio stream format being created.
     */
    static getDefaultInputFormat() {
      return r.getDefaultInputFormat();
    }
    /**
     * Creates an audio stream format object with the specified format characteristics.
     * @member AudioStreamFormat.getWaveFormat
     * @function
     * @public
     * @param {number} samplesPerSecond - Sample rate, in samples per second (Hertz).
     * @param {number} bitsPerSample - Bits per sample, typically 16.
     * @param {number} channels - Number of channels in the waveform-audio data. Monaural data
     * uses one channel and stereo data uses two channels.
     * @param {AudioFormatTag} format - Audio format (PCM, alaw or mulaw).
     * @returns {AudioStreamFormat} The audio stream format being created.
     */
    static getWaveFormat(o, a, i, c) {
      return new r(o, a, i, c);
    }
    /**
     * Creates an audio stream format object with the specified pcm waveformat characteristics.
     * @member AudioStreamFormat.getWaveFormatPCM
     * @function
     * @public
     * @param {number} samplesPerSecond - Sample rate, in samples per second (Hertz).
     * @param {number} bitsPerSample - Bits per sample, typically 16.
     * @param {number} channels - Number of channels in the waveform-audio data. Monaural data
     * uses one channel and stereo data uses two channels.
     * @returns {AudioStreamFormat} The audio stream format being created.
     */
    static getWaveFormatPCM(o, a, i) {
      return new r(o, a, i);
    }
  }
  t.AudioStreamFormat = n;
  class r extends n {
    /**
     * Creates an instance with the given values.
     * @constructor
     * @param {number} samplesPerSec - Samples per second.
     * @param {number} bitsPerSample - Bits per sample.
     * @param {number} channels - Number of channels.
     * @param {AudioFormatTag} format - Audio format (PCM, alaw or mulaw).
     */
    constructor(o = 16e3, a = 16, i = 1, c = e.PCM) {
      super();
      let u = !0;
      switch (c) {
        case e.PCM:
          this.formatTag = 1;
          break;
        case e.ALaw:
          this.formatTag = 6;
          break;
        case e.MuLaw:
          this.formatTag = 7;
          break;
        default:
          u = !1;
      }
      if (this.bitsPerSample = a, this.samplesPerSec = o, this.channels = i, this.avgBytesPerSec = this.samplesPerSec * this.channels * (this.bitsPerSample / 8), this.blockAlign = this.channels * Math.max(this.bitsPerSample, 8), u) {
        this.privHeader = new ArrayBuffer(44);
        const p = new DataView(this.privHeader);
        this.setString(p, 0, "RIFF"), p.setUint32(4, 0, !0), this.setString(p, 8, "WAVEfmt "), p.setUint32(16, 16, !0), p.setUint16(20, this.formatTag, !0), p.setUint16(22, this.channels, !0), p.setUint32(24, this.samplesPerSec, !0), p.setUint32(28, this.avgBytesPerSec, !0), p.setUint16(32, this.channels * (this.bitsPerSample / 8), !0), p.setUint16(34, this.bitsPerSample, !0), this.setString(p, 36, "data"), p.setUint32(40, 0, !0);
      }
    }
    /**
     * Retrieves the default input format.
     * @member AudioStreamFormatImpl.getDefaultInputFormat
     * @function
     * @public
     * @returns {AudioStreamFormatImpl} The default input format.
     */
    static getDefaultInputFormat() {
      return new r();
    }
    /**
     * Creates an audio context appropriate to current browser
     * @member AudioStreamFormatImpl.getAudioContext
     * @function
     * @public
     * @returns {AudioContext} An audio context instance
     */
    /* eslint-disable */
    static getAudioContext(o) {
      const a = window.AudioContext || window.webkitAudioContext || !1;
      if (a)
        return o !== void 0 && navigator.mediaDevices.getSupportedConstraints().sampleRate ? new a({ sampleRate: o }) : new a();
      throw new Error("Browser does not support Web Audio API (AudioContext is not available).");
    }
    /* eslint-enable */
    /**
     * Closes the configuration object.
     * @member AudioStreamFormatImpl.prototype.close
     * @function
     * @public
     */
    close() {
    }
    get header() {
      return this.privHeader;
    }
    setString(o, a, i) {
      for (let c = 0; c < i.length; c++)
        o.setUint8(a + c, i.charCodeAt(c));
    }
  }
  t.AudioStreamFormatImpl = r;
})(Wt);
var Jp;
function K_() {
  return Jp || (Jp = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.MicAudioSource = t.AudioWorkletSourceURLPropertyName = void 0;
    const e = A(), n = k(), r = Wt;
    t.AudioWorkletSourceURLPropertyName = "MICROPHONE-WorkletSourceUrl";
    class s {
      constructor(a, i, c, u) {
        this.privRecorder = a, this.deviceId = i, this.privStreams = {}, this.privOutputChunkSize = s.AUDIOFORMAT.avgBytesPerSec / 10, this.privId = c || n.createNoDashGuid(), this.privEvents = new n.EventSource(), this.privMediaStream = u || null, this.privIsClosing = !1;
      }
      get format() {
        return Promise.resolve(s.AUDIOFORMAT);
      }
      turnOn() {
        if (this.privInitializeDeferral)
          return this.privInitializeDeferral.promise;
        this.privInitializeDeferral = new n.Deferred();
        try {
          this.createAudioContext();
        } catch (c) {
          if (c instanceof Error) {
            const u = c;
            this.privInitializeDeferral.reject(u.name + ": " + u.message);
          } else
            this.privInitializeDeferral.reject(c);
          return this.privInitializeDeferral.promise;
        }
        const a = window.navigator;
        let i = (
          // eslint-disable-next-line
          a.getUserMedia || a.webkitGetUserMedia || a.mozGetUserMedia || a.msGetUserMedia
        );
        if (a.mediaDevices && (i = (c, u, p) => {
          a.mediaDevices.getUserMedia(c).then(u).catch(p);
        }), i) {
          const c = () => {
            this.onEvent(new n.AudioSourceInitializingEvent(this.privId)), this.privMediaStream && this.privMediaStream.active ? (this.onEvent(new n.AudioSourceReadyEvent(this.privId)), this.privInitializeDeferral.resolve()) : i({ audio: this.deviceId ? { deviceId: this.deviceId } : !0, video: !1 }, (u) => {
              this.privMediaStream = u, this.onEvent(new n.AudioSourceReadyEvent(this.privId)), this.privInitializeDeferral.resolve();
            }, (u) => {
              const p = `Error occurred during microphone initialization: ${u}`;
              this.privInitializeDeferral.reject(p), this.onEvent(new n.AudioSourceErrorEvent(this.privId, p));
            });
          };
          this.privContext.state === "suspended" ? this.privContext.resume().then(c).catch((u) => {
            this.privInitializeDeferral.reject(`Failed to initialize audio context: ${u}`);
          }) : c();
        } else {
          const c = "Browser does not support getUserMedia.";
          this.privInitializeDeferral.reject(c), this.onEvent(new n.AudioSourceErrorEvent(c, ""));
        }
        return this.privInitializeDeferral.promise;
      }
      id() {
        return this.privId;
      }
      attach(a) {
        return this.onEvent(new n.AudioStreamNodeAttachingEvent(this.privId, a)), this.listen(a).then((i) => (this.onEvent(new n.AudioStreamNodeAttachedEvent(this.privId, a)), {
          detach: async () => (i.readEnded(), delete this.privStreams[a], this.onEvent(new n.AudioStreamNodeDetachedEvent(this.privId, a)), this.turnOff()),
          id: () => a,
          read: () => i.read()
        }));
      }
      detach(a) {
        a && this.privStreams[a] && (this.privStreams[a].close(), delete this.privStreams[a], this.onEvent(new n.AudioStreamNodeDetachedEvent(this.privId, a)));
      }
      async turnOff() {
        for (const a in this.privStreams)
          if (a) {
            const i = this.privStreams[a];
            i && i.close();
          }
        this.onEvent(new n.AudioSourceOffEvent(this.privId)), this.privInitializeDeferral && (await this.privInitializeDeferral, this.privInitializeDeferral = null), await this.destroyAudioContext();
      }
      get events() {
        return this.privEvents;
      }
      get deviceInfo() {
        return this.getMicrophoneLabel().then((a) => ({
          bitspersample: s.AUDIOFORMAT.bitsPerSample,
          channelcount: s.AUDIOFORMAT.channels,
          connectivity: e.connectivity.Unknown,
          manufacturer: "Speech SDK",
          model: a,
          samplerate: s.AUDIOFORMAT.samplesPerSec,
          type: e.type.Microphones
        }));
      }
      setProperty(a, i) {
        if (a === t.AudioWorkletSourceURLPropertyName)
          this.privRecorder.setWorkletUrl(i);
        else
          throw new Error("Property '" + a + "' is not supported on Microphone.");
      }
      getMicrophoneLabel() {
        const a = "microphone";
        if (this.privMicrophoneLabel !== void 0)
          return Promise.resolve(this.privMicrophoneLabel);
        if (this.privMediaStream === void 0 || !this.privMediaStream.active)
          return Promise.resolve(a);
        this.privMicrophoneLabel = a;
        const i = this.privMediaStream.getTracks()[0].getSettings().deviceId;
        if (i === void 0)
          return Promise.resolve(this.privMicrophoneLabel);
        const c = new n.Deferred();
        return navigator.mediaDevices.enumerateDevices().then((u) => {
          for (const p of u)
            if (p.deviceId === i) {
              this.privMicrophoneLabel = p.label;
              break;
            }
          c.resolve(this.privMicrophoneLabel);
        }, () => c.resolve(this.privMicrophoneLabel)), c.promise;
      }
      async listen(a) {
        await this.turnOn();
        const i = new n.ChunkedArrayBufferStream(this.privOutputChunkSize, a);
        this.privStreams[a] = i;
        try {
          this.privRecorder.record(this.privContext, this.privMediaStream, i);
        } catch (u) {
          throw this.onEvent(new n.AudioStreamNodeErrorEvent(this.privId, a, u)), u;
        }
        return i;
      }
      onEvent(a) {
        this.privEvents.onEvent(a), n.Events.instance.onEvent(a);
      }
      createAudioContext() {
        this.privContext || (this.privContext = r.AudioStreamFormatImpl.getAudioContext(s.AUDIOFORMAT.samplesPerSec));
      }
      async destroyAudioContext() {
        if (!this.privContext)
          return;
        this.privRecorder.releaseMediaResources(this.privContext);
        let a = !1;
        "close" in this.privContext && (a = !0), a ? this.privIsClosing || (this.privIsClosing = !0, await this.privContext.close(), this.privContext = null, this.privIsClosing = !1) : this.privContext !== null && this.privContext.state === "running" && await this.privContext.suspend();
      }
    }
    t.MicAudioSource = s, s.AUDIOFORMAT = r.AudioStreamFormat.getDefaultInputFormat();
  }(fc)), fc;
}
var Sr = {}, Gp;
function J_() {
  if (Gp)
    return Sr;
  Gp = 1, Object.defineProperty(Sr, "__esModule", { value: !0 }), Sr.FileAudioSource = void 0;
  const t = A(), e = k(), n = Wt;
  let r = class {
    constructor(o, a, i) {
      this.privStreams = {}, this.privHeaderEnd = 44, this.privId = i || e.createNoDashGuid(), this.privEvents = new e.EventSource(), this.privSource = o, typeof window < "u" && typeof Blob < "u" && this.privSource instanceof Blob ? this.privFilename = o.name : this.privFilename = a || "unknown.wav", this.privAudioFormatPromise = this.readHeader();
    }
    get format() {
      return this.privAudioFormatPromise;
    }
    turnOn() {
      if (this.privFilename.lastIndexOf(".wav") !== this.privFilename.length - 4) {
        const o = this.privFilename + " is not supported. Only WAVE files are allowed at the moment.";
        return this.onEvent(new e.AudioSourceErrorEvent(o, "")), Promise.reject(o);
      }
      this.onEvent(new e.AudioSourceInitializingEvent(this.privId)), this.onEvent(new e.AudioSourceReadyEvent(this.privId));
    }
    id() {
      return this.privId;
    }
    async attach(o) {
      this.onEvent(new e.AudioStreamNodeAttachingEvent(this.privId, o));
      const a = await this.upload(o);
      return this.onEvent(new e.AudioStreamNodeAttachedEvent(this.privId, o)), Promise.resolve({
        detach: async () => {
          a.readEnded(), delete this.privStreams[o], this.onEvent(new e.AudioStreamNodeDetachedEvent(this.privId, o)), await this.turnOff();
        },
        id: () => o,
        read: () => a.read()
      });
    }
    detach(o) {
      o && this.privStreams[o] && (this.privStreams[o].close(), delete this.privStreams[o], this.onEvent(new e.AudioStreamNodeDetachedEvent(this.privId, o)));
    }
    turnOff() {
      for (const o in this.privStreams)
        if (o) {
          const a = this.privStreams[o];
          a && !a.isClosed && a.close();
        }
      return this.onEvent(new e.AudioSourceOffEvent(this.privId)), Promise.resolve();
    }
    get events() {
      return this.privEvents;
    }
    get deviceInfo() {
      return this.privAudioFormatPromise.then((o) => Promise.resolve({
        bitspersample: o.bitsPerSample,
        channelcount: o.channels,
        connectivity: t.connectivity.Unknown,
        manufacturer: "Speech SDK",
        model: "File",
        samplerate: o.samplesPerSec,
        type: t.type.File
      }));
    }
    readHeader() {
      const a = this.privSource.slice(0, 4296), i = new e.Deferred(), c = (u) => {
        const p = new DataView(u), d = (m) => String.fromCharCode(p.getUint8(m), p.getUint8(m + 1), p.getUint8(m + 2), p.getUint8(m + 3));
        if (d(0) !== "RIFF") {
          i.reject("Invalid WAV header in file, RIFF was not found");
          return;
        }
        if (d(8) !== "WAVE" || d(12) !== "fmt ") {
          i.reject("Invalid WAV header in file, WAVEfmt was not found");
          return;
        }
        const l = p.getInt32(16, !0), h = p.getUint16(22, !0), v = p.getUint32(24, !0), g = p.getUint16(34, !0);
        let f = 36 + Math.max(l - 16, 0);
        for (; d(f) !== "data"; f += 2)
          if (f > 4288) {
            i.reject("Invalid WAV header in file, data block was not found");
            return;
          }
        this.privHeaderEnd = f + 8, i.resolve(n.AudioStreamFormat.getWaveFormatPCM(v, g, h));
      };
      if (typeof window < "u" && typeof Blob < "u" && a instanceof Blob) {
        const u = new FileReader();
        u.onload = (p) => {
          const d = p.target.result;
          c(d);
        }, u.readAsArrayBuffer(a);
      } else {
        const u = a;
        c(u.buffer.slice(u.byteOffset, u.byteOffset + u.byteLength));
      }
      return i.promise;
    }
    async upload(o) {
      const a = (i) => {
        const c = `Error occurred while processing '${this.privFilename}'. ${i}`;
        throw this.onEvent(new e.AudioStreamNodeErrorEvent(this.privId, o, c)), new Error(c);
      };
      try {
        await this.turnOn();
        const i = await this.privAudioFormatPromise, c = new e.ChunkedArrayBufferStream(i.avgBytesPerSec / 10, o);
        this.privStreams[o] = c;
        const u = this.privSource.slice(this.privHeaderEnd), p = (d) => {
          c.isClosed || (c.writeStreamChunk({
            buffer: d,
            isEnd: !1,
            timeReceived: Date.now()
          }), c.close());
        };
        if (typeof window < "u" && typeof Blob < "u" && u instanceof Blob) {
          const d = new FileReader();
          d.onerror = (l) => a(l.toString()), d.onload = (l) => {
            const h = l.target.result;
            p(h);
          }, d.readAsArrayBuffer(u);
        } else {
          const d = u;
          p(d.buffer.slice(d.byteOffset, d.byteOffset + d.byteLength));
        }
        return c;
      } catch (i) {
        a(i);
      }
    }
    onEvent(o) {
      this.privEvents.onEvent(o), e.Events.instance.onEvent(o);
    }
  };
  return Sr.FileAudioSource = r, Sr;
}
var Zo = {};
Object.defineProperty(Zo, "__esModule", { value: !0 });
Zo.PcmRecorder = void 0;
const G_ = k();
class Q_ {
  constructor(e) {
    this.privStopInputOnRelease = e;
  }
  record(e, n, r) {
    const o = new G_.RiffPcmEncoder(e.sampleRate, 16e3), a = e.createMediaStreamSource(n), i = () => {
      const u = (() => {
        let p = 0;
        try {
          return e.createScriptProcessor(p, 1, 1);
        } catch {
          p = 2048;
          let l = e.sampleRate;
          for (; p < 16384 && l >= 32e3; )
            p <<= 1, l >>= 1;
          return e.createScriptProcessor(p, 1, 1);
        }
      })();
      u.onaudioprocess = (p) => {
        const d = p.inputBuffer.getChannelData(0);
        if (r && !r.isClosed) {
          const l = o.encode(d);
          l && r.writeStreamChunk({
            buffer: l,
            isEnd: !1,
            timeReceived: Date.now()
          });
        }
      }, a.connect(u), u.connect(e.destination), this.privMediaResources = {
        scriptProcessorNode: u,
        source: a,
        stream: n
      };
    }, c = !!this.privSpeechProcessorScript && this.privSpeechProcessorScript.toLowerCase() === "ignore";
    if (e.audioWorklet && !c) {
      if (!this.privSpeechProcessorScript) {
        const u = `class SP extends AudioWorkletProcessor {
                    constructor(options) {
                      super(options);
                    }
                    process(inputs, outputs) {
                      const input = inputs[0];
                      const output = [];
                      for (let channel = 0; channel < input.length; channel += 1) {
                        output[channel] = input[channel];
                      }
                      this.port.postMessage(output[0]);
                      return true;
                    }
                  }
                  registerProcessor('speech-processor', SP);`, p = new Blob([u], { type: "application/javascript; charset=utf-8" });
        this.privSpeechProcessorScript = URL.createObjectURL(p);
      }
      e.audioWorklet.addModule(this.privSpeechProcessorScript).then(() => {
        const u = new AudioWorkletNode(e, "speech-processor");
        u.port.onmessage = (p) => {
          const d = p.data;
          if (r && !r.isClosed) {
            const l = o.encode(d);
            l && r.writeStreamChunk({
              buffer: l,
              isEnd: !1,
              timeReceived: Date.now()
            });
          }
        }, a.connect(u), u.connect(e.destination), this.privMediaResources = {
          scriptProcessorNode: u,
          source: a,
          stream: n
        };
      }).catch(() => {
        i();
      });
    } else
      try {
        i();
      } catch (u) {
        throw new Error(`Unable to start audio worklet node for PCMRecorder: ${u}`);
      }
  }
  releaseMediaResources(e) {
    this.privMediaResources && (this.privMediaResources.scriptProcessorNode && (this.privMediaResources.scriptProcessorNode.disconnect(e.destination), this.privMediaResources.scriptProcessorNode = null), this.privMediaResources.source && (this.privMediaResources.source.disconnect(), this.privStopInputOnRelease && this.privMediaResources.stream.getTracks().forEach((n) => n.stop()), this.privMediaResources.source = null));
  }
  setWorkletUrl(e) {
    this.privSpeechProcessorScript = e;
  }
}
Zo.PcmRecorder = Q_;
var Xo = {}, Ss = {}, Y_ = W && W.__createBinding || (Object.create ? function(t, e, n, r) {
  r === void 0 && (r = n), Object.defineProperty(t, r, { enumerable: !0, get: function() {
    return e[n];
  } });
} : function(t, e, n, r) {
  r === void 0 && (r = n), t[r] = e[n];
}), Z_ = W && W.__setModuleDefault || (Object.create ? function(t, e) {
  Object.defineProperty(t, "default", { enumerable: !0, value: e });
} : function(t, e) {
  t.default = e;
}), mf = W && W.__importStar || function(t) {
  if (t && t.__esModule)
    return t;
  var e = {};
  if (t != null)
    for (var n in t)
      n !== "default" && Object.hasOwnProperty.call(t, n) && Y_(e, t, n);
  return Z_(e, t), e;
}, Mu = W && W.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty(Ss, "__esModule", { value: !0 });
Ss.WebsocketMessageAdapter = void 0;
const X_ = mf(Tn), e0 = mf(Tn), t0 = Mu(Tn), n0 = Mu(Tn), r0 = Mu(Tn), i0 = Se, j = k();
class as {
  constructor(e, n, r, s, o, a) {
    if (!e)
      throw new j.ArgumentNullError("uri");
    if (!r)
      throw new j.ArgumentNullError("messageFormatter");
    this.proxyInfo = s, this.privConnectionEvents = new j.EventSource(), this.privConnectionId = n, this.privMessageFormatter = r, this.privConnectionState = j.ConnectionState.None, this.privUri = e, this.privHeaders = o, this.privEnableCompression = a, this.privHeaders[i0.HeaderNames.ConnectionId] = this.privConnectionId, this.privLastErrorReceived = "";
  }
  get state() {
    return this.privConnectionState;
  }
  open() {
    if (this.privConnectionState === j.ConnectionState.Disconnected)
      return Promise.reject(`Cannot open a connection that is in ${this.privConnectionState} state`);
    if (this.privConnectionEstablishDeferral)
      return this.privConnectionEstablishDeferral.promise;
    this.privConnectionEstablishDeferral = new j.Deferred(), this.privCertificateValidatedDeferral = new j.Deferred(), this.privConnectionState = j.ConnectionState.Connecting;
    try {
      if (typeof WebSocket < "u" && !as.forceNpmWebSocket)
        this.privCertificateValidatedDeferral.resolve(), this.privWebsocketClient = new WebSocket(this.privUri);
      else {
        const e = { headers: this.privHeaders, perMessageDeflate: this.privEnableCompression };
        this.privCertificateValidatedDeferral.resolve(), e.agent = this.getAgent();
        let r = new URL(this.privUri).protocol;
        (r == null ? void 0 : r.toLocaleLowerCase()) === "wss:" ? r = "https:" : (r == null ? void 0 : r.toLocaleLowerCase()) === "ws:" && (r = "http:"), e.agent.protocol = r, this.privWebsocketClient = new r0.default(this.privUri, e);
      }
      this.privWebsocketClient.binaryType = "arraybuffer", this.privReceivingMessageQueue = new j.Queue(), this.privDisconnectDeferral = new j.Deferred(), this.privSendMessageQueue = new j.Queue(), this.processSendQueue().catch((e) => {
        j.Events.instance.onEvent(new j.BackgroundEvent(e));
      });
    } catch (e) {
      return this.privConnectionEstablishDeferral.resolve(new j.ConnectionOpenResponse(500, e)), this.privConnectionEstablishDeferral.promise;
    }
    return this.onEvent(new j.ConnectionStartEvent(this.privConnectionId, this.privUri)), this.privWebsocketClient.onopen = () => {
      this.privCertificateValidatedDeferral.promise.then(() => {
        this.privConnectionState = j.ConnectionState.Connected, this.onEvent(new j.ConnectionEstablishedEvent(this.privConnectionId)), this.privConnectionEstablishDeferral.resolve(new j.ConnectionOpenResponse(200, ""));
      }, (e) => {
        this.privConnectionEstablishDeferral.reject(e);
      });
    }, this.privWebsocketClient.onerror = (e) => {
      this.onEvent(new j.ConnectionErrorEvent(this.privConnectionId, e.message, e.type)), this.privLastErrorReceived = e.message;
    }, this.privWebsocketClient.onclose = (e) => {
      this.privConnectionState === j.ConnectionState.Connecting ? (this.privConnectionState = j.ConnectionState.Disconnected, this.privConnectionEstablishDeferral.resolve(new j.ConnectionOpenResponse(e.code, e.reason + " " + this.privLastErrorReceived))) : (this.privConnectionState = j.ConnectionState.Disconnected, this.privWebsocketClient = null, this.onEvent(new j.ConnectionClosedEvent(this.privConnectionId, e.code, e.reason))), this.onClose(e.code, e.reason).catch((n) => {
        j.Events.instance.onEvent(new j.BackgroundEvent(n));
      });
    }, this.privWebsocketClient.onmessage = (e) => {
      const n = (/* @__PURE__ */ new Date()).toISOString();
      if (this.privConnectionState === j.ConnectionState.Connected) {
        const r = new j.Deferred();
        if (this.privReceivingMessageQueue.enqueueFromPromise(r.promise), e.data instanceof ArrayBuffer) {
          const s = new j.RawWebsocketMessage(j.MessageType.Binary, e.data);
          this.privMessageFormatter.toConnectionMessage(s).then((o) => {
            this.onEvent(new j.ConnectionMessageReceivedEvent(this.privConnectionId, n, o)), r.resolve(o);
          }, (o) => {
            r.reject(`Invalid binary message format. Error: ${o}`);
          });
        } else {
          const s = new j.RawWebsocketMessage(j.MessageType.Text, e.data);
          this.privMessageFormatter.toConnectionMessage(s).then((o) => {
            this.onEvent(new j.ConnectionMessageReceivedEvent(this.privConnectionId, n, o)), r.resolve(o);
          }, (o) => {
            r.reject(`Invalid text message format. Error: ${o}`);
          });
        }
      }
    }, this.privConnectionEstablishDeferral.promise;
  }
  send(e) {
    if (this.privConnectionState !== j.ConnectionState.Connected)
      return Promise.reject(`Cannot send on connection that is in ${j.ConnectionState[this.privConnectionState]} state`);
    const n = new j.Deferred(), r = new j.Deferred();
    return this.privSendMessageQueue.enqueueFromPromise(r.promise), this.privMessageFormatter.fromConnectionMessage(e).then((s) => {
      r.resolve({
        Message: e,
        RawWebsocketMessage: s,
        sendStatusDeferral: n
      });
    }, (s) => {
      r.reject(`Error formatting the message. ${s}`);
    }), n.promise;
  }
  read() {
    return this.privConnectionState !== j.ConnectionState.Connected ? Promise.reject(`Cannot read on connection that is in ${this.privConnectionState} state`) : this.privReceivingMessageQueue.dequeue();
  }
  close(e) {
    if (this.privWebsocketClient)
      this.privConnectionState !== j.ConnectionState.Disconnected && this.privWebsocketClient.close(1e3, e || "Normal closure by client");
    else
      return Promise.resolve();
    return this.privDisconnectDeferral.promise;
  }
  get events() {
    return this.privConnectionEvents;
  }
  sendRawMessage(e) {
    try {
      if (!e)
        return Promise.resolve();
      if (this.onEvent(new j.ConnectionMessageSentEvent(this.privConnectionId, (/* @__PURE__ */ new Date()).toISOString(), e.Message)), this.isWebsocketOpen)
        this.privWebsocketClient.send(e.RawWebsocketMessage.payload);
      else
        return Promise.reject("websocket send error: Websocket not ready " + this.privConnectionId + " " + e.Message.id + " " + new Error().stack);
      return Promise.resolve();
    } catch (n) {
      return Promise.reject(`websocket send error: ${n}`);
    }
  }
  async onClose(e, n) {
    const r = `Connection closed. ${e}: ${n}`;
    this.privConnectionState = j.ConnectionState.Disconnected, this.privDisconnectDeferral.resolve(), await this.privReceivingMessageQueue.drainAndDispose(() => {
    }, r), await this.privSendMessageQueue.drainAndDispose((s) => {
      s.sendStatusDeferral.reject(r);
    }, r);
  }
  async processSendQueue() {
    for (; ; ) {
      const n = await this.privSendMessageQueue.dequeue();
      if (!n)
        return;
      try {
        await this.sendRawMessage(n), n.sendStatusDeferral.resolve();
      } catch (r) {
        n.sendStatusDeferral.reject(r);
      }
    }
  }
  onEvent(e) {
    this.privConnectionEvents.onEvent(e), j.Events.instance.onEvent(e);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getAgent() {
    const e = new t0.default.Agent(this.createConnection);
    return this.proxyInfo !== void 0 && this.proxyInfo.HostName !== void 0 && this.proxyInfo.Port > 0 && (e.proxyInfo = this.proxyInfo), e;
  }
  static GetProxyAgent(e) {
    const n = {
      host: e.HostName,
      port: e.Port
    };
    return e.UserName ? n.headers = {
      "Proxy-Authentication": "Basic " + new Buffer(`${e.UserName}:${e.Password === void 0 ? "" : e.Password}`).toString("base64")
    } : n.headers = {}, n.headers.requestOCSP = "true", new n0.default(n);
  }
  createConnection(e, n) {
    let r;
    if (n = {
      ...n,
      requestOCSP: !0,
      servername: n.host
    }, this.proxyInfo) {
      const o = as.GetProxyAgent(this.proxyInfo);
      r = new Promise((a, i) => {
        o.callback(e, n, (c, u) => {
          c ? i(c) : a(u);
        });
      });
    } else
      n.secureEndpoint ? r = Promise.resolve(e0.connect(n)) : r = Promise.resolve(X_.connect(n));
    return r;
  }
  get isWebsocketOpen() {
    return this.privWebsocketClient && this.privWebsocketClient.readyState === this.privWebsocketClient.OPEN;
  }
}
Ss.WebsocketMessageAdapter = as;
as.forceNpmWebSocket = !1;
Object.defineProperty(Xo, "__esModule", { value: !0 });
Xo.WebsocketConnection = void 0;
const gc = k(), s0 = Ss;
class o0 {
  constructor(e, n, r, s, o, a = !1, i) {
    if (this.privIsDisposed = !1, !e)
      throw new gc.ArgumentNullError("uri");
    if (!s)
      throw new gc.ArgumentNullError("messageFormatter");
    this.privMessageFormatter = s;
    let c = "", u = 0;
    if (n) {
      for (const p in n)
        if (p) {
          c += u === 0 && e.indexOf("?") === -1 ? "?" : "&";
          const d = encodeURIComponent(p);
          c += d;
          let l = n[p];
          l && (l = encodeURIComponent(l), c += `=${l}`), u++;
        }
    }
    if (r) {
      for (const p in r)
        if (p) {
          c += u === 0 && e.indexOf("?") === -1 ? "?" : "&";
          const d = encodeURIComponent(r[p]);
          c += `${p}=${d}`, u++;
        }
    }
    this.privUri = e + c, this.privId = i || gc.createNoDashGuid(), this.privConnectionMessageAdapter = new s0.WebsocketMessageAdapter(this.privUri, this.id, this.privMessageFormatter, o, r, a);
  }
  async dispose() {
    this.privIsDisposed = !0, this.privConnectionMessageAdapter && await this.privConnectionMessageAdapter.close();
  }
  isDisposed() {
    return this.privIsDisposed;
  }
  get id() {
    return this.privId;
  }
  get uri() {
    return this.privUri;
  }
  state() {
    return this.privConnectionMessageAdapter.state;
  }
  open() {
    return this.privConnectionMessageAdapter.open();
  }
  send(e) {
    return this.privConnectionMessageAdapter.send(e);
  }
  read() {
    return this.privConnectionMessageAdapter.read();
  }
  get events() {
    return this.privConnectionMessageAdapter.events;
  }
}
Xo.WebsocketConnection = o0;
var ea = {};
Object.defineProperty(ea, "__esModule", { value: !0 });
ea.ReplayableAudioNode = void 0;
class a0 {
  constructor(e, n) {
    this.privBuffers = [], this.privReplayOffset = 0, this.privLastShrinkOffset = 0, this.privBufferStartOffset = 0, this.privBufferSerial = 0, this.privBufferedBytes = 0, this.privReplay = !1, this.privLastChunkAcquiredTime = 0, this.privAudioNode = e, this.privBytesPerSecond = n;
  }
  id() {
    return this.privAudioNode.id();
  }
  // Reads and returns the next chunk of audio buffer.
  // If replay of existing buffers are needed, read() will first seek and replay
  // existing content, and upoin completion it will read new content from the underlying
  // audio node, saving that content into the replayable buffers.
  read() {
    if (this.privReplay && this.privBuffers.length !== 0) {
      const e = this.privReplayOffset - this.privBufferStartOffset;
      let n = Math.round(e * this.privBytesPerSecond * 1e-7);
      n % 2 !== 0 && n++;
      let r = 0;
      for (; r < this.privBuffers.length && n >= this.privBuffers[r].chunk.buffer.byteLength; )
        n -= this.privBuffers[r++].chunk.buffer.byteLength;
      if (r < this.privBuffers.length) {
        const s = this.privBuffers[r].chunk.buffer.slice(n);
        return this.privReplayOffset += s.byteLength / this.privBytesPerSecond * 1e7, r === this.privBuffers.length - 1 && (this.privReplay = !1), Promise.resolve({
          buffer: s,
          isEnd: !1,
          timeReceived: this.privBuffers[r].chunk.timeReceived
        });
      }
    }
    return this.privAudioNode.read().then((e) => (e && e.buffer && (this.privBuffers.push(new c0(e, this.privBufferSerial++, this.privBufferedBytes)), this.privBufferedBytes += e.buffer.byteLength), e));
  }
  detach() {
    return this.privBuffers = void 0, this.privAudioNode.detach();
  }
  replay() {
    this.privBuffers && this.privBuffers.length !== 0 && (this.privReplay = !0, this.privReplayOffset = this.privLastShrinkOffset);
  }
  // Shrinks the existing audio buffers to start at the new offset, or at the
  // beginning of the buffer closest to the requested offset.
  // A replay request will start from the last shrink point.
  shrinkBuffers(e) {
    if (this.privBuffers === void 0 || this.privBuffers.length === 0)
      return;
    this.privLastShrinkOffset = e;
    const n = e - this.privBufferStartOffset;
    let r = Math.round(n * this.privBytesPerSecond * 1e-7), s = 0;
    for (; s < this.privBuffers.length && r >= this.privBuffers[s].chunk.buffer.byteLength; )
      r -= this.privBuffers[s++].chunk.buffer.byteLength;
    this.privBufferStartOffset = Math.round(e - r / this.privBytesPerSecond * 1e7), this.privBuffers = this.privBuffers.slice(s);
  }
  // Finds the time a buffer of audio was first seen by offset.
  findTimeAtOffset(e) {
    if (e < this.privBufferStartOffset || this.privBuffers === void 0)
      return 0;
    for (const n of this.privBuffers) {
      const r = n.byteOffset / this.privBytesPerSecond * 1e7, s = r + n.chunk.buffer.byteLength / this.privBytesPerSecond * 1e7;
      if (e >= r && e <= s)
        return n.chunk.timeReceived;
    }
    return 0;
  }
}
ea.ReplayableAudioNode = a0;
class c0 {
  constructor(e, n, r) {
    this.chunk = e, this.serial = n, this.byteOffset = r;
  }
}
var yr = {}, mc = {}, ft = {}, ys = {}, u0 = W && W.__createBinding || (Object.create ? function(t, e, n, r) {
  r === void 0 && (r = n), Object.defineProperty(t, r, { enumerable: !0, get: function() {
    return e[n];
  } });
} : function(t, e, n, r) {
  r === void 0 && (r = n), t[r] = e[n];
}), p0 = W && W.__setModuleDefault || (Object.create ? function(t, e) {
  Object.defineProperty(t, "default", { enumerable: !0, value: e });
} : function(t, e) {
  t.default = e;
}), d0 = W && W.__importStar || function(t) {
  if (t && t.__esModule)
    return t;
  var e = {};
  if (t != null)
    for (var n in t)
      n !== "default" && Object.hasOwnProperty.call(t, n) && u0(e, t, n);
  return p0(e, t), e;
};
Object.defineProperty(ys, "__esModule", { value: !0 });
ys.AudioFileWriter = void 0;
const Cr = d0(Tn), Sc = N;
class l0 {
  constructor(e) {
    Sc.Contracts.throwIfNullOrUndefined(Cr.openSync, `
File System access not available, please use Push or PullAudioOutputStream`), this.privFd = Cr.openSync(e, "w");
  }
  set format(e) {
    Sc.Contracts.throwIfNotUndefined(this.privAudioFormat, "format is already set"), this.privAudioFormat = e;
    let n = 0;
    this.privAudioFormat.hasHeader && (n = this.privAudioFormat.header.byteLength), this.privFd !== void 0 && (this.privWriteStream = Cr.createWriteStream("", { fd: this.privFd, start: n, autoClose: !1 }));
  }
  write(e) {
    Sc.Contracts.throwIfNullOrUndefined(this.privAudioFormat, "must set format before writing."), this.privWriteStream !== void 0 && this.privWriteStream.write(new Uint8Array(e.slice(0)));
  }
  close() {
    this.privFd !== void 0 && (this.privWriteStream.on("finish", () => {
      this.privAudioFormat.hasHeader && (this.privAudioFormat.updateHeader(this.privWriteStream.bytesWritten), Cr.writeSync(this.privFd, new Int8Array(this.privAudioFormat.header), 0, this.privAudioFormat.header.byteLength, 0)), Cr.closeSync(this.privFd), this.privFd = void 0;
    }), this.privWriteStream.end());
  }
  id() {
    return this.privId;
  }
}
ys.AudioFileWriter = l0;
var Ve = {}, Qp;
function Sf() {
  if (Qp)
    return Ve;
  Qp = 1, Object.defineProperty(Ve, "__esModule", { value: !0 }), Ve.PullAudioInputStreamImpl = Ve.PullAudioInputStream = Ve.PushAudioInputStreamImpl = Ve.PushAudioInputStream = Ve.AudioInputStream = void 0;
  const t = A(), e = k(), n = Ye, r = R(), s = Wt;
  let o = class {
    /**
     * Creates and initializes an instance.
     * @constructor
     */
    constructor() {
    }
    /**
     * Creates a memory backed PushAudioInputStream with the specified audio format.
     * @member AudioInputStream.createPushStream
     * @function
     * @public
     * @param {AudioStreamFormat} format - The audio data format in which audio will be
     * written to the push audio stream's write() method (Required if format is not 16 kHz 16bit mono PCM).
     * @returns {PushAudioInputStream} The audio input stream being created.
     */
    static createPushStream(d) {
      return a.create(d);
    }
    /**
     * Creates a PullAudioInputStream that delegates to the specified callback interface for read()
     * and close() methods.
     * @member AudioInputStream.createPullStream
     * @function
     * @public
     * @param {PullAudioInputStreamCallback} callback - The custom audio input object, derived from
     * PullAudioInputStreamCallback
     * @param {AudioStreamFormat} format - The audio data format in which audio will be returned from
     * the callback's read() method (Required if format is not 16 kHz 16bit mono PCM).
     * @returns {PullAudioInputStream} The audio input stream being created.
     */
    static createPullStream(d, l) {
      return c.create(d, l);
    }
  };
  Ve.AudioInputStream = o;
  class a extends o {
    /**
     * Creates a memory backed PushAudioInputStream with the specified audio format.
     * @member PushAudioInputStream.create
     * @function
     * @public
     * @param {AudioStreamFormat} format - The audio data format in which audio will be written to the
     * push audio stream's write() method (Required if format is not 16 kHz 16bit mono PCM).
     * @returns {PushAudioInputStream} The push audio input stream being created.
     */
    static create(d) {
      return new i(d);
    }
  }
  Ve.PushAudioInputStream = a;
  class i extends a {
    /**
     * Creates and initalizes an instance with the given values.
     * @constructor
     * @param {AudioStreamFormat} format - The audio stream format.
     */
    constructor(d) {
      super(), d === void 0 ? this.privFormat = s.AudioStreamFormatImpl.getDefaultInputFormat() : this.privFormat = d, this.privEvents = new e.EventSource(), this.privId = n.createNoDashGuid(), this.privStream = new e.ChunkedArrayBufferStream(this.privFormat.avgBytesPerSec / 10);
    }
    /**
     * Format information for the audio
     */
    get format() {
      return Promise.resolve(this.privFormat);
    }
    /**
     * Writes the audio data specified by making an internal copy of the data.
     * @member PushAudioInputStreamImpl.prototype.write
     * @function
     * @public
     * @param {ArrayBuffer} dataBuffer - The audio buffer of which this function will make a copy.
     */
    write(d) {
      this.privStream.writeStreamChunk({
        buffer: d,
        isEnd: !1,
        timeReceived: Date.now()
      });
    }
    /**
     * Closes the stream.
     * @member PushAudioInputStreamImpl.prototype.close
     * @function
     * @public
     */
    close() {
      this.privStream.close();
    }
    id() {
      return this.privId;
    }
    turnOn() {
      this.onEvent(new e.AudioSourceInitializingEvent(this.privId)), this.onEvent(new e.AudioSourceReadyEvent(this.privId));
    }
    async attach(d) {
      this.onEvent(new e.AudioStreamNodeAttachingEvent(this.privId, d)), await this.turnOn();
      const l = this.privStream;
      return this.onEvent(new e.AudioStreamNodeAttachedEvent(this.privId, d)), {
        detach: async () => (this.onEvent(new e.AudioStreamNodeDetachedEvent(this.privId, d)), this.turnOff()),
        id: () => d,
        read: () => l.read()
      };
    }
    detach(d) {
      this.onEvent(new e.AudioStreamNodeDetachedEvent(this.privId, d));
    }
    turnOff() {
    }
    get events() {
      return this.privEvents;
    }
    get deviceInfo() {
      return Promise.resolve({
        bitspersample: this.privFormat.bitsPerSample,
        channelcount: this.privFormat.channels,
        connectivity: t.connectivity.Unknown,
        manufacturer: "Speech SDK",
        model: "PushStream",
        samplerate: this.privFormat.samplesPerSec,
        type: t.type.Stream
      });
    }
    onEvent(d) {
      this.privEvents.onEvent(d), e.Events.instance.onEvent(d);
    }
    toBuffer(d) {
      const l = Buffer.alloc(d.byteLength), h = new Uint8Array(d);
      for (let v = 0; v < l.length; ++v)
        l[v] = h[v];
      return l;
    }
  }
  Ve.PushAudioInputStreamImpl = i;
  class c extends o {
    /**
     * Creates and initializes and instance.
     * @constructor
     */
    constructor() {
      super();
    }
    /**
     * Creates a PullAudioInputStream that delegates to the specified callback interface for
     * read() and close() methods, using the default format (16 kHz 16bit mono PCM).
     * @member PullAudioInputStream.create
     * @function
     * @public
     * @param {PullAudioInputStreamCallback} callback - The custom audio input object,
     * derived from PullAudioInputStreamCustomCallback
     * @param {AudioStreamFormat} format - The audio data format in which audio will be
     * returned from the callback's read() method (Required if format is not 16 kHz 16bit mono PCM).
     * @returns {PullAudioInputStream} The push audio input stream being created.
     */
    static create(d, l) {
      return new u(d, l);
    }
  }
  Ve.PullAudioInputStream = c;
  class u extends c {
    /**
     * Creates a PullAudioInputStream that delegates to the specified callback interface for
     * read() and close() methods, using the default format (16 kHz 16bit mono PCM).
     * @constructor
     * @param {PullAudioInputStreamCallback} callback - The custom audio input object,
     * derived from PullAudioInputStreamCustomCallback
     * @param {AudioStreamFormat} format - The audio data format in which audio will be
     * returned from the callback's read() method (Required if format is not 16 kHz 16bit mono PCM).
     */
    constructor(d, l) {
      super(), l === void 0 ? this.privFormat = r.AudioStreamFormat.getDefaultInputFormat() : this.privFormat = l, this.privEvents = new e.EventSource(), this.privId = n.createNoDashGuid(), this.privCallback = d, this.privIsClosed = !1, this.privBufferSize = this.privFormat.avgBytesPerSec / 10;
    }
    /**
     * Format information for the audio
     */
    get format() {
      return Promise.resolve(this.privFormat);
    }
    /**
     * Closes the stream.
     * @member PullAudioInputStreamImpl.prototype.close
     * @function
     * @public
     */
    close() {
      this.privIsClosed = !0, this.privCallback.close();
    }
    id() {
      return this.privId;
    }
    turnOn() {
      this.onEvent(new e.AudioSourceInitializingEvent(this.privId)), this.onEvent(new e.AudioSourceReadyEvent(this.privId));
    }
    async attach(d) {
      return this.onEvent(new e.AudioStreamNodeAttachingEvent(this.privId, d)), await this.turnOn(), this.onEvent(new e.AudioStreamNodeAttachedEvent(this.privId, d)), {
        detach: () => (this.privCallback.close(), this.onEvent(new e.AudioStreamNodeDetachedEvent(this.privId, d)), this.turnOff()),
        id: () => d,
        read: () => {
          let l = 0, h;
          for (; l < this.privBufferSize; ) {
            const v = new ArrayBuffer(this.privBufferSize - l), g = this.privCallback.read(v);
            if (h === void 0 ? h = v : new Int8Array(h).set(new Int8Array(v), l), g === 0)
              break;
            l += g;
          }
          return Promise.resolve({
            buffer: h.slice(0, l),
            isEnd: this.privIsClosed || l === 0,
            timeReceived: Date.now()
          });
        }
      };
    }
    detach(d) {
      this.onEvent(new e.AudioStreamNodeDetachedEvent(this.privId, d));
    }
    turnOff() {
    }
    get events() {
      return this.privEvents;
    }
    get deviceInfo() {
      return Promise.resolve({
        bitspersample: this.privFormat.bitsPerSample,
        channelcount: this.privFormat.channels,
        connectivity: t.connectivity.Unknown,
        manufacturer: "Speech SDK",
        model: "PullStream",
        samplerate: this.privFormat.samplesPerSec,
        type: t.type.Stream
      });
    }
    onEvent(d) {
      this.privEvents.onEvent(d), e.Events.instance.onEvent(d);
    }
  }
  return Ve.PullAudioInputStreamImpl = u, Ve;
}
var Re = {}, Vt = {}, ku = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.SpeechSynthesisOutputFormat = void 0, function(e) {
    e[e.Raw8Khz8BitMonoMULaw = 0] = "Raw8Khz8BitMonoMULaw", e[e.Riff16Khz16KbpsMonoSiren = 1] = "Riff16Khz16KbpsMonoSiren", e[e.Audio16Khz16KbpsMonoSiren = 2] = "Audio16Khz16KbpsMonoSiren", e[e.Audio16Khz32KBitRateMonoMp3 = 3] = "Audio16Khz32KBitRateMonoMp3", e[e.Audio16Khz128KBitRateMonoMp3 = 4] = "Audio16Khz128KBitRateMonoMp3", e[e.Audio16Khz64KBitRateMonoMp3 = 5] = "Audio16Khz64KBitRateMonoMp3", e[e.Audio24Khz48KBitRateMonoMp3 = 6] = "Audio24Khz48KBitRateMonoMp3", e[e.Audio24Khz96KBitRateMonoMp3 = 7] = "Audio24Khz96KBitRateMonoMp3", e[e.Audio24Khz160KBitRateMonoMp3 = 8] = "Audio24Khz160KBitRateMonoMp3", e[e.Raw16Khz16BitMonoTrueSilk = 9] = "Raw16Khz16BitMonoTrueSilk", e[e.Riff16Khz16BitMonoPcm = 10] = "Riff16Khz16BitMonoPcm", e[e.Riff8Khz16BitMonoPcm = 11] = "Riff8Khz16BitMonoPcm", e[e.Riff24Khz16BitMonoPcm = 12] = "Riff24Khz16BitMonoPcm", e[e.Riff8Khz8BitMonoMULaw = 13] = "Riff8Khz8BitMonoMULaw", e[e.Raw16Khz16BitMonoPcm = 14] = "Raw16Khz16BitMonoPcm", e[e.Raw24Khz16BitMonoPcm = 15] = "Raw24Khz16BitMonoPcm", e[e.Raw8Khz16BitMonoPcm = 16] = "Raw8Khz16BitMonoPcm", e[e.Ogg16Khz16BitMonoOpus = 17] = "Ogg16Khz16BitMonoOpus", e[e.Ogg24Khz16BitMonoOpus = 18] = "Ogg24Khz16BitMonoOpus", e[e.Raw48Khz16BitMonoPcm = 19] = "Raw48Khz16BitMonoPcm", e[e.Riff48Khz16BitMonoPcm = 20] = "Riff48Khz16BitMonoPcm", e[e.Audio48Khz96KBitRateMonoMp3 = 21] = "Audio48Khz96KBitRateMonoMp3", e[e.Audio48Khz192KBitRateMonoMp3 = 22] = "Audio48Khz192KBitRateMonoMp3", e[e.Ogg48Khz16BitMonoOpus = 23] = "Ogg48Khz16BitMonoOpus", e[e.Webm16Khz16BitMonoOpus = 24] = "Webm16Khz16BitMonoOpus", e[e.Webm24Khz16BitMonoOpus = 25] = "Webm24Khz16BitMonoOpus", e[e.Raw24Khz16BitMonoTrueSilk = 26] = "Raw24Khz16BitMonoTrueSilk", e[e.Raw8Khz8BitMonoALaw = 27] = "Raw8Khz8BitMonoALaw", e[e.Riff8Khz8BitMonoALaw = 28] = "Riff8Khz8BitMonoALaw", e[e.Webm24Khz16Bit24KbpsMonoOpus = 29] = "Webm24Khz16Bit24KbpsMonoOpus", e[e.Audio16Khz16Bit32KbpsMonoOpus = 30] = "Audio16Khz16Bit32KbpsMonoOpus", e[e.Audio24Khz16Bit48KbpsMonoOpus = 31] = "Audio24Khz16Bit48KbpsMonoOpus", e[e.Audio24Khz16Bit24KbpsMonoOpus = 32] = "Audio24Khz16Bit24KbpsMonoOpus", e[e.Raw22050Hz16BitMonoPcm = 33] = "Raw22050Hz16BitMonoPcm", e[e.Riff22050Hz16BitMonoPcm = 34] = "Riff22050Hz16BitMonoPcm", e[e.Raw44100Hz16BitMonoPcm = 35] = "Raw44100Hz16BitMonoPcm", e[e.Riff44100Hz16BitMonoPcm = 36] = "Riff44100Hz16BitMonoPcm", e[e.AmrWb16000Hz = 37] = "AmrWb16000Hz", e[e.G72216Khz64Kbps = 38] = "G72216Khz64Kbps";
  }(t.SpeechSynthesisOutputFormat || (t.SpeechSynthesisOutputFormat = {}));
})(ku);
Object.defineProperty(Vt, "__esModule", { value: !0 });
Vt.AudioOutputFormatImpl = void 0;
const F = ku, B = Wt;
class D extends B.AudioStreamFormatImpl {
  /**
   * Creates an instance with the given values.
   * @constructor
   * @param formatTag
   * @param {number} channels - Number of channels.
   * @param {number} samplesPerSec - Samples per second.
   * @param {number} avgBytesPerSec - Average bytes per second.
   * @param {number} blockAlign - Block alignment.
   * @param {number} bitsPerSample - Bits per sample.
   * @param {string} audioFormatString - Audio format string
   * @param {string} requestAudioFormatString - Audio format string sent to service.
   * @param {boolean} hasHeader - If the format has header or not.
   */
  constructor(e, n, r, s, o, a, i, c, u) {
    super(r, a, n, e), this.formatTag = e, this.avgBytesPerSec = s, this.blockAlign = o, this.priAudioFormatString = i, this.priRequestAudioFormatString = c, this.priHasHeader = u;
  }
  static fromSpeechSynthesisOutputFormat(e) {
    return e === void 0 ? D.getDefaultOutputFormat() : D.fromSpeechSynthesisOutputFormatString(D.SpeechSynthesisOutputFormatToString[e]);
  }
  static fromSpeechSynthesisOutputFormatString(e) {
    switch (e) {
      case "raw-8khz-8bit-mono-mulaw":
        return new D(B.AudioFormatTag.MuLaw, 1, 8e3, 8e3, 1, 8, e, e, !1);
      case "riff-16khz-16kbps-mono-siren":
        return new D(B.AudioFormatTag.Siren, 1, 16e3, 2e3, 40, 0, e, "audio-16khz-16kbps-mono-siren", !0);
      case "audio-16khz-16kbps-mono-siren":
        return new D(B.AudioFormatTag.Siren, 1, 16e3, 2e3, 40, 0, e, e, !1);
      case "audio-16khz-32kbitrate-mono-mp3":
        return new D(B.AudioFormatTag.MP3, 1, 16e3, 4096, 2, 16, e, e, !1);
      case "audio-16khz-128kbitrate-mono-mp3":
        return new D(B.AudioFormatTag.MP3, 1, 16e3, 16384, 2, 16, e, e, !1);
      case "audio-16khz-64kbitrate-mono-mp3":
        return new D(B.AudioFormatTag.MP3, 1, 16e3, 8192, 2, 16, e, e, !1);
      case "audio-24khz-48kbitrate-mono-mp3":
        return new D(B.AudioFormatTag.MP3, 1, 24e3, 6144, 2, 16, e, e, !1);
      case "audio-24khz-96kbitrate-mono-mp3":
        return new D(B.AudioFormatTag.MP3, 1, 24e3, 12288, 2, 16, e, e, !1);
      case "audio-24khz-160kbitrate-mono-mp3":
        return new D(B.AudioFormatTag.MP3, 1, 24e3, 20480, 2, 16, e, e, !1);
      case "raw-16khz-16bit-mono-truesilk":
        return new D(B.AudioFormatTag.SILKSkype, 1, 16e3, 32e3, 2, 16, e, e, !1);
      case "riff-8khz-16bit-mono-pcm":
        return new D(B.AudioFormatTag.PCM, 1, 8e3, 16e3, 2, 16, e, "raw-8khz-16bit-mono-pcm", !0);
      case "riff-24khz-16bit-mono-pcm":
        return new D(B.AudioFormatTag.PCM, 1, 24e3, 48e3, 2, 16, e, "raw-24khz-16bit-mono-pcm", !0);
      case "riff-8khz-8bit-mono-mulaw":
        return new D(B.AudioFormatTag.MuLaw, 1, 8e3, 8e3, 1, 8, e, "raw-8khz-8bit-mono-mulaw", !0);
      case "raw-16khz-16bit-mono-pcm":
        return new D(B.AudioFormatTag.PCM, 1, 16e3, 32e3, 2, 16, e, "raw-16khz-16bit-mono-pcm", !1);
      case "raw-24khz-16bit-mono-pcm":
        return new D(B.AudioFormatTag.PCM, 1, 24e3, 48e3, 2, 16, e, "raw-24khz-16bit-mono-pcm", !1);
      case "raw-8khz-16bit-mono-pcm":
        return new D(B.AudioFormatTag.PCM, 1, 8e3, 16e3, 2, 16, e, "raw-8khz-16bit-mono-pcm", !1);
      case "ogg-16khz-16bit-mono-opus":
        return new D(B.AudioFormatTag.OGG_OPUS, 1, 16e3, 8192, 2, 16, e, e, !1);
      case "ogg-24khz-16bit-mono-opus":
        return new D(B.AudioFormatTag.OGG_OPUS, 1, 24e3, 8192, 2, 16, e, e, !1);
      case "raw-48khz-16bit-mono-pcm":
        return new D(B.AudioFormatTag.PCM, 1, 48e3, 96e3, 2, 16, e, "raw-48khz-16bit-mono-pcm", !1);
      case "riff-48khz-16bit-mono-pcm":
        return new D(B.AudioFormatTag.PCM, 1, 48e3, 96e3, 2, 16, e, "raw-48khz-16bit-mono-pcm", !0);
      case "audio-48khz-96kbitrate-mono-mp3":
        return new D(B.AudioFormatTag.MP3, 1, 48e3, 12288, 2, 16, e, e, !1);
      case "audio-48khz-192kbitrate-mono-mp3":
        return new D(B.AudioFormatTag.MP3, 1, 48e3, 24576, 2, 16, e, e, !1);
      case "ogg-48khz-16bit-mono-opus":
        return new D(B.AudioFormatTag.OGG_OPUS, 1, 48e3, 12e3, 2, 16, e, e, !1);
      case "webm-16khz-16bit-mono-opus":
        return new D(B.AudioFormatTag.WEBM_OPUS, 1, 16e3, 4e3, 2, 16, e, e, !1);
      case "webm-24khz-16bit-mono-opus":
        return new D(B.AudioFormatTag.WEBM_OPUS, 1, 24e3, 6e3, 2, 16, e, e, !1);
      case "webm-24khz-16bit-24kbps-mono-opus":
        return new D(B.AudioFormatTag.WEBM_OPUS, 1, 24e3, 3e3, 2, 16, e, e, !1);
      case "audio-16khz-16bit-32kbps-mono-opus":
        return new D(B.AudioFormatTag.OPUS, 1, 16e3, 4e3, 2, 16, e, e, !1);
      case "audio-24khz-16bit-48kbps-mono-opus":
        return new D(B.AudioFormatTag.OPUS, 1, 24e3, 6e3, 2, 16, e, e, !1);
      case "audio-24khz-16bit-24kbps-mono-opus":
        return new D(B.AudioFormatTag.OPUS, 1, 24e3, 3e3, 2, 16, e, e, !1);
      case "audio-24khz-16bit-mono-flac":
        return new D(B.AudioFormatTag.FLAC, 1, 24e3, 24e3, 2, 16, e, e, !1);
      case "audio-48khz-16bit-mono-flac":
        return new D(B.AudioFormatTag.FLAC, 1, 48e3, 3e4, 2, 16, e, e, !1);
      case "raw-24khz-16bit-mono-truesilk":
        return new D(B.AudioFormatTag.SILKSkype, 1, 24e3, 48e3, 2, 16, e, e, !1);
      case "raw-8khz-8bit-mono-alaw":
        return new D(B.AudioFormatTag.ALaw, 1, 8e3, 8e3, 1, 8, e, e, !1);
      case "riff-8khz-8bit-mono-alaw":
        return new D(B.AudioFormatTag.ALaw, 1, 8e3, 8e3, 1, 8, e, "raw-8khz-8bit-mono-alaw", !0);
      case "raw-22050hz-16bit-mono-pcm":
        return new D(B.AudioFormatTag.PCM, 1, 22050, 44100, 2, 16, e, e, !1);
      case "riff-22050hz-16bit-mono-pcm":
        return new D(B.AudioFormatTag.PCM, 1, 22050, 44100, 2, 16, e, "raw-22050hz-16bit-mono-pcm", !0);
      case "raw-44100hz-16bit-mono-pcm":
        return new D(B.AudioFormatTag.PCM, 1, 44100, 88200, 2, 16, e, e, !1);
      case "riff-44100hz-16bit-mono-pcm":
        return new D(B.AudioFormatTag.PCM, 1, 44100, 88200, 2, 16, e, "raw-44100hz-16bit-mono-pcm", !0);
      case "amr-wb-16000h":
        return new D(B.AudioFormatTag.AMR_WB, 1, 16e3, 3052, 2, 16, e, e, !1);
      case "g722-16khz-64kbps":
        return new D(B.AudioFormatTag.G722, 1, 16e3, 8e3, 2, 16, e, e, !1);
      case "riff-16khz-16bit-mono-pcm":
      default:
        return new D(B.AudioFormatTag.PCM, 1, 16e3, 32e3, 2, 16, "riff-16khz-16bit-mono-pcm", "raw-16khz-16bit-mono-pcm", !0);
    }
  }
  static getDefaultOutputFormat() {
    return D.fromSpeechSynthesisOutputFormatString(typeof window < "u" ? "audio-24khz-48kbitrate-mono-mp3" : "riff-16khz-16bit-mono-pcm");
  }
  /**
   * Specifies if this audio output format has a header
   * @boolean AudioOutputFormatImpl.prototype.hasHeader
   * @function
   * @public
   */
  get hasHeader() {
    return this.priHasHeader;
  }
  /**
   * Specifies the header of this format
   * @ArrayBuffer AudioOutputFormatImpl.prototype.header
   * @function
   * @public
   */
  get header() {
    if (this.hasHeader)
      return this.privHeader;
  }
  /**
   * Updates the header based on the audio length
   * @member AudioOutputFormatImpl.updateHeader
   * @function
   * @public
   * @param {number} audioLength - the audio length
   */
  updateHeader(e) {
    if (this.priHasHeader) {
      const n = new DataView(this.privHeader);
      n.setUint32(4, e + this.privHeader.byteLength - 8, !0), n.setUint32(40, e, !0);
    }
  }
  /**
   * Specifies the audio format string to be sent to the service
   * @string AudioOutputFormatImpl.prototype.requestAudioFormatString
   * @function
   * @public
   */
  get requestAudioFormatString() {
    return this.priRequestAudioFormatString;
  }
  /**
   * Adds audio header
   * @param audio the raw audio without header
   * @returns the audio with header if applicable
   */
  addHeader(e) {
    if (!this.hasHeader)
      return e;
    this.updateHeader(e.byteLength);
    const n = new Uint8Array(e.byteLength + this.header.byteLength);
    return n.set(new Uint8Array(this.header), 0), n.set(new Uint8Array(e), this.header.byteLength), n.buffer;
  }
}
Vt.AudioOutputFormatImpl = D;
D.SpeechSynthesisOutputFormatToString = {
  [F.SpeechSynthesisOutputFormat.Raw8Khz8BitMonoMULaw]: "raw-8khz-8bit-mono-mulaw",
  [F.SpeechSynthesisOutputFormat.Riff16Khz16KbpsMonoSiren]: "riff-16khz-16kbps-mono-siren",
  [F.SpeechSynthesisOutputFormat.Audio16Khz16KbpsMonoSiren]: "audio-16khz-16kbps-mono-siren",
  [F.SpeechSynthesisOutputFormat.Audio16Khz32KBitRateMonoMp3]: "audio-16khz-32kbitrate-mono-mp3",
  [F.SpeechSynthesisOutputFormat.Audio16Khz128KBitRateMonoMp3]: "audio-16khz-128kbitrate-mono-mp3",
  [F.SpeechSynthesisOutputFormat.Audio16Khz64KBitRateMonoMp3]: "audio-16khz-64kbitrate-mono-mp3",
  [F.SpeechSynthesisOutputFormat.Audio24Khz48KBitRateMonoMp3]: "audio-24khz-48kbitrate-mono-mp3",
  [F.SpeechSynthesisOutputFormat.Audio24Khz96KBitRateMonoMp3]: "audio-24khz-96kbitrate-mono-mp3",
  [F.SpeechSynthesisOutputFormat.Audio24Khz160KBitRateMonoMp3]: "audio-24khz-160kbitrate-mono-mp3",
  [F.SpeechSynthesisOutputFormat.Raw16Khz16BitMonoTrueSilk]: "raw-16khz-16bit-mono-truesilk",
  [F.SpeechSynthesisOutputFormat.Riff16Khz16BitMonoPcm]: "riff-16khz-16bit-mono-pcm",
  [F.SpeechSynthesisOutputFormat.Riff8Khz16BitMonoPcm]: "riff-8khz-16bit-mono-pcm",
  [F.SpeechSynthesisOutputFormat.Riff24Khz16BitMonoPcm]: "riff-24khz-16bit-mono-pcm",
  [F.SpeechSynthesisOutputFormat.Riff8Khz8BitMonoMULaw]: "riff-8khz-8bit-mono-mulaw",
  [F.SpeechSynthesisOutputFormat.Raw16Khz16BitMonoPcm]: "raw-16khz-16bit-mono-pcm",
  [F.SpeechSynthesisOutputFormat.Raw24Khz16BitMonoPcm]: "raw-24khz-16bit-mono-pcm",
  [F.SpeechSynthesisOutputFormat.Raw8Khz16BitMonoPcm]: "raw-8khz-16bit-mono-pcm",
  [F.SpeechSynthesisOutputFormat.Ogg16Khz16BitMonoOpus]: "ogg-16khz-16bit-mono-opus",
  [F.SpeechSynthesisOutputFormat.Ogg24Khz16BitMonoOpus]: "ogg-24khz-16bit-mono-opus",
  [F.SpeechSynthesisOutputFormat.Raw48Khz16BitMonoPcm]: "raw-48khz-16bit-mono-pcm",
  [F.SpeechSynthesisOutputFormat.Riff48Khz16BitMonoPcm]: "riff-48khz-16bit-mono-pcm",
  [F.SpeechSynthesisOutputFormat.Audio48Khz96KBitRateMonoMp3]: "audio-48khz-96kbitrate-mono-mp3",
  [F.SpeechSynthesisOutputFormat.Audio48Khz192KBitRateMonoMp3]: "audio-48khz-192kbitrate-mono-mp3",
  [F.SpeechSynthesisOutputFormat.Ogg48Khz16BitMonoOpus]: "ogg-48khz-16bit-mono-opus",
  [F.SpeechSynthesisOutputFormat.Webm16Khz16BitMonoOpus]: "webm-16khz-16bit-mono-opus",
  [F.SpeechSynthesisOutputFormat.Webm24Khz16BitMonoOpus]: "webm-24khz-16bit-mono-opus",
  [F.SpeechSynthesisOutputFormat.Webm24Khz16Bit24KbpsMonoOpus]: "webm-24khz-16bit-24kbps-mono-opus",
  [F.SpeechSynthesisOutputFormat.Raw24Khz16BitMonoTrueSilk]: "raw-24khz-16bit-mono-truesilk",
  [F.SpeechSynthesisOutputFormat.Raw8Khz8BitMonoALaw]: "raw-8khz-8bit-mono-alaw",
  [F.SpeechSynthesisOutputFormat.Riff8Khz8BitMonoALaw]: "riff-8khz-8bit-mono-alaw",
  [F.SpeechSynthesisOutputFormat.Audio16Khz16Bit32KbpsMonoOpus]: "audio-16khz-16bit-32kbps-mono-opus",
  [F.SpeechSynthesisOutputFormat.Audio24Khz16Bit48KbpsMonoOpus]: "audio-24khz-16bit-48kbps-mono-opus",
  [F.SpeechSynthesisOutputFormat.Audio24Khz16Bit24KbpsMonoOpus]: "audio-24khz-16bit-24kbps-mono-opus",
  [F.SpeechSynthesisOutputFormat.Raw22050Hz16BitMonoPcm]: "raw-22050hz-16bit-mono-pcm",
  [F.SpeechSynthesisOutputFormat.Riff22050Hz16BitMonoPcm]: "riff-22050hz-16bit-mono-pcm",
  [F.SpeechSynthesisOutputFormat.Raw44100Hz16BitMonoPcm]: "raw-44100hz-16bit-mono-pcm",
  [F.SpeechSynthesisOutputFormat.Riff44100Hz16BitMonoPcm]: "riff-44100hz-16bit-mono-pcm",
  [F.SpeechSynthesisOutputFormat.AmrWb16000Hz]: "amr-wb-16000hz",
  [F.SpeechSynthesisOutputFormat.G72216Khz64Kbps]: "g722-16khz-64kbps"
};
Object.defineProperty(Re, "__esModule", { value: !0 });
Re.PushAudioOutputStreamImpl = Re.PushAudioOutputStream = Re.PullAudioOutputStreamImpl = Re.PullAudioOutputStream = Re.AudioOutputStream = void 0;
const Kc = k(), h0 = N, v0 = Vt;
class Ou {
  /**
   * Creates and initializes an instance.
   * @constructor
   */
  constructor() {
  }
  /**
   * Creates a memory backed PullAudioOutputStream with the specified audio format.
   * @member AudioOutputStream.createPullStream
   * @function
   * @public
   * @returns {PullAudioOutputStream} The audio output stream being created.
   */
  static createPullStream() {
    return Du.create();
  }
}
Re.AudioOutputStream = Ou;
class Du extends Ou {
  /**
   * Creates a memory backed PullAudioOutputStream with the specified audio format.
   * @member PullAudioOutputStream.create
   * @function
   * @public
   * @returns {PullAudioOutputStream} The push audio output stream being created.
   */
  static create() {
    return new yf();
  }
}
Re.PullAudioOutputStream = Du;
class yf extends Du {
  /**
   * Creates and initializes an instance with the given values.
   * @constructor
   */
  constructor() {
    super(), this.privId = Kc.createNoDashGuid(), this.privStream = new Kc.Stream();
  }
  /**
   * Sets the format information to the stream. For internal use only.
   * @param {AudioStreamFormat} format - the format to be set.
   */
  set format(e) {
    e == null && (this.privFormat = v0.AudioOutputFormatImpl.getDefaultOutputFormat()), this.privFormat = e;
  }
  /**
   * Format information for the audio
   */
  get format() {
    return this.privFormat;
  }
  /**
   * Checks if the stream is closed
   * @member PullAudioOutputStreamImpl.prototype.isClosed
   * @property
   * @public
   */
  get isClosed() {
    return this.privStream.isClosed;
  }
  /**
   * Gets the id of the stream
   * @member PullAudioOutputStreamImpl.prototype.id
   * @property
   * @public
   */
  id() {
    return this.privId;
  }
  /**
   * Reads audio data from the internal buffer.
   * @member PullAudioOutputStreamImpl.prototype.read
   * @function
   * @public
   * @param {ArrayBuffer} dataBuffer - An ArrayBuffer to store the read data.
   * @returns {Promise<number>} - Audio buffer length has been read.
   */
  async read(e) {
    const n = new Int8Array(e);
    let r = 0;
    if (this.privLastChunkView !== void 0) {
      if (this.privLastChunkView.length > e.byteLength)
        return n.set(this.privLastChunkView.slice(0, e.byteLength)), this.privLastChunkView = this.privLastChunkView.slice(e.byteLength), Promise.resolve(e.byteLength);
      n.set(this.privLastChunkView), r = this.privLastChunkView.length, this.privLastChunkView = void 0;
    }
    for (; r < e.byteLength && !this.privStream.isReadEnded; ) {
      const s = await this.privStream.read();
      if (s !== void 0 && !s.isEnd) {
        let o;
        s.buffer.byteLength > e.byteLength - r ? (o = s.buffer.slice(0, e.byteLength - r), this.privLastChunkView = new Int8Array(s.buffer.slice(e.byteLength - r))) : o = s.buffer, n.set(new Int8Array(o), r), r += o.byteLength;
      } else
        this.privStream.readEnded();
    }
    return r;
  }
  /**
   * Writes the audio data specified by making an internal copy of the data.
   * @member PullAudioOutputStreamImpl.prototype.write
   * @function
   * @public
   * @param {ArrayBuffer} dataBuffer - The audio buffer of which this function will make a copy.
   */
  write(e) {
    h0.Contracts.throwIfNullOrUndefined(this.privStream, "must set format before writing"), this.privStream.writeStreamChunk({
      buffer: e,
      isEnd: !1,
      timeReceived: Date.now()
    });
  }
  /**
   * Closes the stream.
   * @member PullAudioOutputStreamImpl.prototype.close
   * @function
   * @public
   */
  close() {
    this.privStream.close();
  }
}
Re.PullAudioOutputStreamImpl = yf;
class Cf extends Ou {
  /**
   * Creates and initializes and instance.
   * @constructor
   */
  constructor() {
    super();
  }
  /**
   * Creates a PushAudioOutputStream that delegates to the specified callback interface for
   * write() and close() methods.
   * @member PushAudioOutputStream.create
   * @function
   * @public
   * @param {PushAudioOutputStreamCallback} callback - The custom audio output object,
   * derived from PushAudioOutputStreamCallback
   * @returns {PushAudioOutputStream} The push audio output stream being created.
   */
  static create(e) {
    return new _f(e);
  }
}
Re.PushAudioOutputStream = Cf;
class _f extends Cf {
  /**
   * Creates a PushAudioOutputStream that delegates to the specified callback interface for
   * read() and close() methods.
   * @constructor
   * @param {PushAudioOutputStreamCallback} callback - The custom audio output object,
   * derived from PushAudioOutputStreamCallback
   */
  constructor(e) {
    super(), this.privId = Kc.createNoDashGuid(), this.privCallback = e;
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  set format(e) {
  }
  write(e) {
    this.privCallback.write && this.privCallback.write(e);
  }
  close() {
    this.privCallback.close && this.privCallback.close();
  }
  id() {
    return this.privId;
  }
}
Re.PushAudioOutputStreamImpl = _f;
var Yp;
function Pf() {
  if (Yp)
    return ft;
  Yp = 1, Object.defineProperty(ft, "__esModule", { value: !0 }), ft.AudioOutputConfigImpl = ft.AudioConfigImpl = ft.AudioConfig = void 0;
  const t = ye(), e = N, n = R(), r = ys, s = Sf(), o = Re;
  let a = class Rf {
    /**
     * Creates an AudioConfig object representing the default microphone on the system.
     * @member AudioConfig.fromDefaultMicrophoneInput
     * @function
     * @public
     * @returns {AudioConfig} The audio input configuration being created.
     */
    static fromDefaultMicrophoneInput() {
      const p = new t.PcmRecorder(!0);
      return new i(new t.MicAudioSource(p));
    }
    /**
     * Creates an AudioConfig object representing a microphone with the specified device ID.
     * @member AudioConfig.fromMicrophoneInput
     * @function
     * @public
     * @param {string | undefined} deviceId - Specifies the device ID of the microphone to be used.
     * Default microphone is used the value is omitted.
     * @returns {AudioConfig} The audio input configuration being created.
     */
    static fromMicrophoneInput(p) {
      const d = new t.PcmRecorder(!0);
      return new i(new t.MicAudioSource(d, p));
    }
    /**
     * Creates an AudioConfig object representing the specified file.
     * @member AudioConfig.fromWavFileInput
     * @function
     * @public
     * @param {File} fileName - Specifies the audio input file. Currently, only WAV / PCM is supported.
     * @returns {AudioConfig} The audio input configuration being created.
     */
    static fromWavFileInput(p, d = "unnamedBuffer.wav") {
      return new i(new t.FileAudioSource(p, d));
    }
    /**
     * Creates an AudioConfig object representing the specified stream.
     * @member AudioConfig.fromStreamInput
     * @function
     * @public
     * @param {AudioInputStream | PullAudioInputStreamCallback | MediaStream} audioStream - Specifies the custom audio input
     * stream. Currently, only WAV / PCM is supported.
     * @returns {AudioConfig} The audio input configuration being created.
     */
    static fromStreamInput(p) {
      if (p instanceof n.PullAudioInputStreamCallback)
        return new i(new s.PullAudioInputStreamImpl(p));
      if (p instanceof n.AudioInputStream)
        return new i(p);
      if (typeof MediaStream < "u" && p instanceof MediaStream) {
        const d = new t.PcmRecorder(!1);
        return new i(new t.MicAudioSource(d, null, null, p));
      }
      throw new Error("Not Supported Type");
    }
    /**
     * Creates an AudioConfig object representing the default speaker.
     * @member AudioConfig.fromDefaultSpeakerOutput
     * @function
     * @public
     * @returns {AudioConfig} The audio output configuration being created.
     * Added in version 1.11.0
     */
    static fromDefaultSpeakerOutput() {
      return new c(new n.SpeakerAudioDestination());
    }
    /**
     * Creates an AudioConfig object representing the custom IPlayer object.
     * You can use the IPlayer object to control pause, resume, etc.
     * @member AudioConfig.fromSpeakerOutput
     * @function
     * @public
     * @param {IPlayer} player - the IPlayer object for playback.
     * @returns {AudioConfig} The audio output configuration being created.
     * Added in version 1.12.0
     */
    static fromSpeakerOutput(p) {
      if (p === void 0)
        return Rf.fromDefaultSpeakerOutput();
      if (p instanceof n.SpeakerAudioDestination)
        return new c(p);
      throw new Error("Not Supported Type");
    }
    /**
     * Creates an AudioConfig object representing a specified output audio file
     * @member AudioConfig.fromAudioFileOutput
     * @function
     * @public
     * @param {PathLike} filename - the filename of the output audio file
     * @returns {AudioConfig} The audio output configuration being created.
     * Added in version 1.11.0
     */
    static fromAudioFileOutput(p) {
      return new c(new r.AudioFileWriter(p));
    }
    /**
     * Creates an AudioConfig object representing a specified audio output stream
     * @member AudioConfig.fromStreamOutput
     * @function
     * @public
     * @param {AudioOutputStream | PushAudioOutputStreamCallback} audioStream - Specifies the custom audio output
     * stream.
     * @returns {AudioConfig} The audio output configuration being created.
     * Added in version 1.11.0
     */
    static fromStreamOutput(p) {
      if (p instanceof n.PushAudioOutputStreamCallback)
        return new c(new o.PushAudioOutputStreamImpl(p));
      if (p instanceof n.PushAudioOutputStream)
        return new c(p);
      if (p instanceof n.PullAudioOutputStream)
        return new c(p);
      throw new Error("Not Supported Type");
    }
  };
  ft.AudioConfig = a;
  class i extends a {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {IAudioSource} source - An audio source.
     */
    constructor(p) {
      super(), this.privSource = p;
    }
    /**
     * Format information for the audio
     */
    get format() {
      return this.privSource.format;
    }
    /**
     * @member AudioConfigImpl.prototype.close
     * @function
     * @public
     */
    close(p, d) {
      this.privSource.turnOff().then(() => {
        p && p();
      }, (l) => {
        d && d(l);
      });
    }
    /**
     * @member AudioConfigImpl.prototype.id
     * @function
     * @public
     */
    id() {
      return this.privSource.id();
    }
    /**
     * @member AudioConfigImpl.prototype.turnOn
     * @function
     * @public
     * @returns {Promise<void>} A promise.
     */
    turnOn() {
      return this.privSource.turnOn();
    }
    /**
     * @member AudioConfigImpl.prototype.attach
     * @function
     * @public
     * @param {string} audioNodeId - The audio node id.
     * @returns {Promise<IAudioStreamNode>} A promise.
     */
    attach(p) {
      return this.privSource.attach(p);
    }
    /**
     * @member AudioConfigImpl.prototype.detach
     * @function
     * @public
     * @param {string} audioNodeId - The audio node id.
     */
    detach(p) {
      return this.privSource.detach(p);
    }
    /**
     * @member AudioConfigImpl.prototype.turnOff
     * @function
     * @public
     * @returns {Promise<void>} A promise.
     */
    turnOff() {
      return this.privSource.turnOff();
    }
    /**
     * @member AudioConfigImpl.prototype.events
     * @function
     * @public
     * @returns {EventSource<AudioSourceEvent>} An event source for audio events.
     */
    get events() {
      return this.privSource.events;
    }
    setProperty(p, d) {
      if (e.Contracts.throwIfNull(d, "value"), this.privSource.setProperty !== void 0)
        this.privSource.setProperty(p, d);
      else
        throw new Error("This AudioConfig instance does not support setting properties.");
    }
    getProperty(p, d) {
      if (this.privSource.getProperty !== void 0)
        return this.privSource.getProperty(p, d);
      throw new Error("This AudioConfig instance does not support getting properties.");
    }
    get deviceInfo() {
      return this.privSource.deviceInfo;
    }
  }
  ft.AudioConfigImpl = i;
  class c extends a {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {IAudioDestination} destination - An audio destination.
     */
    constructor(p) {
      super(), this.privDestination = p;
    }
    set format(p) {
      this.privDestination.format = p;
    }
    write(p) {
      this.privDestination.write(p);
    }
    close() {
      this.privDestination.close();
    }
    id() {
      return this.privDestination.id();
    }
    setProperty() {
      throw new Error("This AudioConfig instance does not support setting properties.");
    }
    getProperty() {
      throw new Error("This AudioConfig instance does not support getting properties.");
    }
  }
  return ft.AudioOutputConfigImpl = c, ft;
}
var Ef = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.CancellationReason = void 0, function(e) {
    e[e.Error = 0] = "Error", e[e.EndOfStream = 1] = "EndOfStream";
  }(t.CancellationReason || (t.CancellationReason = {}));
})(Ef);
var ta = {};
Object.defineProperty(ta, "__esModule", { value: !0 });
ta.PullAudioInputStreamCallback = void 0;
class f0 {
}
ta.PullAudioInputStreamCallback = f0;
var na = {};
Object.defineProperty(na, "__esModule", { value: !0 });
na.PushAudioOutputStreamCallback = void 0;
class g0 {
}
na.PushAudioOutputStreamCallback = g0;
var ra = {};
Object.defineProperty(ra, "__esModule", { value: !0 });
ra.KeywordRecognitionModel = void 0;
const Zp = N;
class m0 {
  /**
   * Create and initializes a new instance.
   * @constructor
   */
  constructor() {
    this.privDisposed = !1;
  }
  /**
   * Creates a keyword recognition model using the specified filename.
   * @member KeywordRecognitionModel.fromFile
   * @function
   * @public
   * @param {string} fileName - A string that represents file name for the keyword recognition model.
   * Note, the file can point to a zip file in which case the model
   * will be extracted from the zip.
   * @returns {KeywordRecognitionModel} The keyword recognition model being created.
   */
  static fromFile(e) {
    throw Zp.Contracts.throwIfFileDoesNotExist(e, "fileName"), new Error("Not yet implemented.");
  }
  /**
   * Creates a keyword recognition model using the specified filename.
   * @member KeywordRecognitionModel.fromStream
   * @function
   * @public
   * @param {string} file - A File that represents file for the keyword recognition model.
   * Note, the file can point to a zip file in which case the model will be extracted from the zip.
   * @returns {KeywordRecognitionModel} The keyword recognition model being created.
   */
  static fromStream(e) {
    throw Zp.Contracts.throwIfNull(e, "file"), new Error("Not yet implemented.");
  }
  /**
   * Dispose of associated resources.
   * @member KeywordRecognitionModel.prototype.close
   * @function
   * @public
   */
  close() {
    this.privDisposed || (this.privDisposed = !0);
  }
}
ra.KeywordRecognitionModel = m0;
var ia = {};
Object.defineProperty(ia, "__esModule", { value: !0 });
ia.SessionEventArgs = void 0;
class S0 {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {string} sessionId - The session id.
   */
  constructor(e) {
    this.privSessionId = e;
  }
  /**
   * Represents the session identifier.
   * @member SessionEventArgs.prototype.sessionId
   * @function
   * @public
   * @returns {string} Represents the session identifier.
   */
  get sessionId() {
    return this.privSessionId;
  }
}
ia.SessionEventArgs = S0;
var _r = {}, Xp;
function y0() {
  if (Xp)
    return _r;
  Xp = 1, Object.defineProperty(_r, "__esModule", { value: !0 }), _r.RecognitionEventArgs = void 0;
  const t = R();
  let e = class extends t.SessionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {number} offset - The offset.
     * @param {string} sessionId - The session id.
     */
    constructor(r, s) {
      super(s), this.privOffset = r;
    }
    /**
     * Represents the message offset
     * @member RecognitionEventArgs.prototype.offset
     * @function
     * @public
     */
    get offset() {
      return this.privOffset;
    }
  };
  return _r.RecognitionEventArgs = e, _r;
}
var Tf = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.OutputFormat = void 0, function(e) {
    e[e.Simple = 0] = "Simple", e[e.Detailed = 1] = "Detailed";
  }(t.OutputFormat || (t.OutputFormat = {}));
})(Tf);
var Rr = {}, ed;
function C0() {
  if (ed)
    return Rr;
  ed = 1, Object.defineProperty(Rr, "__esModule", { value: !0 }), Rr.IntentRecognitionEventArgs = void 0;
  const t = R();
  let e = class extends t.RecognitionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param result - The result of the intent recognition.
     * @param offset - The offset.
     * @param sessionId - The session id.
     */
    constructor(r, s, o) {
      super(s, o), this.privResult = r;
    }
    /**
     * Represents the intent recognition result.
     * @member IntentRecognitionEventArgs.prototype.result
     * @function
     * @public
     * @returns {IntentRecognitionResult} Represents the intent recognition result.
     */
    get result() {
      return this.privResult;
    }
  };
  return Rr.IntentRecognitionEventArgs = e, Rr;
}
var sa = {};
Object.defineProperty(sa, "__esModule", { value: !0 });
sa.RecognitionResult = void 0;
class _0 {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {string} resultId - The result id.
   * @param {ResultReason} reason - The reason.
   * @param {string} text - The recognized text.
   * @param {number} duration - The duration.
   * @param {number} offset - The offset into the stream.
   * @param {string} language - Primary Language detected, if provided.
   * @param {string} languageDetectionConfidence - Primary Language confidence ("Unknown," "Low," "Medium," "High"...), if provided.
   * @param {string} errorDetails - Error details, if provided.
   * @param {string} json - Additional Json, if provided.
   * @param {PropertyCollection} properties - Additional properties, if provided.
   */
  constructor(e, n, r, s, o, a, i, c, u, p) {
    this.privResultId = e, this.privReason = n, this.privText = r, this.privDuration = s, this.privOffset = o, this.privLanguage = a, this.privLanguageDetectionConfidence = i, this.privErrorDetails = c, this.privJson = u, this.privProperties = p;
  }
  /**
   * Specifies the result identifier.
   * @member RecognitionResult.prototype.resultId
   * @function
   * @public
   * @returns {string} Specifies the result identifier.
   */
  get resultId() {
    return this.privResultId;
  }
  /**
   * Specifies status of the result.
   * @member RecognitionResult.prototype.reason
   * @function
   * @public
   * @returns {ResultReason} Specifies status of the result.
   */
  get reason() {
    return this.privReason;
  }
  /**
   * Presents the recognized text in the result.
   * @member RecognitionResult.prototype.text
   * @function
   * @public
   * @returns {string} Presents the recognized text in the result.
   */
  get text() {
    return this.privText;
  }
  /**
   * Duration of recognized speech in 100 nano second increments.
   * @member RecognitionResult.prototype.duration
   * @function
   * @public
   * @returns {number} Duration of recognized speech in 100 nano second increments.
   */
  get duration() {
    return this.privDuration;
  }
  /**
   * Offset of recognized speech in 100 nano second increments.
   * @member RecognitionResult.prototype.offset
   * @function
   * @public
   * @returns {number} Offset of recognized speech in 100 nano second increments.
   */
  get offset() {
    return this.privOffset;
  }
  /**
   * Primary Language detected.
   * @member RecognitionResult.prototype.language
   * @function
   * @public
   * @returns {string} language detected.
   */
  get language() {
    return this.privLanguage;
  }
  /**
   * Primary Language detection confidence (Unknown, Low, Medium, High).
   * @member RecognitionResult.prototype.languageDetectionConfidence
   * @function
   * @public
   * @returns {string} detection confidence strength.
   */
  get languageDetectionConfidence() {
    return this.privLanguageDetectionConfidence;
  }
  /**
   * In case of an unsuccessful recognition, provides details of the occurred error.
   * @member RecognitionResult.prototype.errorDetails
   * @function
   * @public
   * @returns {string} a brief description of an error.
   */
  get errorDetails() {
    return this.privErrorDetails;
  }
  /**
   * A string containing Json serialized recognition result as it was received from the service.
   * @member RecognitionResult.prototype.json
   * @function
   * @private
   * @returns {string} Json serialized representation of the result.
   */
  get json() {
    return this.privJson;
  }
  /**
   * The set of properties exposed in the result.
   * @member RecognitionResult.prototype.properties
   * @function
   * @public
   * @returns {PropertyCollection} The set of properties exposed in the result.
   */
  get properties() {
    return this.privProperties;
  }
}
sa.RecognitionResult = _0;
var Pr = {}, td;
function R0() {
  if (td)
    return Pr;
  td = 1, Object.defineProperty(Pr, "__esModule", { value: !0 }), Pr.SpeechRecognitionResult = void 0;
  const t = R();
  let e = class extends t.RecognitionResult {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @public
     * @param {string} resultId - The result id.
     * @param {ResultReason} reason - The reason.
     * @param {string} text - The recognized text.
     * @param {number} duration - The duration.
     * @param {number} offset - The offset into the stream.
     * @param {string} language - Primary Language detected, if provided.
     * @param {string} languageDetectionConfidence - Primary Language confidence ("Unknown," "Low," "Medium," "High"...), if provided.
     * @param {string} speakerId - speaker id for conversation transcription, if provided.
     * @param {string} errorDetails - Error details, if provided.
     * @param {string} json - Additional Json, if provided.
     * @param {PropertyCollection} properties - Additional properties, if provided.
     */
    constructor(r, s, o, a, i, c, u, p, d, l, h) {
      super(r, s, o, a, i, c, u, d, l, h), this.privSpeakerId = p;
    }
    /**
     * speaker id from conversation transcription/id scenarios
     * @member SpeechRecognitionResult.prototype.speakerId
     * @function
     * @public
     * @returns {string} id of speaker in given result
     */
    get speakerId() {
      return this.privSpeakerId;
    }
  };
  return Pr.SpeechRecognitionResult = e, Pr;
}
var Er = {}, nd;
function P0() {
  if (nd)
    return Er;
  nd = 1, Object.defineProperty(Er, "__esModule", { value: !0 }), Er.IntentRecognitionResult = void 0;
  const t = R();
  let e = class extends t.SpeechRecognitionResult {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param intentId - The intent id.
     * @param resultId - The result id.
     * @param reason - The reason.
     * @param text - The recognized text.
     * @param duration - The duration.
     * @param offset - The offset into the stream.
     * @param language - Primary Language detected, if provided.
     * @param languageDetectionConfidence - Primary Language confidence ("Unknown," "Low," "Medium," "High"...), if provided.
     * @param errorDetails - Error details, if provided.
     * @param json - Additional Json, if provided.
     * @param properties - Additional properties, if provided.
     */
    constructor(r, s, o, a, i, c, u, p, d, l, h) {
      super(s, o, a, i, c, u, p, void 0, d, l, h), this.privIntentId = r;
    }
    /**
     * A String that represents the intent identifier being recognized.
     * @member IntentRecognitionResult.prototype.intentId
     * @function
     * @public
     * @returns {string} A String that represents the intent identifier being recognized.
     */
    get intentId() {
      return this.privIntentId;
    }
  };
  return Er.IntentRecognitionResult = e, Er;
}
var Un = {};
Object.defineProperty(Un, "__esModule", { value: !0 });
Un.LanguageUnderstandingModelImpl = Un.LanguageUnderstandingModel = void 0;
const Ln = N;
class If {
  /**
   * Creates and initializes a new instance
   * @constructor
   */
  constructor() {
  }
  /**
   * Creates an language understanding model using the specified endpoint.
   * @member LanguageUnderstandingModel.fromEndpoint
   * @function
   * @public
   * @param {URL} uri - A String that represents the endpoint of the language understanding model.
   * @returns {LanguageUnderstandingModel} The language understanding model being created.
   */
  static fromEndpoint(e) {
    Ln.Contracts.throwIfNull(e, "uri"), Ln.Contracts.throwIfNullOrWhitespace(e.hostname, "uri");
    const n = new ro(), r = e.host.indexOf(".");
    if (r === -1)
      throw new Error("Could not determine region from endpoint");
    n.region = e.host.substr(0, r);
    const s = e.pathname.lastIndexOf("/") + 1;
    if (s === -1)
      throw new Error("Could not determine appId from endpoint");
    if (n.appId = e.pathname.substr(s), n.subscriptionKey = e.searchParams.get("subscription-key"), n.subscriptionKey === void 0)
      throw new Error("Could not determine subscription key from endpoint");
    return n;
  }
  /**
   * Creates an language understanding model using the application id of Language Understanding service.
   * @member LanguageUnderstandingModel.fromAppId
   * @function
   * @public
   * @param {string} appId - A String that represents the application id of Language Understanding service.
   * @returns {LanguageUnderstandingModel} The language understanding model being created.
   */
  static fromAppId(e) {
    Ln.Contracts.throwIfNullOrWhitespace(e, "appId");
    const n = new ro();
    return n.appId = e, n;
  }
  /**
   * Creates a language understanding model using hostname, subscription key and application
   * id of Language Understanding service.
   * @member LanguageUnderstandingModel.fromSubscription
   * @function
   * @public
   * @param {string} subscriptionKey - A String that represents the subscription key of
   * Language Understanding service.
   * @param {string} appId - A String that represents the application id of Language
   * Understanding service.
   * @param {LanguageUnderstandingModel} region - A String that represents the region
   * of the Language Understanding service (see the <a href="https://aka.ms/csspeech/region">region page</a>).
   * @returns {LanguageUnderstandingModel} The language understanding model being created.
   */
  static fromSubscription(e, n, r) {
    Ln.Contracts.throwIfNullOrWhitespace(e, "subscriptionKey"), Ln.Contracts.throwIfNullOrWhitespace(n, "appId"), Ln.Contracts.throwIfNullOrWhitespace(r, "region");
    const s = new ro();
    return s.appId = n, s.region = r, s.subscriptionKey = e, s;
  }
}
Un.LanguageUnderstandingModel = If;
class ro extends If {
}
Un.LanguageUnderstandingModelImpl = ro;
var gt = {}, rd;
function E0() {
  if (rd)
    return gt;
  rd = 1, Object.defineProperty(gt, "__esModule", { value: !0 }), gt.MeetingTranscriptionEventArgs = gt.ConversationTranscriptionEventArgs = gt.SpeechRecognitionEventArgs = void 0;
  const t = R();
  let e = class extends t.RecognitionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {SpeechRecognitionResult} result - The speech recognition result.
     * @param {number} offset - The offset.
     * @param {string} sessionId - The session id.
     */
    constructor(o, a, i) {
      super(a, i), this.privResult = o;
    }
    /**
     * Specifies the recognition result.
     * @member SpeechRecognitionEventArgs.prototype.result
     * @function
     * @public
     * @returns {SpeechRecognitionResult} the recognition result.
     */
    get result() {
      return this.privResult;
    }
  };
  gt.SpeechRecognitionEventArgs = e;
  class n extends t.RecognitionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {ConversationTranscriptionResult} result - The conversation transcription result.
     * @param {number} offset - The offset.
     * @param {string} sessionId - The session id.
     */
    constructor(o, a, i) {
      super(a, i), this.privResult = o;
    }
    /**
     * Specifies the transcription result.
     * @member ConversationTranscription1EventArgs.prototype.result
     * @function
     * @public
     * @returns {ConversationTranscriptionResult} the recognition result.
     */
    get result() {
      return this.privResult;
    }
  }
  gt.ConversationTranscriptionEventArgs = n;
  class r extends e {
  }
  return gt.MeetingTranscriptionEventArgs = r, gt;
}
var Tr = {}, Ir = {}, id;
function Cs() {
  if (id)
    return Ir;
  id = 1, Object.defineProperty(Ir, "__esModule", { value: !0 }), Ir.CancellationEventArgsBase = void 0;
  const t = R();
  let e = class extends t.RecognitionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {CancellationReason} reason - The cancellation reason.
     * @param {string} errorDetails - Error details, if provided.
     * @param {number} offset - The offset.
     * @param {string} sessionId - The session id.
     */
    constructor(r, s, o, a, i) {
      super(a, i), this.privReason = r, this.privErrorDetails = s, this.privErrorCode = o;
    }
    /**
     * The reason the recognition was canceled.
     * @member CancellationEventArgsBase.prototype.reason
     * @function
     * @public
     * @returns {CancellationReason} Specifies the reason canceled.
     */
    get reason() {
      return this.privReason;
    }
    /**
     * The error code in case of an unsuccessful operation.
     * @return An error code that represents the error reason.
     */
    get errorCode() {
      return this.privErrorCode;
    }
    /**
     * In case of an unsuccessful operation, provides details of the occurred error.
     * @member CancellationEventArgsBase.prototype.errorDetails
     * @function
     * @public
     * @returns {string} A String that represents the error details.
     */
    get errorDetails() {
      return this.privErrorDetails;
    }
  };
  return Ir.CancellationEventArgsBase = e, Ir;
}
var sd;
function T0() {
  if (sd)
    return Tr;
  sd = 1, Object.defineProperty(Tr, "__esModule", { value: !0 }), Tr.SpeechRecognitionCanceledEventArgs = void 0;
  const t = Cs();
  let e = class extends t.CancellationEventArgsBase {
  };
  return Tr.SpeechRecognitionCanceledEventArgs = e, Tr;
}
var wr = {}, od;
function I0() {
  if (od)
    return wr;
  od = 1, Object.defineProperty(wr, "__esModule", { value: !0 }), wr.TranslationRecognitionEventArgs = void 0;
  const t = R();
  let e = class extends t.RecognitionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {TranslationRecognitionResult} result - The translation recognition result.
     * @param {number} offset - The offset.
     * @param {string} sessionId - The session id.
     */
    constructor(r, s, o) {
      super(s, o), this.privResult = r;
    }
    /**
     * Specifies the recognition result.
     * @member TranslationRecognitionEventArgs.prototype.result
     * @function
     * @public
     * @returns {TranslationRecognitionResult} the recognition result.
     */
    get result() {
      return this.privResult;
    }
  };
  return wr.TranslationRecognitionEventArgs = e, wr;
}
var br = {}, ad;
function w0() {
  if (ad)
    return br;
  ad = 1, Object.defineProperty(br, "__esModule", { value: !0 }), br.TranslationSynthesisEventArgs = void 0;
  const t = R();
  let e = class extends t.SessionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {TranslationSynthesisResult} result - The translation synthesis result.
     * @param {string} sessionId - The session id.
     */
    constructor(r, s) {
      super(s), this.privResult = r;
    }
    /**
     * Specifies the translation synthesis result.
     * @member TranslationSynthesisEventArgs.prototype.result
     * @function
     * @public
     * @returns {TranslationSynthesisResult} Specifies the translation synthesis result.
     */
    get result() {
      return this.privResult;
    }
  };
  return br.TranslationSynthesisEventArgs = e, br;
}
var Ar = {}, cd;
function bf() {
  if (cd)
    return Ar;
  cd = 1, Object.defineProperty(Ar, "__esModule", { value: !0 }), Ar.TranslationRecognitionResult = void 0;
  const t = R();
  let e = class wf extends t.SpeechRecognitionResult {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {Translations} translations - The translations.
     * @param {string} resultId - The result id.
     * @param {ResultReason} reason - The reason.
     * @param {string} text - The recognized text.
     * @param {number} duration - The duration.
     * @param {number} offset - The offset into the stream.
     * @param {string} language - Primary Language detected, if provided.
     * @param {string} languageDetectionConfidence - Primary Language confidence ("Unknown," "Low," "Medium," "High"...), if provided.
     * @param {string} errorDetails - Error details, if provided.
     * @param {string} json - Additional Json, if provided.
     * @param {PropertyCollection} properties - Additional properties, if provided.
     */
    constructor(r, s, o, a, i, c, u, p, d, l, h) {
      super(s, o, a, i, c, u, p, void 0, d, l, h), this.privTranslations = r;
    }
    static fromSpeechRecognitionResult(r) {
      return new wf(void 0, r.resultId, r.reason, r.text, r.duration, r.offset, r.language, r.languageDetectionConfidence, r.errorDetails, r.json, r.properties);
    }
    /**
     * Presents the translation results. Each item in the dictionary represents
     * a translation result in one of target languages, where the key is the name
     * of the target language, in BCP-47 format, and the value is the translation
     * text in the specified language.
     * @member TranslationRecognitionResult.prototype.translations
     * @function
     * @public
     * @returns {Translations} the current translation map that holds all translations requested.
     */
    get translations() {
      return this.privTranslations;
    }
  };
  return Ar.TranslationRecognitionResult = e, Ar;
}
var oa = {};
Object.defineProperty(oa, "__esModule", { value: !0 });
oa.TranslationSynthesisResult = void 0;
class b0 {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {ResultReason} reason - The synthesis reason.
   * @param {ArrayBuffer} audio - The audio data.
   */
  constructor(e, n) {
    this.privReason = e, this.privAudio = n;
  }
  /**
   * Translated text in the target language.
   * @member TranslationSynthesisResult.prototype.audio
   * @function
   * @public
   * @returns {ArrayBuffer} Translated audio in the target language.
   */
  get audio() {
    return this.privAudio;
  }
  /**
   * The synthesis status.
   * @member TranslationSynthesisResult.prototype.reason
   * @function
   * @public
   * @returns {ResultReason} The synthesis status.
   */
  get reason() {
    return this.privReason;
  }
}
oa.TranslationSynthesisResult = b0;
var Af = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.ResultReason = void 0, function(e) {
    e[e.NoMatch = 0] = "NoMatch", e[e.Canceled = 1] = "Canceled", e[e.RecognizingSpeech = 2] = "RecognizingSpeech", e[e.RecognizedSpeech = 3] = "RecognizedSpeech", e[e.RecognizedKeyword = 4] = "RecognizedKeyword", e[e.RecognizingIntent = 5] = "RecognizingIntent", e[e.RecognizedIntent = 6] = "RecognizedIntent", e[e.TranslatingSpeech = 7] = "TranslatingSpeech", e[e.TranslatedSpeech = 8] = "TranslatedSpeech", e[e.SynthesizingAudio = 9] = "SynthesizingAudio", e[e.SynthesizingAudioCompleted = 10] = "SynthesizingAudioCompleted", e[e.SynthesizingAudioStarted = 11] = "SynthesizingAudioStarted", e[e.EnrollingVoiceProfile = 12] = "EnrollingVoiceProfile", e[e.EnrolledVoiceProfile = 13] = "EnrolledVoiceProfile", e[e.RecognizedSpeakers = 14] = "RecognizedSpeakers", e[e.RecognizedSpeaker = 15] = "RecognizedSpeaker", e[e.ResetVoiceProfile = 16] = "ResetVoiceProfile", e[e.DeletedVoiceProfile = 17] = "DeletedVoiceProfile", e[e.VoicesListRetrieved = 18] = "VoicesListRetrieved", e[e.TranslatingParticipantSpeech = 19] = "TranslatingParticipantSpeech", e[e.TranslatedParticipantSpeech = 20] = "TranslatedParticipantSpeech", e[e.TranslatedInstantMessage = 21] = "TranslatedInstantMessage", e[e.TranslatedParticipantInstantMessage = 22] = "TranslatedParticipantInstantMessage";
  }(t.ResultReason || (t.ResultReason = {}));
})(Af);
var Kt = {}, ud;
function A0() {
  if (ud)
    return Kt;
  ud = 1, Object.defineProperty(Kt, "__esModule", { value: !0 }), Kt.SpeechConfigImpl = Kt.SpeechConfig = void 0;
  const t = A(), e = N, n = R();
  let r = class {
    /**
     * Creates and initializes an instance.
     * @constructor
     */
    constructor() {
    }
    /**
     * Static instance of SpeechConfig returned by passing subscriptionKey and service region.
     * Note: Please use your LanguageUnderstanding subscription key in case you want to use the Intent recognizer.
     * @member SpeechConfig.fromSubscription
     * @function
     * @public
     * @param {string} subscriptionKey - The subscription key.
     * @param {string} region - The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {SpeechConfig} The speech factory
     */
    static fromSubscription(a, i) {
      e.Contracts.throwIfNullOrWhitespace(a, "subscriptionKey"), e.Contracts.throwIfNullOrWhitespace(i, "region");
      const c = new s();
      return c.setProperty(n.PropertyId.SpeechServiceConnection_Region, i), c.setProperty(n.PropertyId.SpeechServiceConnection_IntentRegion, i), c.setProperty(n.PropertyId.SpeechServiceConnection_Key, a), c;
    }
    /**
     * Creates an instance of the speech config with specified endpoint and subscription key.
     * This method is intended only for users who use a non-standard service endpoint or parameters.
     * Note: Please use your LanguageUnderstanding subscription key in case you want to use the Intent recognizer.
     * Note: The query parameters specified in the endpoint URL are not changed, even if they are set by any other APIs.
     * For example, if language is defined in the uri as query parameter "language=de-DE", and also set by
     * SpeechConfig.speechRecognitionLanguage = "en-US", the language setting in uri takes precedence,
     * and the effective language is "de-DE". Only the parameters that are not specified in the
     * endpoint URL can be set by other APIs.
     * Note: To use authorization token with fromEndpoint, pass an empty string to the subscriptionKey in the
     * fromEndpoint method, and then set authorizationToken="token" on the created SpeechConfig instance to
     * use the authorization token.
     * @member SpeechConfig.fromEndpoint
     * @function
     * @public
     * @param {URL} endpoint - The service endpoint to connect to.
     * @param {string} subscriptionKey - The subscription key. If a subscription key is not specified, an authorization token must be set.
     * @returns {SpeechConfig} A speech factory instance.
     */
    static fromEndpoint(a, i) {
      e.Contracts.throwIfNull(a, "endpoint");
      const c = new s();
      return c.setProperty(n.PropertyId.SpeechServiceConnection_Endpoint, a.href), i !== void 0 && c.setProperty(n.PropertyId.SpeechServiceConnection_Key, i), c;
    }
    /**
     * Creates an instance of the speech config with specified host and subscription key.
     * This method is intended only for users who use a non-default service host. Standard resource path will be assumed.
     * For services with a non-standard resource path or no path at all, use fromEndpoint instead.
     * Note: Query parameters are not allowed in the host URI and must be set by other APIs.
     * Note: To use an authorization token with fromHost, use fromHost(URL),
     * and then set the AuthorizationToken property on the created SpeechConfig instance.
     * Note: Added in version 1.9.0.
     * @member SpeechConfig.fromHost
     * @function
     * @public
     * @param {URL} host - The service endpoint to connect to. Format is "protocol://host:port" where ":port" is optional.
     * @param {string} subscriptionKey - The subscription key. If a subscription key is not specified, an authorization token must be set.
     * @returns {SpeechConfig} A speech factory instance.
     */
    static fromHost(a, i) {
      e.Contracts.throwIfNull(a, "hostName");
      const c = new s();
      return c.setProperty(n.PropertyId.SpeechServiceConnection_Host, a.protocol + "//" + a.hostname + (a.port === "" ? "" : ":" + a.port)), i !== void 0 && c.setProperty(n.PropertyId.SpeechServiceConnection_Key, i), c;
    }
    /**
     * Creates an instance of the speech factory with specified initial authorization token and region.
     * Note: The caller needs to ensure that the authorization token is valid. Before the authorization token
     * expires, the caller needs to refresh it by calling this setter with a new valid token.
     * Note: Please use a token derived from your LanguageUnderstanding subscription key in case you want
     * to use the Intent recognizer. As configuration values are copied when creating a new recognizer,
     * the new token value will not apply to recognizers that have already been created. For recognizers
     * that have been created before, you need to set authorization token of the corresponding recognizer
     * to refresh the token. Otherwise, the recognizers will encounter errors during recognition.
     * @member SpeechConfig.fromAuthorizationToken
     * @function
     * @public
     * @param {string} authorizationToken - The initial authorization token.
     * @param {string} region - The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {SpeechConfig} A speech factory instance.
     */
    static fromAuthorizationToken(a, i) {
      e.Contracts.throwIfNull(a, "authorizationToken"), e.Contracts.throwIfNullOrWhitespace(i, "region");
      const c = new s();
      return c.setProperty(n.PropertyId.SpeechServiceConnection_Region, i), c.setProperty(n.PropertyId.SpeechServiceConnection_IntentRegion, i), c.authorizationToken = a, c;
    }
    /**
     * Closes the configuration.
     * @member SpeechConfig.prototype.close
     * @function
     * @public
     */
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    close() {
    }
  };
  Kt.SpeechConfig = r;
  class s extends r {
    constructor() {
      super(), this.privProperties = new n.PropertyCollection(), this.speechRecognitionLanguage = "en-US", this.outputFormat = n.OutputFormat.Simple;
    }
    get properties() {
      return this.privProperties;
    }
    get endPoint() {
      return new URL(this.privProperties.getProperty(n.PropertyId.SpeechServiceConnection_Endpoint));
    }
    get subscriptionKey() {
      return this.privProperties.getProperty(n.PropertyId.SpeechServiceConnection_Key);
    }
    get region() {
      return this.privProperties.getProperty(n.PropertyId.SpeechServiceConnection_Region);
    }
    get authorizationToken() {
      return this.privProperties.getProperty(n.PropertyId.SpeechServiceAuthorization_Token);
    }
    set authorizationToken(a) {
      this.privProperties.setProperty(n.PropertyId.SpeechServiceAuthorization_Token, a);
    }
    get speechRecognitionLanguage() {
      return this.privProperties.getProperty(n.PropertyId.SpeechServiceConnection_RecoLanguage);
    }
    set speechRecognitionLanguage(a) {
      this.privProperties.setProperty(n.PropertyId.SpeechServiceConnection_RecoLanguage, a);
    }
    get autoDetectSourceLanguages() {
      return this.privProperties.getProperty(n.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages);
    }
    set autoDetectSourceLanguages(a) {
      this.privProperties.setProperty(n.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, a);
    }
    get outputFormat() {
      return n.OutputFormat[this.privProperties.getProperty(t.OutputFormatPropertyName, void 0)];
    }
    set outputFormat(a) {
      this.privProperties.setProperty(t.OutputFormatPropertyName, n.OutputFormat[a]);
    }
    get endpointId() {
      return this.privProperties.getProperty(n.PropertyId.SpeechServiceConnection_EndpointId);
    }
    set endpointId(a) {
      this.privProperties.setProperty(n.PropertyId.SpeechServiceConnection_EndpointId, a);
    }
    setProperty(a, i) {
      e.Contracts.throwIfNull(i, "value"), this.privProperties.setProperty(a, i);
    }
    getProperty(a, i) {
      return this.privProperties.getProperty(a, i);
    }
    setProxy(a, i, c, u) {
      this.setProperty(n.PropertyId[n.PropertyId.SpeechServiceConnection_ProxyHostName], a), this.setProperty(n.PropertyId[n.PropertyId.SpeechServiceConnection_ProxyPort], i), this.setProperty(n.PropertyId[n.PropertyId.SpeechServiceConnection_ProxyUserName], c), this.setProperty(n.PropertyId[n.PropertyId.SpeechServiceConnection_ProxyPassword], u);
    }
    setServiceProperty(a, i) {
      const c = JSON.parse(this.privProperties.getProperty(t.ServicePropertiesPropertyName, "{}"));
      c[a] = i, this.privProperties.setProperty(t.ServicePropertiesPropertyName, JSON.stringify(c));
    }
    setProfanity(a) {
      this.privProperties.setProperty(n.PropertyId.SpeechServiceResponse_ProfanityOption, n.ProfanityOption[a]);
    }
    enableAudioLogging() {
      this.privProperties.setProperty(n.PropertyId.SpeechServiceConnection_EnableAudioLogging, "true");
    }
    requestWordLevelTimestamps() {
      this.privProperties.setProperty(n.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, "true"), this.privProperties.setProperty(t.OutputFormatPropertyName, n.OutputFormat[n.OutputFormat.Detailed]);
    }
    enableDictation() {
      this.privProperties.setProperty(t.ForceDictationPropertyName, "true");
    }
    clone() {
      const a = new s();
      return a.privProperties = this.privProperties.clone(), a;
    }
    get speechSynthesisLanguage() {
      return this.privProperties.getProperty(n.PropertyId.SpeechServiceConnection_SynthLanguage);
    }
    set speechSynthesisLanguage(a) {
      this.privProperties.setProperty(n.PropertyId.SpeechServiceConnection_SynthLanguage, a);
    }
    get speechSynthesisVoiceName() {
      return this.privProperties.getProperty(n.PropertyId.SpeechServiceConnection_SynthVoice);
    }
    set speechSynthesisVoiceName(a) {
      this.privProperties.setProperty(n.PropertyId.SpeechServiceConnection_SynthVoice, a);
    }
    get speechSynthesisOutputFormat() {
      return n.SpeechSynthesisOutputFormat[this.privProperties.getProperty(n.PropertyId.SpeechServiceConnection_SynthOutputFormat, void 0)];
    }
    set speechSynthesisOutputFormat(a) {
      this.privProperties.setProperty(n.PropertyId.SpeechServiceConnection_SynthOutputFormat, n.SpeechSynthesisOutputFormat[a]);
    }
  }
  return Kt.SpeechConfigImpl = s, Kt;
}
var Jt = {}, pd;
function M0() {
  if (pd)
    return Jt;
  pd = 1, Object.defineProperty(Jt, "__esModule", { value: !0 }), Jt.SpeechTranslationConfigImpl = Jt.SpeechTranslationConfig = void 0;
  const t = A(), e = N, n = R();
  let r = class extends n.SpeechConfig {
    /**
     * Creates an instance of recognizer config.
     */
    constructor() {
      super();
    }
    /**
     * Static instance of SpeechTranslationConfig returned by passing a subscription key and service region.
     * @member SpeechTranslationConfig.fromSubscription
     * @function
     * @public
     * @param {string} subscriptionKey - The subscription key.
     * @param {string} region - The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {SpeechTranslationConfig} The speech translation config.
     */
    static fromSubscription(a, i) {
      e.Contracts.throwIfNullOrWhitespace(a, "subscriptionKey"), e.Contracts.throwIfNullOrWhitespace(i, "region");
      const c = new s();
      return c.properties.setProperty(n.PropertyId.SpeechServiceConnection_Key, a), c.properties.setProperty(n.PropertyId.SpeechServiceConnection_Region, i), c;
    }
    /**
     * Static instance of SpeechTranslationConfig returned by passing authorization token and service region.
     * Note: The caller needs to ensure that the authorization token is valid. Before the authorization token
     * expires, the caller needs to refresh it by setting the property authorizationToken with a new
     * valid token. Otherwise, all the recognizers created by this SpeechTranslationConfig instance
     * will encounter errors during recognition.
     * As configuration values are copied when creating a new recognizer, the new token value will not apply
     * to recognizers that have already been created.
     * For recognizers that have been created before, you need to set authorization token of the corresponding recognizer
     * to refresh the token. Otherwise, the recognizers will encounter errors during recognition.
     * @member SpeechTranslationConfig.fromAuthorizationToken
     * @function
     * @public
     * @param {string} authorizationToken - The authorization token.
     * @param {string} region - The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {SpeechTranslationConfig} The speech translation config.
     */
    static fromAuthorizationToken(a, i) {
      e.Contracts.throwIfNullOrWhitespace(a, "authorizationToken"), e.Contracts.throwIfNullOrWhitespace(i, "region");
      const c = new s();
      return c.properties.setProperty(n.PropertyId.SpeechServiceAuthorization_Token, a), c.properties.setProperty(n.PropertyId.SpeechServiceConnection_Region, i), c;
    }
    /**
     * Creates an instance of the speech config with specified host and subscription key.
     * This method is intended only for users who use a non-default service host. Standard resource path will be assumed.
     * For services with a non-standard resource path or no path at all, use fromEndpoint instead.
     * Note: Query parameters are not allowed in the host URI and must be set by other APIs.
     * Note: To use an authorization token with fromHost, use fromHost(URL),
     * and then set the AuthorizationToken property on the created SpeechConfig instance.
     * Note: Added in version 1.9.0.
     * @member SpeechConfig.fromHost
     * @function
     * @public
     * @param {URL} host - The service endpoint to connect to. Format is "protocol://host:port" where ":port" is optional.
     * @param {string} subscriptionKey - The subscription key. If a subscription key is not specified, an authorization token must be set.
     * @returns {SpeechConfig} A speech factory instance.
     */
    static fromHost(a, i) {
      e.Contracts.throwIfNull(a, "hostName");
      const c = new s();
      return c.setProperty(n.PropertyId.SpeechServiceConnection_Host, a.protocol + "//" + a.hostname + (a.port === "" ? "" : ":" + a.port)), i !== void 0 && c.setProperty(n.PropertyId.SpeechServiceConnection_Key, i), c;
    }
    /**
     * Creates an instance of the speech translation config with specified endpoint and subscription key.
     * This method is intended only for users who use a non-standard service endpoint or paramters.
     * Note: The query properties specified in the endpoint URL are not changed, even if they are
     * set by any other APIs. For example, if language is defined in the uri as query parameter
     * "language=de-DE", and also set by the speechRecognitionLanguage property, the language
     * setting in uri takes precedence, and the effective language is "de-DE".
     * Only the properties that are not specified in the endpoint URL can be set by other APIs.
     * Note: To use authorization token with fromEndpoint, pass an empty string to the subscriptionKey in the
     * fromEndpoint method, and then set authorizationToken="token" on the created SpeechConfig instance to
     * use the authorization token.
     * @member SpeechTranslationConfig.fromEndpoint
     * @function
     * @public
     * @param {URL} endpoint - The service endpoint to connect to.
     * @param {string} subscriptionKey - The subscription key.
     * @returns {SpeechTranslationConfig} A speech config instance.
     */
    static fromEndpoint(a, i) {
      e.Contracts.throwIfNull(a, "endpoint"), e.Contracts.throwIfNull(i, "subscriptionKey");
      const c = new s();
      return c.properties.setProperty(n.PropertyId.SpeechServiceConnection_Endpoint, a.href), c.properties.setProperty(n.PropertyId.SpeechServiceConnection_Key, i), c;
    }
  };
  Jt.SpeechTranslationConfig = r;
  class s extends r {
    constructor() {
      super(), this.privSpeechProperties = new n.PropertyCollection(), this.outputFormat = n.OutputFormat.Simple;
    }
    /**
     * Gets/Sets the authorization token.
     * If this is set, subscription key is ignored.
     * User needs to make sure the provided authorization token is valid and not expired.
     * @member SpeechTranslationConfigImpl.prototype.authorizationToken
     * @function
     * @public
     * @param {string} value - The authorization token.
     */
    set authorizationToken(a) {
      e.Contracts.throwIfNullOrWhitespace(a, "value"), this.privSpeechProperties.setProperty(n.PropertyId.SpeechServiceAuthorization_Token, a);
    }
    /**
     * Sets the speech recognition language.
     * @member SpeechTranslationConfigImpl.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @param {string} value - The authorization token.
     */
    set speechRecognitionLanguage(a) {
      e.Contracts.throwIfNullOrWhitespace(a, "value"), this.privSpeechProperties.setProperty(n.PropertyId.SpeechServiceConnection_RecoLanguage, a);
    }
    /**
     * Gets the speech recognition language.
     * @member SpeechTranslationConfigImpl.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @return {string} The speechRecognitionLanguage.
     */
    get speechRecognitionLanguage() {
      return this.privSpeechProperties.getProperty(n.PropertyId[n.PropertyId.SpeechServiceConnection_RecoLanguage]);
    }
    /**
     * @member SpeechTranslationConfigImpl.prototype.subscriptionKey
     * @function
     * @public
     */
    get subscriptionKey() {
      return this.privSpeechProperties.getProperty(n.PropertyId[n.PropertyId.SpeechServiceConnection_Key]);
    }
    /**
     * Gets the output format
     * @member SpeechTranslationConfigImpl.prototype.outputFormat
     * @function
     * @public
     */
    get outputFormat() {
      return n.OutputFormat[this.privSpeechProperties.getProperty(t.OutputFormatPropertyName, void 0)];
    }
    /**
     * Gets/Sets the output format
     * @member SpeechTranslationConfigImpl.prototype.outputFormat
     * @function
     * @public
     */
    set outputFormat(a) {
      this.privSpeechProperties.setProperty(t.OutputFormatPropertyName, n.OutputFormat[a]);
    }
    /**
     * Gets the endpoint id.
     * @member SpeechTranslationConfigImpl.prototype.endpointId
     * @function
     * @public
     */
    get endpointId() {
      return this.privSpeechProperties.getProperty(n.PropertyId.SpeechServiceConnection_EndpointId);
    }
    /**
     * Gets/Sets the endpoint id.
     * @member SpeechTranslationConfigImpl.prototype.endpointId
     * @function
     * @public
     */
    set endpointId(a) {
      this.privSpeechProperties.setProperty(n.PropertyId.SpeechServiceConnection_EndpointId, a);
    }
    /**
     * Add a (text) target language to translate into.
     * @member SpeechTranslationConfigImpl.prototype.addTargetLanguage
     * @function
     * @public
     * @param {string} value - The language such as de-DE
     */
    addTargetLanguage(a) {
      e.Contracts.throwIfNullOrWhitespace(a, "value");
      const i = this.targetLanguages;
      i.includes(a) || (i.push(a), this.privSpeechProperties.setProperty(n.PropertyId.SpeechServiceConnection_TranslationToLanguages, i.join(",")));
    }
    /**
     * Gets the (text) target language to translate into.
     * @member SpeechTranslationConfigImpl.prototype.targetLanguages
     * @function
     * @public
     * @param {string} value - The language such as de-DE
     */
    get targetLanguages() {
      return this.privSpeechProperties.getProperty(n.PropertyId.SpeechServiceConnection_TranslationToLanguages, void 0) !== void 0 ? this.privSpeechProperties.getProperty(n.PropertyId.SpeechServiceConnection_TranslationToLanguages).split(",") : [];
    }
    /**
     * Gets the voice name.
     * @member SpeechTranslationConfigImpl.prototype.voiceName
     * @function
     * @public
     */
    get voiceName() {
      return this.getProperty(n.PropertyId[n.PropertyId.SpeechServiceConnection_TranslationVoice]);
    }
    /**
     * Gets/Sets the voice of the translated language, enable voice synthesis output.
     * @member SpeechTranslationConfigImpl.prototype.voiceName
     * @function
     * @public
     * @param {string} value - The name of the voice.
     */
    set voiceName(a) {
      e.Contracts.throwIfNullOrWhitespace(a, "value"), this.privSpeechProperties.setProperty(n.PropertyId.SpeechServiceConnection_TranslationVoice, a);
    }
    /**
     * Provides the region.
     * @member SpeechTranslationConfigImpl.prototype.region
     * @function
     * @public
     * @returns {string} The region.
     */
    get region() {
      return this.privSpeechProperties.getProperty(n.PropertyId.SpeechServiceConnection_Region);
    }
    setProxy(a, i, c, u) {
      this.setProperty(n.PropertyId[n.PropertyId.SpeechServiceConnection_ProxyHostName], a), this.setProperty(n.PropertyId[n.PropertyId.SpeechServiceConnection_ProxyPort], i), this.setProperty(n.PropertyId[n.PropertyId.SpeechServiceConnection_ProxyUserName], c), this.setProperty(n.PropertyId[n.PropertyId.SpeechServiceConnection_ProxyPassword], u);
    }
    /**
     * Gets an arbitrary property value.
     * @member SpeechTranslationConfigImpl.prototype.getProperty
     * @function
     * @public
     * @param {string} name - The name of the property.
     * @param {string} def - The default value of the property in case it is not set.
     * @returns {string} The value of the property.
     */
    getProperty(a, i) {
      return this.privSpeechProperties.getProperty(a, i);
    }
    /**
     * Gets/Sets an arbitrary property value.
     * @member SpeechTranslationConfigImpl.prototype.setProperty
     * @function
     * @public
     * @param {string | PropertyId} name - The name of the property to set.
     * @param {string} value - The value of the property.
     */
    setProperty(a, i) {
      this.privSpeechProperties.setProperty(a, i);
    }
    /**
     * Provides access to custom properties.
     * @member SpeechTranslationConfigImpl.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The properties.
     */
    get properties() {
      return this.privSpeechProperties;
    }
    /**
     * Dispose of associated resources.
     * @member SpeechTranslationConfigImpl.prototype.close
     * @function
     * @public
     */
    close() {
    }
    setServiceProperty(a, i) {
      const c = JSON.parse(this.privSpeechProperties.getProperty(t.ServicePropertiesPropertyName, "{}"));
      c[a] = i, this.privSpeechProperties.setProperty(t.ServicePropertiesPropertyName, JSON.stringify(c));
    }
    setProfanity(a) {
      this.privSpeechProperties.setProperty(n.PropertyId.SpeechServiceResponse_ProfanityOption, n.ProfanityOption[a]);
    }
    enableAudioLogging() {
      this.privSpeechProperties.setProperty(n.PropertyId.SpeechServiceConnection_EnableAudioLogging, "true");
    }
    requestWordLevelTimestamps() {
      this.privSpeechProperties.setProperty(n.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, "true");
    }
    enableDictation() {
      this.privSpeechProperties.setProperty(t.ForceDictationPropertyName, "true");
    }
    get speechSynthesisLanguage() {
      return this.privSpeechProperties.getProperty(n.PropertyId.SpeechServiceConnection_SynthLanguage);
    }
    set speechSynthesisLanguage(a) {
      this.privSpeechProperties.setProperty(n.PropertyId.SpeechServiceConnection_SynthLanguage, a);
    }
    get speechSynthesisVoiceName() {
      return this.privSpeechProperties.getProperty(n.PropertyId.SpeechServiceConnection_SynthVoice);
    }
    set speechSynthesisVoiceName(a) {
      this.privSpeechProperties.setProperty(n.PropertyId.SpeechServiceConnection_SynthVoice, a);
    }
    get speechSynthesisOutputFormat() {
      return n.SpeechSynthesisOutputFormat[this.privSpeechProperties.getProperty(n.PropertyId.SpeechServiceConnection_SynthOutputFormat, void 0)];
    }
    set speechSynthesisOutputFormat(a) {
      this.privSpeechProperties.setProperty(n.PropertyId.SpeechServiceConnection_SynthOutputFormat, n.SpeechSynthesisOutputFormat[a]);
    }
  }
  return Jt.SpeechTranslationConfigImpl = s, Jt;
}
var Mr = {}, dd;
function kf() {
  if (dd)
    return Mr;
  dd = 1, Object.defineProperty(Mr, "__esModule", { value: !0 }), Mr.PropertyCollection = void 0;
  const t = R();
  let e = class Mf {
    constructor() {
      this.privKeys = [], this.privValues = [];
    }
    /**
     * Returns the property value in type String.
     * Currently only String, int and bool are allowed.
     * If the name is not available, the specified defaultValue is returned.
     * @member PropertyCollection.prototype.getProperty
     * @function
     * @public
     * @param {string} key - The parameter name.
     * @param {string | number | boolean} def - The default value which is returned if the parameter
     * is not available in the collection.
     * @returns {string} value of the parameter.
     */
    getProperty(r, s) {
      let o;
      typeof r == "string" ? o = r : o = t.PropertyId[r];
      for (let a = 0; a < this.privKeys.length; a++)
        if (this.privKeys[a] === o)
          return this.privValues[a];
      if (s !== void 0)
        return String(s);
    }
    /**
     * Sets the String value of the parameter specified by name.
     * @member PropertyCollection.prototype.setProperty
     * @function
     * @public
     * @param {string} key - The parameter name.
     * @param {string} value - The value of the parameter.
     */
    setProperty(r, s) {
      let o;
      typeof r == "string" ? o = r : o = t.PropertyId[r];
      for (let a = 0; a < this.privKeys.length; a++)
        if (this.privKeys[a] === o) {
          this.privValues[a] = s;
          return;
        }
      this.privKeys.push(o), this.privValues.push(s);
    }
    /**
     * Clones the collection.
     * @member PropertyCollection.prototype.clone
     * @function
     * @public
     * @returns {PropertyCollection} A copy of the collection.
     */
    clone() {
      const r = new Mf();
      for (let s = 0; s < this.privKeys.length; s++)
        r.privKeys.push(this.privKeys[s]), r.privValues.push(this.privValues[s]);
      return r;
    }
    /**
     * Merges this set of properties into another, no overwrites.
     * @member PropertyCollection.prototype.mergeTo
     * @function
     * @public
     * @param {PropertyCollection}  destinationCollection - The collection to merge into.
     */
    mergeTo(r) {
      this.privKeys.forEach((s) => {
        if (r.getProperty(s, void 0) === void 0) {
          const o = this.getProperty(s);
          r.setProperty(s, o);
        }
      });
    }
    /**
     * Get the keys in Property Collection.
     * @member PropertyCollection.prototype.keys
     * @function
     * @public
     * @returns {string []} Keys in the collection.
     */
    get keys() {
      return this.privKeys;
    }
  };
  return Mr.PropertyCollection = e, Mr;
}
var aa = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.PropertyId = void 0, function(e) {
    e[e.SpeechServiceConnection_Key = 0] = "SpeechServiceConnection_Key", e[e.SpeechServiceConnection_Endpoint = 1] = "SpeechServiceConnection_Endpoint", e[e.SpeechServiceConnection_Region = 2] = "SpeechServiceConnection_Region", e[e.SpeechServiceAuthorization_Token = 3] = "SpeechServiceAuthorization_Token", e[e.SpeechServiceAuthorization_Type = 4] = "SpeechServiceAuthorization_Type", e[e.SpeechServiceConnection_EndpointId = 5] = "SpeechServiceConnection_EndpointId", e[e.SpeechServiceConnection_TranslationToLanguages = 6] = "SpeechServiceConnection_TranslationToLanguages", e[e.SpeechServiceConnection_TranslationVoice = 7] = "SpeechServiceConnection_TranslationVoice", e[e.SpeechServiceConnection_TranslationFeatures = 8] = "SpeechServiceConnection_TranslationFeatures", e[e.SpeechServiceConnection_IntentRegion = 9] = "SpeechServiceConnection_IntentRegion", e[e.SpeechServiceConnection_ProxyHostName = 10] = "SpeechServiceConnection_ProxyHostName", e[e.SpeechServiceConnection_ProxyPort = 11] = "SpeechServiceConnection_ProxyPort", e[e.SpeechServiceConnection_ProxyUserName = 12] = "SpeechServiceConnection_ProxyUserName", e[e.SpeechServiceConnection_ProxyPassword = 13] = "SpeechServiceConnection_ProxyPassword", e[e.SpeechServiceConnection_RecoMode = 14] = "SpeechServiceConnection_RecoMode", e[e.SpeechServiceConnection_RecoLanguage = 15] = "SpeechServiceConnection_RecoLanguage", e[e.Speech_SessionId = 16] = "Speech_SessionId", e[e.SpeechServiceConnection_SynthLanguage = 17] = "SpeechServiceConnection_SynthLanguage", e[e.SpeechServiceConnection_SynthVoice = 18] = "SpeechServiceConnection_SynthVoice", e[e.SpeechServiceConnection_SynthOutputFormat = 19] = "SpeechServiceConnection_SynthOutputFormat", e[e.SpeechServiceConnection_AutoDetectSourceLanguages = 20] = "SpeechServiceConnection_AutoDetectSourceLanguages", e[e.SpeechServiceResponse_RequestDetailedResultTrueFalse = 21] = "SpeechServiceResponse_RequestDetailedResultTrueFalse", e[e.SpeechServiceResponse_RequestProfanityFilterTrueFalse = 22] = "SpeechServiceResponse_RequestProfanityFilterTrueFalse", e[e.SpeechServiceResponse_JsonResult = 23] = "SpeechServiceResponse_JsonResult", e[e.SpeechServiceResponse_JsonErrorDetails = 24] = "SpeechServiceResponse_JsonErrorDetails", e[e.CancellationDetails_Reason = 25] = "CancellationDetails_Reason", e[e.CancellationDetails_ReasonText = 26] = "CancellationDetails_ReasonText", e[e.CancellationDetails_ReasonDetailedText = 27] = "CancellationDetails_ReasonDetailedText", e[e.LanguageUnderstandingServiceResponse_JsonResult = 28] = "LanguageUnderstandingServiceResponse_JsonResult", e[e.SpeechServiceConnection_Url = 29] = "SpeechServiceConnection_Url", e[e.SpeechServiceConnection_InitialSilenceTimeoutMs = 30] = "SpeechServiceConnection_InitialSilenceTimeoutMs", e[e.SpeechServiceConnection_EndSilenceTimeoutMs = 31] = "SpeechServiceConnection_EndSilenceTimeoutMs", e[e.Speech_SegmentationSilenceTimeoutMs = 32] = "Speech_SegmentationSilenceTimeoutMs", e[e.Speech_SegmentationMaximumTimeMs = 33] = "Speech_SegmentationMaximumTimeMs", e[e.Speech_SegmentationStrategy = 34] = "Speech_SegmentationStrategy", e[e.SpeechServiceConnection_EnableAudioLogging = 35] = "SpeechServiceConnection_EnableAudioLogging", e[e.SpeechServiceConnection_LanguageIdMode = 36] = "SpeechServiceConnection_LanguageIdMode", e[e.SpeechServiceConnection_RecognitionEndpointVersion = 37] = "SpeechServiceConnection_RecognitionEndpointVersion", e[e.SpeechServiceConnection_SpeakerIdMode = 38] = "SpeechServiceConnection_SpeakerIdMode", e[e.SpeechServiceResponse_ProfanityOption = 39] = "SpeechServiceResponse_ProfanityOption", e[e.SpeechServiceResponse_PostProcessingOption = 40] = "SpeechServiceResponse_PostProcessingOption", e[e.SpeechServiceResponse_RequestWordLevelTimestamps = 41] = "SpeechServiceResponse_RequestWordLevelTimestamps", e[e.SpeechServiceResponse_StablePartialResultThreshold = 42] = "SpeechServiceResponse_StablePartialResultThreshold", e[e.SpeechServiceResponse_OutputFormatOption = 43] = "SpeechServiceResponse_OutputFormatOption", e[e.SpeechServiceResponse_TranslationRequestStablePartialResult = 44] = "SpeechServiceResponse_TranslationRequestStablePartialResult", e[e.SpeechServiceResponse_RequestWordBoundary = 45] = "SpeechServiceResponse_RequestWordBoundary", e[e.SpeechServiceResponse_RequestPunctuationBoundary = 46] = "SpeechServiceResponse_RequestPunctuationBoundary", e[e.SpeechServiceResponse_RequestSentenceBoundary = 47] = "SpeechServiceResponse_RequestSentenceBoundary", e[e.SpeechServiceResponse_DiarizeIntermediateResults = 48] = "SpeechServiceResponse_DiarizeIntermediateResults", e[e.Conversation_ApplicationId = 49] = "Conversation_ApplicationId", e[e.Conversation_DialogType = 50] = "Conversation_DialogType", e[e.Conversation_Initial_Silence_Timeout = 51] = "Conversation_Initial_Silence_Timeout", e[e.Conversation_From_Id = 52] = "Conversation_From_Id", e[e.Conversation_Conversation_Id = 53] = "Conversation_Conversation_Id", e[e.Conversation_Custom_Voice_Deployment_Ids = 54] = "Conversation_Custom_Voice_Deployment_Ids", e[e.Conversation_Speech_Activity_Template = 55] = "Conversation_Speech_Activity_Template", e[e.Conversation_Request_Bot_Status_Messages = 56] = "Conversation_Request_Bot_Status_Messages", e[e.Conversation_Agent_Connection_Id = 57] = "Conversation_Agent_Connection_Id", e[e.SpeechServiceConnection_Host = 58] = "SpeechServiceConnection_Host", e[e.ConversationTranslator_Host = 59] = "ConversationTranslator_Host", e[e.ConversationTranslator_Name = 60] = "ConversationTranslator_Name", e[e.ConversationTranslator_CorrelationId = 61] = "ConversationTranslator_CorrelationId", e[e.ConversationTranslator_Token = 62] = "ConversationTranslator_Token", e[e.PronunciationAssessment_ReferenceText = 63] = "PronunciationAssessment_ReferenceText", e[e.PronunciationAssessment_GradingSystem = 64] = "PronunciationAssessment_GradingSystem", e[e.PronunciationAssessment_Granularity = 65] = "PronunciationAssessment_Granularity", e[e.PronunciationAssessment_EnableMiscue = 66] = "PronunciationAssessment_EnableMiscue", e[e.PronunciationAssessment_Json = 67] = "PronunciationAssessment_Json", e[e.PronunciationAssessment_Params = 68] = "PronunciationAssessment_Params", e[e.SpeakerRecognition_Api_Version = 69] = "SpeakerRecognition_Api_Version", e[e.WebWorkerLoadType = 70] = "WebWorkerLoadType", e[e.TalkingAvatarService_WebRTC_SDP = 71] = "TalkingAvatarService_WebRTC_SDP";
  }(t.PropertyId || (t.PropertyId = {}));
})(aa);
var kr = {}, ld;
function k0() {
  if (ld)
    return kr;
  ld = 1, Object.defineProperty(kr, "__esModule", { value: !0 }), kr.Recognizer = void 0;
  const t = A(), e = k(), n = N, r = R();
  let s = class Of {
    /**
     * Creates and initializes an instance of a Recognizer
     * @constructor
     * @param {AudioConfig} audioInput - An optional audio input stream associated with the recognizer
     * @param {PropertyCollection} properties - A set of properties to set on the recognizer
     * @param {IConnectionFactory} connectionFactory - The factory class used to create a custom IConnection for the recognizer
     */
    constructor(a, i, c) {
      this.audioConfig = a !== void 0 ? a : r.AudioConfig.fromDefaultMicrophoneInput(), this.privDisposed = !1, this.privProperties = i.clone(), this.privConnectionFactory = c, this.implCommonRecognizerSetup();
    }
    /**
     * Dispose of associated resources.
     * @member Recognizer.prototype.close
     * @function
     * @public
     */
    close(a, i) {
      n.Contracts.throwIfDisposed(this.privDisposed), e.marshalPromiseToCallbacks(this.dispose(!0), a, i);
    }
    /**
     * @Internal
     * Internal data member to support fromRecognizer* pattern methods on other classes.
     * Do not use externally, object returned will change without warning or notice.
     */
    get internalData() {
      return this.privReco;
    }
    /**
     * This method performs cleanup of resources.
     * The Boolean parameter disposing indicates whether the method is called
     * from Dispose (if disposing is true) or from the finalizer (if disposing is false).
     * Derived classes should override this method to dispose resource if needed.
     * @member Recognizer.prototype.dispose
     * @function
     * @public
     * @param {boolean} disposing - Flag to request disposal.
     */
    async dispose(a) {
      this.privDisposed || (this.privDisposed = !0, a && this.privReco && (await this.privReco.audioSource.turnOff(), await this.privReco.dispose()));
    }
    /**
     * This method returns the current state of the telemetry setting.
     * @member Recognizer.prototype.telemetryEnabled
     * @function
     * @public
     * @returns true if the telemetry is enabled, false otherwise.
     */
    static get telemetryEnabled() {
      return t.ServiceRecognizerBase.telemetryDataEnabled;
    }
    /**
     * This method globally enables or disables telemetry.
     * @member Recognizer.prototype.enableTelemetry
     * @function
     * @public
     * @param enabled - Global setting for telemetry collection.
     * If set to true, telemetry information like microphone errors,
     * recognition errors are collected and sent to Microsoft.
     * If set to false, no telemetry is sent to Microsoft.
     */
    static enableTelemetry(a) {
      t.ServiceRecognizerBase.telemetryDataEnabled = a;
    }
    // Does the generic recognizer setup that is common across all recognizer types.
    implCommonRecognizerSetup() {
      let a = typeof window < "u" ? "Browser" : "Node", i = "unknown", c = "unknown";
      typeof navigator < "u" && (a = a + "/" + navigator.platform, i = navigator.userAgent, c = navigator.appVersion);
      const u = this.createRecognizerConfig(new t.SpeechServiceConfig(new t.Context(new t.OS(a, i, c))));
      this.privReco = this.createServiceRecognizer(Of.getAuthFromProperties(this.privProperties), this.privConnectionFactory, this.audioConfig, u);
    }
    async recognizeOnceAsyncImpl(a) {
      n.Contracts.throwIfDisposed(this.privDisposed);
      const i = new e.Deferred();
      await this.implRecognizerStop(), await this.privReco.recognize(a, i.resolve, i.reject);
      const c = await i.promise;
      return await this.implRecognizerStop(), c;
    }
    async startContinuousRecognitionAsyncImpl(a) {
      n.Contracts.throwIfDisposed(this.privDisposed), await this.implRecognizerStop(), await this.privReco.recognize(a, void 0, void 0);
    }
    async stopContinuousRecognitionAsyncImpl() {
      n.Contracts.throwIfDisposed(this.privDisposed), await this.implRecognizerStop();
    }
    async implRecognizerStop() {
      this.privReco && await this.privReco.stopRecognizing();
    }
    static getAuthFromProperties(a) {
      const i = a.getProperty(r.PropertyId.SpeechServiceConnection_Key, void 0);
      return i && i !== "" ? new t.CognitiveSubscriptionKeyAuthentication(i) : new t.CognitiveTokenAuthentication(() => {
        const u = a.getProperty(r.PropertyId.SpeechServiceAuthorization_Token, void 0);
        return Promise.resolve(u);
      }, () => {
        const u = a.getProperty(r.PropertyId.SpeechServiceAuthorization_Token, void 0);
        return Promise.resolve(u);
      });
    }
  };
  return kr.Recognizer = s, kr;
}
var Or = {}, hd;
function O0() {
  if (hd)
    return Or;
  hd = 1, Object.defineProperty(Or, "__esModule", { value: !0 }), Or.SpeechRecognizer = void 0;
  const t = A(), e = k(), n = N, r = R();
  class s extends r.Recognizer {
    /**
     * SpeechRecognizer constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - an set of initial properties for this recognizer
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
     */
    constructor(a, i) {
      const c = a;
      n.Contracts.throwIfNull(c, "speechConfig"), n.Contracts.throwIfNullOrWhitespace(c.properties.getProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage), r.PropertyId[r.PropertyId.SpeechServiceConnection_RecoLanguage]), super(i, c.properties, new t.SpeechConnectionFactory()), this.privDisposedRecognizer = !1;
    }
    /**
     * SpeechRecognizer constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - an set of initial properties for this recognizer
     * @param {AutoDetectSourceLanguageConfig} autoDetectSourceLanguageConfig - An source language detection configuration associated with the recognizer
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
     */
    static FromConfig(a, i, c) {
      const u = a;
      return i.properties.mergeTo(u.properties), new s(a, c);
    }
    /**
     * Gets the endpoint id of a customized speech model that is used for speech recognition.
     * @member SpeechRecognizer.prototype.endpointId
     * @function
     * @public
     * @returns {string} the endpoint id of a customized speech model that is used for speech recognition.
     */
    get endpointId() {
      return n.Contracts.throwIfDisposed(this.privDisposedRecognizer), this.properties.getProperty(r.PropertyId.SpeechServiceConnection_EndpointId, "00000000-0000-0000-0000-000000000000");
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member SpeechRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(r.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * @member SpeechRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @param {string} token - Authorization token.
     */
    set authorizationToken(a) {
      n.Contracts.throwIfNullOrWhitespace(a, "token"), this.properties.setProperty(r.PropertyId.SpeechServiceAuthorization_Token, a);
    }
    /**
     * Gets the spoken language of recognition.
     * @member SpeechRecognizer.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @returns {string} The spoken language of recognition.
     */
    get speechRecognitionLanguage() {
      return n.Contracts.throwIfDisposed(this.privDisposedRecognizer), this.properties.getProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage);
    }
    /**
     * Gets the output format of recognition.
     * @member SpeechRecognizer.prototype.outputFormat
     * @function
     * @public
     * @returns {OutputFormat} The output format of recognition.
     */
    get outputFormat() {
      return n.Contracts.throwIfDisposed(this.privDisposedRecognizer), this.properties.getProperty(t.OutputFormatPropertyName, r.OutputFormat[r.OutputFormat.Simple]) === r.OutputFormat[r.OutputFormat.Simple] ? r.OutputFormat.Simple : r.OutputFormat.Detailed;
    }
    /**
     * The collection of properties and their values defined for this SpeechRecognizer.
     * @member SpeechRecognizer.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this SpeechRecognizer.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Starts speech recognition, and stops after the first utterance is recognized.
     * The task returns the recognition text as result.
     * Note: RecognizeOnceAsync() returns when the first utterance has been recognized,
     * so it is suitable only for single shot recognition
     * like command or query. For long-running recognition, use StartContinuousRecognitionAsync() instead.
     * @member SpeechRecognizer.prototype.recognizeOnceAsync
     * @function
     * @public
     * @param cb - Callback that received the SpeechRecognitionResult.
     * @param err - Callback invoked in case of an error.
     */
    recognizeOnceAsync(a, i) {
      e.marshalPromiseToCallbacks(this.recognizeOnceAsyncImpl(t.RecognitionMode.Interactive), a, i);
    }
    /**
     * Starts speech recognition, until stopContinuousRecognitionAsync() is called.
     * User must subscribe to events to receive recognition results.
     * @member SpeechRecognizer.prototype.startContinuousRecognitionAsync
     * @function
     * @public
     * @param cb - Callback invoked once the recognition has started.
     * @param err - Callback invoked in case of an error.
     */
    startContinuousRecognitionAsync(a, i) {
      e.marshalPromiseToCallbacks(this.startContinuousRecognitionAsyncImpl(t.RecognitionMode.Conversation), a, i);
    }
    /**
     * Stops continuous speech recognition.
     * @member SpeechRecognizer.prototype.stopContinuousRecognitionAsync
     * @function
     * @public
     * @param cb - Callback invoked once the recognition has stopped.
     * @param err - Callback invoked in case of an error.
     */
    stopContinuousRecognitionAsync(a, i) {
      e.marshalPromiseToCallbacks(this.stopContinuousRecognitionAsyncImpl(), a, i);
    }
    /**
     * Starts speech recognition with keyword spotting, until
     * stopKeywordRecognitionAsync() is called.
     * User must subscribe to events to receive recognition results.
     * Note: Key word spotting functionality is only available on the
     * Speech Devices SDK. This functionality is currently not included in the SDK itself.
     * @member SpeechRecognizer.prototype.startKeywordRecognitionAsync
     * @function
     * @public
     * @param {KeywordRecognitionModel} model The keyword recognition model that
     * specifies the keyword to be recognized.
     * @param cb - Callback invoked once the recognition has started.
     * @param err - Callback invoked in case of an error.
     */
    startKeywordRecognitionAsync(a, i, c) {
      n.Contracts.throwIfNull(a, "model"), c && c("Not yet implemented.");
    }
    /**
     * Stops continuous speech recognition.
     * Note: Key word spotting functionality is only available on the
     * Speech Devices SDK. This functionality is currently not included in the SDK itself.
     * @member SpeechRecognizer.prototype.stopKeywordRecognitionAsync
     * @function
     * @public
     * @param cb - Callback invoked once the recognition has stopped.
     * @param err - Callback invoked in case of an error.
     */
    stopKeywordRecognitionAsync(a) {
      a && a();
    }
    /**
     * closes all external resources held by an instance of this class.
     * @member SpeechRecognizer.prototype.close
     * @function
     * @public
     */
    close(a, i) {
      n.Contracts.throwIfDisposed(this.privDisposedRecognizer), e.marshalPromiseToCallbacks(this.dispose(!0), a, i);
    }
    /**
     * Disposes any resources held by the object.
     * @member SpeechRecognizer.prototype.dispose
     * @function
     * @public
     * @param {boolean} disposing - true if disposing the object.
     */
    async dispose(a) {
      this.privDisposedRecognizer || (a && (this.privDisposedRecognizer = !0, await this.implRecognizerStop()), await super.dispose(a));
    }
    createRecognizerConfig(a) {
      return new t.RecognizerConfig(a, this.privProperties);
    }
    createServiceRecognizer(a, i, c, u) {
      const p = c;
      return new t.SpeechServiceRecognizer(a, i, p, u, this);
    }
  }
  return Or.SpeechRecognizer = s, Or;
}
var Dr = {}, vd;
function D0() {
  if (vd)
    return Dr;
  vd = 1, Object.defineProperty(Dr, "__esModule", { value: !0 }), Dr.IntentRecognizer = void 0;
  const t = A(), e = k(), n = N, r = R();
  let s = class extends r.Recognizer {
    /**
     * Initializes an instance of the IntentRecognizer.
     * @constructor
     * @param {SpeechConfig} speechConfig - The set of configuration properties.
     * @param {AudioConfig} audioConfig - An optional audio input config associated with the recognizer
     */
    constructor(a, i) {
      n.Contracts.throwIfNullOrUndefined(a, "speechConfig");
      const c = a;
      n.Contracts.throwIfNullOrUndefined(c, "speechConfig"), super(i, c.properties, new t.IntentConnectionFactory()), this.privAddedIntents = [], this.privAddedLmIntents = {}, this.privDisposedIntentRecognizer = !1, this.privProperties = c.properties, n.Contracts.throwIfNullOrWhitespace(this.properties.getProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage), r.PropertyId[r.PropertyId.SpeechServiceConnection_RecoLanguage]);
    }
    /**
     * Gets the spoken language of recognition.
     * @member IntentRecognizer.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @returns {string} the spoken language of recognition.
     */
    get speechRecognitionLanguage() {
      return n.Contracts.throwIfDisposed(this.privDisposedIntentRecognizer), this.properties.getProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage);
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member IntentRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(r.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * Note: Please use a token derived from your LanguageUnderstanding subscription key for the Intent recognizer.
     * @member IntentRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @param {string} value - Authorization token.
     */
    set authorizationToken(a) {
      this.properties.setProperty(r.PropertyId.SpeechServiceAuthorization_Token, a);
    }
    /**
     * The collection of properties and their values defined for this IntentRecognizer.
     * @member IntentRecognizer.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their
     * values defined for this IntentRecognizer.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Starts intent recognition, and stops after the first utterance is recognized.
     * The task returns the recognition text and intent as result.
     * Note: RecognizeOnceAsync() returns when the first utterance has been recognized,
     * so it is suitable only for single shot recognition like command or query.
     * For long-running recognition, use StartContinuousRecognitionAsync() instead.
     * @member IntentRecognizer.prototype.recognizeOnceAsync
     * @function
     * @public
     * @param cb - Callback that received the recognition has finished with an IntentRecognitionResult.
     * @param err - Callback invoked in case of an error.
     */
    recognizeOnceAsync(a, i) {
      if (n.Contracts.throwIfDisposed(this.privDisposedIntentRecognizer), Object.keys(this.privAddedLmIntents).length !== 0 || this.privUmbrellaIntent !== void 0) {
        const c = this.buildSpeechContext();
        this.privReco.speechContext.setSection("intent", c.Intent), this.privReco.dynamicGrammar.addReferenceGrammar(c.ReferenceGrammars), this.privReco.setIntents(this.privAddedLmIntents, this.privUmbrellaIntent);
      }
      e.marshalPromiseToCallbacks(this.recognizeOnceAsyncImpl(t.RecognitionMode.Interactive), a, i);
    }
    /**
     * Starts speech recognition, until stopContinuousRecognitionAsync() is called.
     * User must subscribe to events to receive recognition results.
     * @member IntentRecognizer.prototype.startContinuousRecognitionAsync
     * @function
     * @public
     * @param cb - Callback invoked once the recognition has started.
     * @param err - Callback invoked in case of an error.
     */
    startContinuousRecognitionAsync(a, i) {
      if (Object.keys(this.privAddedLmIntents).length !== 0 || this.privUmbrellaIntent !== void 0) {
        const c = this.buildSpeechContext();
        this.privReco.speechContext.setSection("intent", c.Intent), this.privReco.dynamicGrammar.addReferenceGrammar(c.ReferenceGrammars), this.privReco.setIntents(this.privAddedLmIntents, this.privUmbrellaIntent);
      }
      e.marshalPromiseToCallbacks(this.startContinuousRecognitionAsyncImpl(t.RecognitionMode.Conversation), a, i);
    }
    /**
     * Stops continuous intent recognition.
     * @member IntentRecognizer.prototype.stopContinuousRecognitionAsync
     * @function
     * @public
     * @param cb - Callback invoked once the recognition has stopped.
     * @param err - Callback invoked in case of an error.
     */
    stopContinuousRecognitionAsync(a, i) {
      e.marshalPromiseToCallbacks(this.stopContinuousRecognitionAsyncImpl(), a, i);
    }
    /**
     * Starts speech recognition with keyword spotting, until stopKeywordRecognitionAsync() is called.
     * User must subscribe to events to receive recognition results.
     * Note: Key word spotting functionality is only available on the Speech Devices SDK.
     * This functionality is currently not included in the SDK itself.
     * @member IntentRecognizer.prototype.startKeywordRecognitionAsync
     * @function
     * @public
     * @param {KeywordRecognitionModel} model - The keyword recognition model that specifies the keyword to be recognized.
     * @param cb - Callback invoked once the recognition has started.
     * @param err - Callback invoked in case of an error.
     */
    startKeywordRecognitionAsync(a, i, c) {
      n.Contracts.throwIfNull(a, "model"), c && c("Not yet implemented.");
    }
    /**
     * Stops continuous speech recognition.
     * Note: Key word spotting functionality is only available on the Speech Devices SDK.
     * This functionality is currently not included in the SDK itself.
     * @member IntentRecognizer.prototype.stopKeywordRecognitionAsync
     * @function
     * @public
     * @param cb - Callback invoked once the recognition has stopped.
     * @param err - Callback invoked in case of an error.
     */
    stopKeywordRecognitionAsync(a, i) {
      if (a)
        try {
          a();
        } catch (c) {
          i && i(c);
        }
    }
    /**
     * Adds a phrase that should be recognized as intent.
     * @member IntentRecognizer.prototype.addIntent
     * @function
     * @public
     * @param {string} intentId - A String that represents the identifier of the intent to be recognized.
     * @param {string} phrase - A String that specifies the phrase representing the intent.
     */
    addIntent(a, i) {
      n.Contracts.throwIfDisposed(this.privDisposedIntentRecognizer), n.Contracts.throwIfNullOrWhitespace(i, "intentId"), n.Contracts.throwIfNullOrWhitespace(a, "simplePhrase"), this.privAddedIntents.push([i, a]);
    }
    /**
     * Adds an intent from Language Understanding service for recognition.
     * @member IntentRecognizer.prototype.addIntentWithLanguageModel
     * @function
     * @public
     * @param {string} intentId - A String that represents the identifier of the intent
     * to be recognized. Ignored if intentName is empty.
     * @param {string} model - The intent model from Language Understanding service.
     * @param {string} intentName - The intent name defined in the intent model. If it
     * is empty, all intent names defined in the model will be added.
     */
    addIntentWithLanguageModel(a, i, c) {
      n.Contracts.throwIfDisposed(this.privDisposedIntentRecognizer), n.Contracts.throwIfNullOrWhitespace(a, "intentId"), n.Contracts.throwIfNull(i, "model");
      const u = i;
      n.Contracts.throwIfNullOrWhitespace(u.appId, "model.appId"), this.privAddedLmIntents[a] = new t.AddedLmIntent(u, c);
    }
    /**
     * @summary Adds all intents from the specified Language Understanding Model.
     * @member IntentRecognizer.prototype.addAllIntents
     * @function
     * @public
     * @function
     * @public
     * @param {LanguageUnderstandingModel} model - The language understanding model containing the intents.
     * @param {string} intentId - A custom id String to be returned in the IntentRecognitionResult's getIntentId() method.
     */
    addAllIntents(a, i) {
      n.Contracts.throwIfNull(a, "model");
      const c = a;
      n.Contracts.throwIfNullOrWhitespace(c.appId, "model.appId"), this.privUmbrellaIntent = new t.AddedLmIntent(c, i);
    }
    /**
     * closes all external resources held by an instance of this class.
     * @member IntentRecognizer.prototype.close
     * @function
     * @public
     */
    close(a, i) {
      n.Contracts.throwIfDisposed(this.privDisposedIntentRecognizer), e.marshalPromiseToCallbacks(this.dispose(!0), a, i);
    }
    createRecognizerConfig(a) {
      return new t.RecognizerConfig(a, this.privProperties);
    }
    createServiceRecognizer(a, i, c, u) {
      const p = c;
      return new t.IntentServiceRecognizer(a, i, p, u, this);
    }
    async dispose(a) {
      this.privDisposedIntentRecognizer || a && (this.privDisposedIntentRecognizer = !0, await super.dispose(a));
    }
    buildSpeechContext() {
      let a, i, c;
      const u = [];
      this.privUmbrellaIntent !== void 0 && (a = this.privUmbrellaIntent.modelImpl.appId, i = this.privUmbrellaIntent.modelImpl.region, c = this.privUmbrellaIntent.modelImpl.subscriptionKey);
      for (const p of Object.keys(this.privAddedLmIntents)) {
        const d = this.privAddedLmIntents[p];
        if (a === void 0)
          a = d.modelImpl.appId;
        else if (a !== d.modelImpl.appId)
          throw new Error("Intents must all be from the same LUIS model");
        if (i === void 0)
          i = d.modelImpl.region;
        else if (i !== d.modelImpl.region)
          throw new Error("Intents must all be from the same LUIS model in a single region");
        if (c === void 0)
          c = d.modelImpl.subscriptionKey;
        else if (c !== d.modelImpl.subscriptionKey)
          throw new Error("Intents must all use the same subscription key");
        const l = "luis/" + a + "-PRODUCTION#" + p;
        u.push(l);
      }
      return {
        Intent: {
          id: a,
          key: c === void 0 ? this.privProperties.getProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_Key]) : c,
          provider: "LUIS"
        },
        ReferenceGrammars: this.privUmbrellaIntent === void 0 ? u : ["luis/" + a + "-PRODUCTION"]
      };
    }
  };
  return Dr.IntentRecognizer = s, Dr;
}
var Df = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.VoiceProfileType = void 0, function(e) {
    e[e.TextIndependentIdentification = 0] = "TextIndependentIdentification", e[e.TextDependentVerification = 1] = "TextDependentVerification", e[e.TextIndependentVerification = 2] = "TextIndependentVerification";
  }(t.VoiceProfileType || (t.VoiceProfileType = {}));
})(Df);
var Nr = {}, Lr = {}, Gt = {}, fd;
function Nf() {
  if (fd)
    return Gt;
  fd = 1, Object.defineProperty(Gt, "__esModule", { value: !0 }), Gt.ConnectionMessageImpl = Gt.ConnectionMessage = void 0;
  const t = Se, e = k(), n = kf(), r = aa;
  let s = class {
  };
  Gt.ConnectionMessage = s;
  class o {
    constructor(i) {
      this.privConnectionMessage = i, this.privProperties = new n.PropertyCollection(), this.privConnectionMessage.headers[t.HeaderNames.ConnectionId] && this.privProperties.setProperty(r.PropertyId.Speech_SessionId, this.privConnectionMessage.headers[t.HeaderNames.ConnectionId]), Object.keys(this.privConnectionMessage.headers).forEach((c) => {
        this.privProperties.setProperty(c, this.privConnectionMessage.headers[c]);
      });
    }
    /**
     * The message path.
     */
    get path() {
      return this.privConnectionMessage.headers[Object.keys(this.privConnectionMessage.headers).find((i) => i.toLowerCase() === "path".toLowerCase())];
    }
    /**
     * Checks to see if the ConnectionMessage is a text message.
     * See also IsBinaryMessage().
     */
    get isTextMessage() {
      return this.privConnectionMessage.messageType === e.MessageType.Text;
    }
    /**
     * Checks to see if the ConnectionMessage is a binary message.
     * See also GetBinaryMessage().
     */
    get isBinaryMessage() {
      return this.privConnectionMessage.messageType === e.MessageType.Binary;
    }
    /**
     * Gets the text message payload. Typically the text message content-type is
     * application/json. To determine other content-types use
     * Properties.GetProperty("Content-Type").
     */
    get TextMessage() {
      return this.privConnectionMessage.textBody;
    }
    /**
     * Gets the binary message payload.
     */
    get binaryMessage() {
      return this.privConnectionMessage.binaryBody;
    }
    /**
     * A collection of properties and their values defined for this <see cref="ConnectionMessage"/>.
     * Message headers can be accessed via this collection (e.g. "Content-Type").
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Returns a string that represents the connection message.
     */
    toString() {
      return "";
    }
  }
  return Gt.ConnectionMessageImpl = o, Gt;
}
var gd;
function Lf() {
  if (gd)
    return Lr;
  gd = 1, Object.defineProperty(Lr, "__esModule", { value: !0 }), Lr.Connection = void 0;
  const t = A(), e = k(), n = Nf(), r = N, s = R();
  let o = class Jc {
    /**
     * Gets the Connection instance from the specified recognizer.
     * @param recognizer The recognizer associated with the connection.
     * @return The Connection instance of the recognizer.
     */
    static fromRecognizer(i) {
      const c = i.internalData, u = new Jc();
      return u.privInternalData = c, u.setupEvents(), u;
    }
    /**
     * Gets the Connection instance from the specified synthesizer.
     * @param synthesizer The synthesizer associated with the connection.
     * @return The Connection instance of the synthesizer.
     */
    static fromSynthesizer(i) {
      const c = i.internalData, u = new Jc();
      return u.privInternalData = c, u.setupEvents(), u;
    }
    /**
     * Starts to set up connection to the service.
     * Users can optionally call openConnection() to manually set up a connection in advance before starting recognition on the
     * Recognizer associated with this Connection. After starting recognition, calling Open() will have no effect
     *
     * Note: On return, the connection might not be ready yet. Please subscribe to the Connected event to
     * be notified when the connection is established.
     */
    openConnection(i, c) {
      e.marshalPromiseToCallbacks(this.privInternalData.connect(), i, c);
    }
    /**
     * Closes the connection the service.
     * Users can optionally call closeConnection() to manually shutdown the connection of the associated Recognizer.
     *
     * If closeConnection() is called during recognition, recognition will fail and cancel with an error.
     */
    closeConnection(i, c) {
      if (this.privInternalData instanceof t.SynthesisAdapterBase)
        throw new Error("Disconnecting a synthesizer's connection is currently not supported");
      e.marshalPromiseToCallbacks(this.privInternalData.disconnect(), i, c);
    }
    /**
     * Appends a parameter in a message to service.
     * Added in version 1.12.1.
     * @param path The path of the network message.
     * @param propertyName Name of the property
     * @param propertyValue Value of the property. This is a json string.
     */
    setMessageProperty(i, c, u) {
      if (r.Contracts.throwIfNullOrWhitespace(c, "propertyName"), this.privInternalData instanceof t.ServiceRecognizerBase) {
        if (i.toLowerCase() !== "speech.context")
          throw new Error("Only speech.context message property sets are currently supported for recognizer");
        this.privInternalData.speechContext.setSection(c, u);
      } else if (this.privInternalData instanceof t.SynthesisAdapterBase) {
        if (i.toLowerCase() !== "synthesis.context")
          throw new Error("Only synthesis.context message property sets are currently supported for synthesizer");
        this.privInternalData.synthesisContext.setSection(c, u);
      }
    }
    /**
     * Sends a message to the speech service.
     * Added in version 1.13.0.
     * @param path The WebSocket path of the message
     * @param payload The payload of the message. This is a json string or a ArrayBuffer.
     * @param success A callback to indicate success.
     * @param error A callback to indicate an error.
     */
    sendMessageAsync(i, c, u, p) {
      e.marshalPromiseToCallbacks(this.privInternalData.sendNetworkMessage(i, c), u, p);
    }
    /**
     * Dispose of associated resources.
     */
    close() {
    }
    setupEvents() {
      this.privEventListener = this.privInternalData.connectionEvents.attach((i) => {
        i.name === "ConnectionEstablishedEvent" ? this.connected && this.connected(new s.ConnectionEventArgs(i.connectionId)) : i.name === "ConnectionClosedEvent" ? this.disconnected && this.disconnected(new s.ConnectionEventArgs(i.connectionId)) : i.name === "ConnectionMessageSentEvent" ? this.messageSent && this.messageSent(new s.ConnectionMessageEventArgs(new n.ConnectionMessageImpl(i.message))) : i.name === "ConnectionMessageReceivedEvent" && this.messageReceived && this.messageReceived(new s.ConnectionMessageEventArgs(new n.ConnectionMessageImpl(i.message)));
      }), this.privServiceEventListener = this.privInternalData.serviceEvents.attach((i) => {
        this.receivedServiceMessage && this.receivedServiceMessage(new s.ServiceEventArgs(i.jsonString, i.name));
      });
    }
  };
  return Lr.Connection = o, Lr;
}
var md;
function N0() {
  if (md)
    return Nr;
  md = 1, Object.defineProperty(Nr, "__esModule", { value: !0 }), Nr.TranslationRecognizer = void 0;
  const t = A(), e = k(), n = Lf(), r = N, s = R();
  let o = class zf extends s.Recognizer {
    /**
     * Initializes an instance of the TranslationRecognizer.
     * @constructor
     * @param {SpeechTranslationConfig} speechConfig - Set of properties to configure this recognizer.
     * @param {AudioConfig} audioConfig - An optional audio config associated with the recognizer
     * @param {IConnectionFactory} connectionFactory - An optional connection factory to use to generate the endpoint URIs, headers to set, etc...
     */
    constructor(i, c, u) {
      const p = i;
      r.Contracts.throwIfNull(p, "speechConfig"), super(c, p.properties, u || new t.TranslationConnectionFactory()), this.privDisposedTranslationRecognizer = !1, this.properties.getProperty(s.PropertyId.SpeechServiceConnection_TranslationVoice, void 0) !== void 0 && r.Contracts.throwIfNullOrWhitespace(this.properties.getProperty(s.PropertyId.SpeechServiceConnection_TranslationVoice), s.PropertyId[s.PropertyId.SpeechServiceConnection_TranslationVoice]), r.Contracts.throwIfNullOrWhitespace(this.properties.getProperty(s.PropertyId.SpeechServiceConnection_TranslationToLanguages), s.PropertyId[s.PropertyId.SpeechServiceConnection_TranslationToLanguages]), r.Contracts.throwIfNullOrWhitespace(this.properties.getProperty(s.PropertyId.SpeechServiceConnection_RecoLanguage), s.PropertyId[s.PropertyId.SpeechServiceConnection_RecoLanguage]);
    }
    /**
     * TranslationRecognizer constructor.
     * @constructor
     * @param {SpeechTranslationConfig} speechTranslationConfig - an set of initial properties for this recognizer
     * @param {AutoDetectSourceLanguageConfig} autoDetectSourceLanguageConfig - An source language detection configuration associated with the recognizer
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
     */
    static FromConfig(i, c, u) {
      const p = i;
      return c.properties.mergeTo(p.properties), new zf(i, u);
    }
    /**
     * Gets the language name that was set when the recognizer was created.
     * @member TranslationRecognizer.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @returns {string} Gets the language name that was set when the recognizer was created.
     */
    get speechRecognitionLanguage() {
      return r.Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer), this.properties.getProperty(s.PropertyId.SpeechServiceConnection_RecoLanguage);
    }
    /**
     * Gets target languages for translation that were set when the recognizer was created.
     * The language is specified in BCP-47 format. The translation will provide translated text for each of language.
     * @member TranslationRecognizer.prototype.targetLanguages
     * @function
     * @public
     * @returns {string[]} Gets target languages for translation that were set when the recognizer was created.
     */
    get targetLanguages() {
      return r.Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer), this.properties.getProperty(s.PropertyId.SpeechServiceConnection_TranslationToLanguages).split(",");
    }
    /**
     * Gets the name of output voice.
     * @member TranslationRecognizer.prototype.voiceName
     * @function
     * @public
     * @returns {string} the name of output voice.
     */
    get voiceName() {
      return r.Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer), this.properties.getProperty(s.PropertyId.SpeechServiceConnection_TranslationVoice, void 0);
    }
    /**
     * The collection of properties and their values defined for this TranslationRecognizer.
     * @member TranslationRecognizer.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this TranslationRecognizer.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member TranslationRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(s.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * @member TranslationRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @param {string} value - Authorization token.
     */
    set authorizationToken(i) {
      this.properties.setProperty(s.PropertyId.SpeechServiceAuthorization_Token, i);
    }
    /**
     * Starts recognition and translation, and stops after the first utterance is recognized.
     * The task returns the translation text as result.
     * Note: recognizeOnceAsync returns when the first utterance has been recognized, so it is suitable only
     * for single shot recognition like command or query. For long-running recognition,
     * use startContinuousRecognitionAsync() instead.
     * @member TranslationRecognizer.prototype.recognizeOnceAsync
     * @function
     * @public
     * @param cb - Callback that received the result when the translation has completed.
     * @param err - Callback invoked in case of an error.
     */
    recognizeOnceAsync(i, c) {
      r.Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer), e.marshalPromiseToCallbacks(this.recognizeOnceAsyncImpl(t.RecognitionMode.Interactive), i, c);
    }
    /**
     * Starts recognition and translation, until stopContinuousRecognitionAsync() is called.
     * User must subscribe to events to receive translation results.
     * @member TranslationRecognizer.prototype.startContinuousRecognitionAsync
     * @function
     * @public
     * @param cb - Callback that received the translation has started.
     * @param err - Callback invoked in case of an error.
     */
    startContinuousRecognitionAsync(i, c) {
      e.marshalPromiseToCallbacks(this.startContinuousRecognitionAsyncImpl(t.RecognitionMode.Conversation), i, c);
    }
    /**
     * Stops continuous recognition and translation.
     * @member TranslationRecognizer.prototype.stopContinuousRecognitionAsync
     * @function
     * @public
     * @param cb - Callback that received the translation has stopped.
     * @param err - Callback invoked in case of an error.
     */
    stopContinuousRecognitionAsync(i, c) {
      e.marshalPromiseToCallbacks(this.stopContinuousRecognitionAsyncImpl(), i, c);
    }
    /**
     * dynamically remove a language from list of target language
     * (can be used while recognition is ongoing)
     * @member TranslationRecognizer.prototype.removeTargetLanguage
     * @function
     * @param lang - language to be removed
     * @public
     */
    removeTargetLanguage(i) {
      if (r.Contracts.throwIfNullOrUndefined(i, "language to be removed"), this.properties.getProperty(s.PropertyId.SpeechServiceConnection_TranslationToLanguages, void 0) !== void 0) {
        const c = this.properties.getProperty(s.PropertyId.SpeechServiceConnection_TranslationToLanguages).split(","), u = c.indexOf(i);
        u > -1 && (c.splice(u, 1), this.properties.setProperty(s.PropertyId.SpeechServiceConnection_TranslationToLanguages, c.join(",")), this.updateLanguages(c));
      }
    }
    /**
     * dynamically add a language to list of target language
     * (can be used while recognition is ongoing)
     * @member TranslationRecognizer.prototype.addTargetLanguage
     * @function
     * @param lang - language to be added
     * @public
     */
    addTargetLanguage(i) {
      r.Contracts.throwIfNullOrUndefined(i, "language to be added");
      let c = [];
      this.properties.getProperty(s.PropertyId.SpeechServiceConnection_TranslationToLanguages, void 0) !== void 0 ? (c = this.properties.getProperty(s.PropertyId.SpeechServiceConnection_TranslationToLanguages).split(","), c.includes(i) || (c.push(i), this.properties.setProperty(s.PropertyId.SpeechServiceConnection_TranslationToLanguages, c.join(",")))) : (this.properties.setProperty(s.PropertyId.SpeechServiceConnection_TranslationToLanguages, i), c = [i]), this.updateLanguages(c);
    }
    /**
     * closes all external resources held by an instance of this class.
     * @member TranslationRecognizer.prototype.close
     * @function
     * @public
     */
    close(i, c) {
      r.Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer), e.marshalPromiseToCallbacks(this.dispose(!0), i, c);
    }
    /**
     * handles ConnectionEstablishedEvent for conversation translation scenarios.
     * @member TranslationRecognizer.prototype.onConnection
     * @function
     * @public
     */
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    onConnection() {
    }
    async dispose(i) {
      this.privDisposedTranslationRecognizer || (this.privDisposedTranslationRecognizer = !0, i && (await this.implRecognizerStop(), await super.dispose(i)));
    }
    createRecognizerConfig(i) {
      return new t.RecognizerConfig(i, this.privProperties);
    }
    createServiceRecognizer(i, c, u, p) {
      const d = u;
      return new t.TranslationServiceRecognizer(i, c, d, p, this);
    }
    updateLanguages(i) {
      const c = n.Connection.fromRecognizer(this);
      c && (c.setMessageProperty("speech.context", "translationcontext", { to: i }), c.sendMessageAsync("event", JSON.stringify({
        id: "translation",
        name: "updateLanguage",
        to: i
      })));
    }
  };
  return Nr.TranslationRecognizer = o, Nr;
}
var zr = {}, Sd;
function L0() {
  if (Sd)
    return zr;
  Sd = 1, Object.defineProperty(zr, "__esModule", { value: !0 }), zr.Translations = void 0;
  const t = R();
  let e = class {
    constructor() {
      this.privMap = new t.PropertyCollection();
    }
    /**
     * Get the languages in the object in a String array.
     * @member Translations.prototype.languages
     * @function
     * @public
     * @returns {string[]} languages in translations object.
     */
    get languages() {
      return this.privMap.keys;
    }
    /**
     * Returns the parameter value in type String. The parameter must have the same type as String.
     * Currently only String, int and bool are allowed.
     * If the name is not available, the specified defaultValue is returned.
     * @member Translations.prototype.get
     * @function
     * @public
     * @param {string} key - The parameter name.
     * @param {string} def - The default value which is returned if the parameter is not available in the collection.
     * @returns {string} value of the parameter.
     */
    get(r, s) {
      return this.privMap.getProperty(r, s);
    }
    /**
     * Sets the String value of the parameter specified by name.
     * @member Translations.prototype.set
     * @function
     * @public
     * @param {string} key - The parameter name.
     * @param {string} value - The value of the parameter.
     */
    set(r, s) {
      this.privMap.setProperty(r, s);
    }
  };
  return zr.Translations = e, zr;
}
var jf = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.NoMatchReason = void 0, function(e) {
    e[e.NotRecognized = 0] = "NotRecognized", e[e.InitialSilenceTimeout = 1] = "InitialSilenceTimeout", e[e.InitialBabbleTimeout = 2] = "InitialBabbleTimeout";
  }(t.NoMatchReason || (t.NoMatchReason = {}));
})(jf);
var jr = {}, yd;
function z0() {
  if (yd)
    return jr;
  yd = 1, Object.defineProperty(jr, "__esModule", { value: !0 }), jr.NoMatchDetails = void 0;
  const t = A(), e = R();
  let n = class xf {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {NoMatchReason} reason - The no-match reason.
     */
    constructor(s) {
      this.privReason = s;
    }
    /**
     * Creates an instance of NoMatchDetails object for the NoMatch SpeechRecognitionResults.
     * @member NoMatchDetails.fromResult
     * @function
     * @public
     * @param {SpeechRecognitionResult | IntentRecognitionResult | TranslationRecognitionResult}
     * result - The recognition result that was not recognized.
     * @returns {NoMatchDetails} The no match details object being created.
     */
    static fromResult(s) {
      const o = t.SimpleSpeechPhrase.fromJSON(s.json, 0);
      let a = e.NoMatchReason.NotRecognized;
      switch (o.RecognitionStatus) {
        case t.RecognitionStatus.BabbleTimeout:
          a = e.NoMatchReason.InitialBabbleTimeout;
          break;
        case t.RecognitionStatus.InitialSilenceTimeout:
          a = e.NoMatchReason.InitialSilenceTimeout;
          break;
        default:
          a = e.NoMatchReason.NotRecognized;
          break;
      }
      return new xf(a);
    }
    /**
     * The reason the recognition was canceled.
     * @member NoMatchDetails.prototype.reason
     * @function
     * @public
     * @returns {NoMatchReason} Specifies the reason canceled.
     */
    get reason() {
      return this.privReason;
    }
  };
  return jr.NoMatchDetails = n, jr;
}
var ca = {};
Object.defineProperty(ca, "__esModule", { value: !0 });
ca.TranslationRecognitionCanceledEventArgs = void 0;
class j0 {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {string} sessionid - The session id.
   * @param {CancellationReason} cancellationReason - The cancellation reason.
   * @param {string} errorDetails - Error details, if provided.
   * @param {TranslationRecognitionResult} result - The result.
   */
  constructor(e, n, r, s, o) {
    this.privCancelReason = n, this.privErrorDetails = r, this.privResult = o, this.privSessionId = e, this.privErrorCode = s;
  }
  /**
   * Specifies the recognition result.
   * @member TranslationRecognitionCanceledEventArgs.prototype.result
   * @function
   * @public
   * @returns {TranslationRecognitionResult} the recognition result.
   */
  get result() {
    return this.privResult;
  }
  /**
   * Specifies the session identifier.
   * @member TranslationRecognitionCanceledEventArgs.prototype.sessionId
   * @function
   * @public
   * @returns {string} the session identifier.
   */
  get sessionId() {
    return this.privSessionId;
  }
  /**
   * The reason the recognition was canceled.
   * @member TranslationRecognitionCanceledEventArgs.prototype.reason
   * @function
   * @public
   * @returns {CancellationReason} Specifies the reason canceled.
   */
  get reason() {
    return this.privCancelReason;
  }
  /**
   * The error code in case of an unsuccessful recognition.
   * Added in version 1.1.0.
   * @return An error code that represents the error reason.
   */
  get errorCode() {
    return this.privErrorCode;
  }
  /**
   * In case of an unsuccessful recognition, provides details of the occurred error.
   * @member TranslationRecognitionCanceledEventArgs.prototype.errorDetails
   * @function
   * @public
   * @returns {string} A String that represents the error details.
   */
  get errorDetails() {
    return this.privErrorDetails;
  }
}
ca.TranslationRecognitionCanceledEventArgs = j0;
var xr = {}, Cd;
function x0() {
  if (Cd)
    return xr;
  Cd = 1, Object.defineProperty(xr, "__esModule", { value: !0 }), xr.IntentRecognitionCanceledEventArgs = void 0;
  const t = R();
  let e = class extends t.IntentRecognitionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {CancellationReason} result - The result of the intent recognition.
     * @param {string} offset - The offset.
     * @param {IntentRecognitionResult} sessionId - The session id.
     */
    constructor(r, s, o, a, i, c) {
      super(a, i, c), this.privReason = r, this.privErrorDetails = s, this.privErrorCode = o;
    }
    /**
     * The reason the recognition was canceled.
     * @member IntentRecognitionCanceledEventArgs.prototype.reason
     * @function
     * @public
     * @returns {CancellationReason} Specifies the reason canceled.
     */
    get reason() {
      return this.privReason;
    }
    /**
     * The error code in case of an unsuccessful recognition.
     * Added in version 1.1.0.
     * @return An error code that represents the error reason.
     */
    get errorCode() {
      return this.privErrorCode;
    }
    /**
     * In case of an unsuccessful recognition, provides details of the occurred error.
     * @member IntentRecognitionCanceledEventArgs.prototype.errorDetails
     * @function
     * @public
     * @returns {string} A String that represents the error details.
     */
    get errorDetails() {
      return this.privErrorDetails;
    }
  };
  return xr.IntentRecognitionCanceledEventArgs = e, xr;
}
var _s = {};
Object.defineProperty(_s, "__esModule", { value: !0 });
_s.CancellationDetailsBase = void 0;
class B0 {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {CancellationReason} reason - The cancellation reason.
   * @param {string} errorDetails - The error details, if provided.
   */
  constructor(e, n, r) {
    this.privReason = e, this.privErrorDetails = n, this.privErrorCode = r;
  }
  /**
   * The reason the recognition was canceled.
   * @member CancellationDetailsBase.prototype.reason
   * @function
   * @public
   * @returns {CancellationReason} Specifies the reason canceled.
   */
  get reason() {
    return this.privReason;
  }
  /**
   * In case of an unsuccessful recognition, provides details of the occurred error.
   * @member CancellationDetailsBase.prototype.errorDetails
   * @function
   * @public
   * @returns {string} A String that represents the error details.
   */
  get errorDetails() {
    return this.privErrorDetails;
  }
  /**
   * The error code in case of an unsuccessful recognition.
   * Added in version 1.1.0.
   * @return An error code that represents the error reason.
   */
  get ErrorCode() {
    return this.privErrorCode;
  }
}
_s.CancellationDetailsBase = B0;
var Br = {}, _d;
function q0() {
  if (_d)
    return Br;
  _d = 1, Object.defineProperty(Br, "__esModule", { value: !0 }), Br.CancellationDetails = void 0;
  const t = A(), e = _s, n = R();
  let r = class Bf extends e.CancellationDetailsBase {
    constructor(o, a, i) {
      super(o, a, i);
    }
    /**
     * Creates an instance of CancellationDetails object for the canceled RecognitionResult.
     * @member CancellationDetails.fromResult
     * @function
     * @public
     * @param {RecognitionResult | SpeechSynthesisResult} result - The result that was canceled.
     * @returns {CancellationDetails} The cancellation details object being created.
     */
    static fromResult(o) {
      let a = n.CancellationReason.Error, i = n.CancellationErrorCode.NoError;
      if (o instanceof n.RecognitionResult && o.json) {
        const c = t.SimpleSpeechPhrase.fromJSON(o.json, 0);
        a = t.EnumTranslation.implTranslateCancelResult(c.RecognitionStatus);
      }
      return o.properties && (i = n.CancellationErrorCode[o.properties.getProperty(t.CancellationErrorCodePropertyName, n.CancellationErrorCode[n.CancellationErrorCode.NoError])]), new Bf(a, o.errorDetails || t.EnumTranslation.implTranslateErrorDetails(i), i);
    }
  };
  return Br.CancellationDetails = r, Br;
}
var qf = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.CancellationErrorCode = void 0, function(e) {
    e[e.NoError = 0] = "NoError", e[e.AuthenticationFailure = 1] = "AuthenticationFailure", e[e.BadRequestParameters = 2] = "BadRequestParameters", e[e.TooManyRequests = 3] = "TooManyRequests", e[e.ConnectionFailure = 4] = "ConnectionFailure", e[e.ServiceTimeout = 5] = "ServiceTimeout", e[e.ServiceError = 6] = "ServiceError", e[e.RuntimeError = 7] = "RuntimeError", e[e.Forbidden = 8] = "Forbidden";
  }(t.CancellationErrorCode || (t.CancellationErrorCode = {}));
})(qf);
var qr = {}, Rd;
function F0() {
  if (Rd)
    return qr;
  Rd = 1, Object.defineProperty(qr, "__esModule", { value: !0 }), qr.ConnectionEventArgs = void 0;
  const t = R();
  let e = class extends t.SessionEventArgs {
  };
  return qr.ConnectionEventArgs = e, qr;
}
var Fr = {}, Pd;
function $0() {
  if (Pd)
    return Fr;
  Pd = 1, Object.defineProperty(Fr, "__esModule", { value: !0 }), Fr.ServiceEventArgs = void 0;
  const t = R();
  let e = class extends t.SessionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} json - json payload of the USP message.
     */
    constructor(r, s, o) {
      super(o), this.privJsonResult = r, this.privEventName = s;
    }
    get jsonString() {
      return this.privJsonResult;
    }
    get eventName() {
      return this.privEventName;
    }
  };
  return Fr.ServiceEventArgs = e, Fr;
}
var ua = {};
Object.defineProperty(ua, "__esModule", { value: !0 });
ua.PhraseListGrammar = void 0;
class Nu {
  constructor(e) {
    this.privGrammerBuilder = e.dynamicGrammar;
  }
  /**
   * Creates a PhraseListGrammar from a given speech recognizer. Will accept any recognizer that derives from @class Recognizer.
   * @param recognizer The recognizer to add phrase lists to.
   */
  static fromRecognizer(e) {
    const n = e.internalData;
    return new Nu(n);
  }
  /**
   * Adds a single phrase to the current recognizer.
   * @param phrase Phrase to add.
   */
  addPhrase(e) {
    this.privGrammerBuilder.addPhrase(e);
  }
  /**
   * Adds multiple phrases to the current recognizer.
   * @param phrases Array of phrases to add.
   */
  addPhrases(e) {
    this.privGrammerBuilder.addPhrase(e);
  }
  /**
   * Clears all phrases added to the current recognizer.
   */
  clear() {
    this.privGrammerBuilder.clearPhrases();
  }
}
ua.PhraseListGrammar = Nu;
var Qt = {}, Ed;
function Lu() {
  if (Ed)
    return Qt;
  Ed = 1, Object.defineProperty(Qt, "__esModule", { value: !0 }), Qt.DialogServiceConfigImpl = Qt.DialogServiceConfig = void 0;
  const t = N, e = R();
  let n = class {
    /**
     * Creates an instance of DialogService config.
     * @constructor
     */
    constructor() {
    }
    /**
     * Sets the corresponding backend application identifier.
     * @member DialogServiceConfig.prototype.Conversation_ApplicationId
     * @function
     * @public
     * @param {string} value - The application identifier to set.
     */
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    set applicationId(o) {
    }
    static get DialogTypes() {
      return {
        BotFramework: "bot_framework",
        CustomCommands: "custom_commands"
      };
    }
  };
  Qt.DialogServiceConfig = n;
  class r extends n {
    /**
     * Creates an instance of dialogService config.
     */
    constructor() {
      super(), this.privSpeechConfig = new e.SpeechConfigImpl();
    }
    /**
     * Provides access to custom properties.
     * @member DialogServiceConfigImpl.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The properties.
     */
    get properties() {
      return this.privSpeechConfig.properties;
    }
    /**
     * Gets the speech recognition language.
     * @member DialogServiceConfigImpl.prototype.speechRecognitionLanguage
     * @function
     * @public
     */
    get speechRecognitionLanguage() {
      return this.privSpeechConfig.speechRecognitionLanguage;
    }
    /**
     * Sets the speech recognition language.
     * @member DialogServiceConfigImpl.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @param {string} value - The language to set.
     */
    set speechRecognitionLanguage(o) {
      t.Contracts.throwIfNullOrWhitespace(o, "value"), this.privSpeechConfig.speechRecognitionLanguage = o;
    }
    get outputFormat() {
      return this.privSpeechConfig.outputFormat;
    }
    set outputFormat(o) {
      this.privSpeechConfig.outputFormat = o;
    }
    /**
     * Sets a named property as value
     * @member DialogServiceConfigImpl.prototype.setProperty
     * @function
     * @public
     * @param {PropertyId | string} name - The property to set.
     * @param {string} value - The value.
     */
    setProperty(o, a) {
      this.privSpeechConfig.setProperty(o, a);
    }
    /**
     * Sets a named property as value
     * @member DialogServiceConfigImpl.prototype.getProperty
     * @function
     * @public
     * @param {PropertyId | string} name - The property to get.
     * @param {string} def - The default value to return in case the property is not known.
     * @returns {string} The current value, or provided default, of the given property.
     */
    getProperty(o, a) {
      return this.privSpeechConfig.getProperty(o);
    }
    /**
     * Sets the proxy configuration.
     * Only relevant in Node.js environments.
     * Added in version 1.4.0.
     * @param proxyHostName The host name of the proxy server, without the protocol scheme (http://)
     * @param proxyPort The port number of the proxy server.
     * @param proxyUserName The user name of the proxy server.
     * @param proxyPassword The password of the proxy server.
     */
    setProxy(o, a, i, c) {
      this.setProperty(e.PropertyId.SpeechServiceConnection_ProxyHostName, o), this.setProperty(e.PropertyId.SpeechServiceConnection_ProxyPort, `${a}`), i && this.setProperty(e.PropertyId.SpeechServiceConnection_ProxyUserName, i), c && this.setProperty(e.PropertyId.SpeechServiceConnection_ProxyPassword, c);
    }
    setServiceProperty(o, a, i) {
      this.privSpeechConfig.setServiceProperty(o, a);
    }
    /**
     * Dispose of associated resources.
     * @member DialogServiceConfigImpl.prototype.close
     * @function
     * @public
     */
    close() {
    }
  }
  return Qt.DialogServiceConfigImpl = r, Qt;
}
var $r = {}, Td;
function U0() {
  if (Td)
    return $r;
  Td = 1, Object.defineProperty($r, "__esModule", { value: !0 }), $r.BotFrameworkConfig = void 0;
  const t = N, e = Lu(), n = R();
  let r = class extends e.DialogServiceConfigImpl {
    /**
     * Creates an instance of BotFrameworkConfig.
     */
    constructor() {
      super();
    }
    /**
     * Creates a bot framework configuration instance with the provided subscription information.
     * @member BotFrameworkConfig.fromSubscription
     * @function
     * @public
     * @param subscription Subscription key associated with the bot
     * @param region The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @param botId Optional. Identifier for using a specific bot within an Azure resource group. Equivalent to the
     * resource name.
     * @returns {BotFrameworkConfig} A new bot framework configuration instance.
     */
    static fromSubscription(o, a, i) {
      t.Contracts.throwIfNullOrWhitespace(o, "subscription"), t.Contracts.throwIfNullOrWhitespace(a, "region");
      const c = new e.DialogServiceConfigImpl();
      return c.setProperty(n.PropertyId.Conversation_DialogType, e.DialogServiceConfig.DialogTypes.BotFramework), c.setProperty(n.PropertyId.SpeechServiceConnection_Key, o), c.setProperty(n.PropertyId.SpeechServiceConnection_Region, a), i && c.setProperty(n.PropertyId.Conversation_ApplicationId, i), c;
    }
    /**
     * Creates a bot framework configuration instance for the specified authorization token and region.
     * Note: The caller must ensure that an authorization token is valid. Before an authorization token expires, the
     * caller must refresh it by setting the authorizationToken property on the corresponding
     * DialogServiceConnector instance created with this config. The contents of configuration objects are copied
     * when connectors are created, so setting authorizationToken on a DialogServiceConnector will not update the
     * original configuration's authorization token. Create a new configuration instance or set the
     * SpeechServiceAuthorization_Token property to update an existing instance if it will be used to create
     * further DialogServiceConnectors.
     * @member BotFrameworkConfig.fromAuthorizationToken
     * @function
     * @public
     * @param authorizationToken The authorization token associated with the bot
     * @param region The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @param botId Optional. Identifier for using a specific bot within an Azure resource group. Equivalent to the
     * resource name.
     * @returns {BotFrameworkConfig} A new bot framework configuration instance.
     */
    static fromAuthorizationToken(o, a, i) {
      t.Contracts.throwIfNullOrWhitespace(o, "authorizationToken"), t.Contracts.throwIfNullOrWhitespace(a, "region");
      const c = new e.DialogServiceConfigImpl();
      return c.setProperty(n.PropertyId.Conversation_DialogType, e.DialogServiceConfig.DialogTypes.BotFramework), c.setProperty(n.PropertyId.SpeechServiceAuthorization_Token, o), c.setProperty(n.PropertyId.SpeechServiceConnection_Region, a), i && c.setProperty(n.PropertyId.Conversation_ApplicationId, i), c;
    }
    /**
     * Creates an instance of a BotFrameworkConfig.
     * This method is intended only for users who use a non-default service host. The standard resource path will be
     * assumed. For services with a non-standard resource path or no path at all, use fromEndpoint instead.
     * Note: Query parameters are not allowed in the host URI and must be set by other APIs.
     * Note: To use an authorization token with fromHost, use fromHost(URL) and then set the AuthorizationToken
     * property on the created BotFrameworkConfig instance.
     * Note: Added in version 1.15.0.
     * @member BotFrameworkConfig.fromHost
     * @function
     * @public
     * @param {URL | string} host - If a URL is provided, the fully-qualified host with protocol (e.g.
     * wss://your.host.com:1234) will be used. If a string is provided, it will be embedded in
     * wss://{host}.convai.speech.azure.us.
     * @param {string} subscriptionKey - The subscription key. If a subscription key is not specified, an authorization
     * token must be set.
     * @param botId Optional. Identifier for using a specific bot within an Azure resource group. Equivalent to the
     * resource name.
     * @returns {BotFrameworkConfig} A new bot framework configuration instance.
     */
    static fromHost(o, a, i) {
      t.Contracts.throwIfNullOrUndefined(o, "host");
      const c = o instanceof URL ? o : new URL(`wss://${o}.convai.speech.azure.us`);
      t.Contracts.throwIfNullOrUndefined(c, "resolvedHost");
      const u = new e.DialogServiceConfigImpl();
      return u.setProperty(n.PropertyId.Conversation_DialogType, e.DialogServiceConfig.DialogTypes.BotFramework), u.setProperty(n.PropertyId.SpeechServiceConnection_Host, c.toString()), a !== void 0 && u.setProperty(n.PropertyId.SpeechServiceConnection_Key, a), u;
    }
    /**
     * Creates an instance of a BotFrameworkConfig.
     * This method is intended only for users who use a non-standard service endpoint or parameters.
     * Note: The query parameters specified in the endpoint URL are not changed, even if they are set by any other APIs.
     * Note: To use authorization token with fromEndpoint, pass an empty string to the subscriptionKey in the
     * fromEndpoint method, and then set authorizationToken="token" on the created BotFrameworkConfig instance to
     * use the authorization token.
     * Note: Added in version 1.15.0.
     * @member BotFrameworkConfig.fromEndpoint
     * @function
     * @public
     * @param {URL} endpoint - The service endpoint to connect to.
     * @param {string} subscriptionKey - The subscription key. If a subscription key is not specified, an authorization
     * token must be set.
     * @returns {BotFrameworkConfig} - A new bot framework configuration instance using the provided endpoint.
     */
    static fromEndpoint(o, a) {
      t.Contracts.throwIfNull(o, "endpoint");
      const i = new e.DialogServiceConfigImpl();
      return i.setProperty(n.PropertyId.Conversation_DialogType, e.DialogServiceConfig.DialogTypes.BotFramework), i.setProperty(n.PropertyId.SpeechServiceConnection_Endpoint, o.toString()), a !== void 0 && i.setProperty(n.PropertyId.SpeechServiceConnection_Key, a), i;
    }
  };
  return $r.BotFrameworkConfig = r, $r;
}
var Ur = {}, Id;
function H0() {
  if (Id)
    return Ur;
  Id = 1, Object.defineProperty(Ur, "__esModule", { value: !0 }), Ur.CustomCommandsConfig = void 0;
  const t = N, e = Lu(), n = R();
  let r = class extends e.DialogServiceConfigImpl {
    /**
     * Creates an instance of CustomCommandsConfig.
     */
    constructor() {
      super();
    }
    /**
     * Creates an instance of the bot framework config with the specified subscription and region.
     * @member CustomCommandsConfig.fromSubscription
     * @function
     * @public
     * @param applicationId Speech Commands application id.
     * @param subscription Subscription key associated with the bot
     * @param region The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {CustomCommandsConfig} A new bot framework config.
     */
    static fromSubscription(o, a, i) {
      t.Contracts.throwIfNullOrWhitespace(o, "applicationId"), t.Contracts.throwIfNullOrWhitespace(a, "subscription"), t.Contracts.throwIfNullOrWhitespace(i, "region");
      const c = new e.DialogServiceConfigImpl();
      return c.setProperty(n.PropertyId.Conversation_DialogType, e.DialogServiceConfig.DialogTypes.CustomCommands), c.setProperty(n.PropertyId.Conversation_ApplicationId, o), c.setProperty(n.PropertyId.SpeechServiceConnection_Key, a), c.setProperty(n.PropertyId.SpeechServiceConnection_Region, i), c;
    }
    /**
     * Creates an instance of the bot framework config with the specified Speech Commands application id, authorization token and region.
     * Note: The caller needs to ensure that the authorization token is valid. Before the authorization token
     * expires, the caller needs to refresh it by calling this setter with a new valid token.
     * As configuration values are copied when creating a new recognizer, the new token value will not apply to recognizers that have already been created.
     * For recognizers that have been created before, you need to set authorization token of the corresponding recognizer
     * to refresh the token. Otherwise, the recognizers will encounter errors during recognition.
     * @member CustomCommandsConfig.fromAuthorizationToken
     * @function
     * @public
     * @param applicationId Speech Commands application id.
     * @param authorizationToken The authorization token associated with the application.
     * @param region The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {CustomCommandsConfig} A new speech commands config.
     */
    static fromAuthorizationToken(o, a, i) {
      t.Contracts.throwIfNullOrWhitespace(o, "applicationId"), t.Contracts.throwIfNullOrWhitespace(a, "authorizationToken"), t.Contracts.throwIfNullOrWhitespace(i, "region");
      const c = new e.DialogServiceConfigImpl();
      return c.setProperty(n.PropertyId.Conversation_DialogType, e.DialogServiceConfig.DialogTypes.CustomCommands), c.setProperty(n.PropertyId.Conversation_ApplicationId, o), c.setProperty(n.PropertyId.SpeechServiceAuthorization_Token, a), c.setProperty(n.PropertyId.SpeechServiceConnection_Region, i), c;
    }
    /**
     * Sets the corresponding backend application identifier.
     * @member CustomCommandsConfig.prototype.Conversation_ApplicationId
     * @function
     * @public
     * @param {string} value - The application identifier to set.
     */
    set applicationId(o) {
      t.Contracts.throwIfNullOrWhitespace(o, "value"), this.setProperty(n.PropertyId.Conversation_ApplicationId, o);
    }
    /**
     * Gets the corresponding backend application identifier.
     * @member CustomCommandsConfig.prototype.Conversation_ApplicationId
     * @function
     * @public
     * @param {string} value - The application identifier to get.
     */
    get applicationId() {
      return this.getProperty(n.PropertyId.Conversation_ApplicationId);
    }
  };
  return Ur.CustomCommandsConfig = r, Ur;
}
var Hr = {}, Wr = {}, Vr = {}, st = {};
Object.defineProperty(st, "__esModule", { value: !0 });
st.QueryParameterNames = void 0;
class ae {
}
st.QueryParameterNames = ae;
ae.BotId = "botid";
ae.CustomSpeechDeploymentId = "cid";
ae.CustomVoiceDeploymentId = "deploymentId";
ae.EnableAudioLogging = "storeAudio";
ae.EnableLanguageId = "lidEnabled";
ae.EnableWordLevelTimestamps = "wordLevelTimestamps";
ae.EndSilenceTimeoutMs = "endSilenceTimeoutMs";
ae.SegmentationSilenceTimeoutMs = "segmentationSilenceTimeoutMs";
ae.SegmentationMaximumTimeMs = "segmentationMaximumTimeMs";
ae.SegmentationStrategy = "segmentationStrategy";
ae.Format = "format";
ae.InitialSilenceTimeoutMs = "initialSilenceTimeoutMs";
ae.Language = "language";
ae.Profanity = "profanity";
ae.RequestBotStatusMessages = "enableBotMessageStatus";
ae.StableIntermediateThreshold = "stableIntermediateThreshold";
ae.StableTranslation = "stableTranslation";
ae.TestHooks = "testhooks";
ae.Postprocessing = "postprocessing";
ae.CtsMeetingId = "meetingId";
ae.CtsDeviceId = "deviceId";
ae.CtsIsParticipant = "isParticipant";
ae.EnableAvatar = "enableTalkingAvatar";
var wd;
function ot() {
  if (wd)
    return Vr;
  wd = 1, Object.defineProperty(Vr, "__esModule", { value: !0 }), Vr.ConnectionFactoryBase = void 0;
  const t = A(), e = R(), n = st;
  let r = class {
    static getHostSuffix(o) {
      if (o) {
        if (o.toLowerCase().startsWith("china"))
          return ".azure.cn";
        if (o.toLowerCase().startsWith("usgov"))
          return ".azure.us";
      }
      return ".microsoft.com";
    }
    setCommonUrlParams(o, a, i) {
      (/* @__PURE__ */ new Map([
        [e.PropertyId.Speech_SegmentationSilenceTimeoutMs, n.QueryParameterNames.SegmentationSilenceTimeoutMs],
        [e.PropertyId.SpeechServiceConnection_EnableAudioLogging, n.QueryParameterNames.EnableAudioLogging],
        [e.PropertyId.SpeechServiceConnection_EndSilenceTimeoutMs, n.QueryParameterNames.EndSilenceTimeoutMs],
        [e.PropertyId.SpeechServiceConnection_InitialSilenceTimeoutMs, n.QueryParameterNames.InitialSilenceTimeoutMs],
        [e.PropertyId.SpeechServiceResponse_PostProcessingOption, n.QueryParameterNames.Postprocessing],
        [e.PropertyId.SpeechServiceResponse_ProfanityOption, n.QueryParameterNames.Profanity],
        [e.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, n.QueryParameterNames.EnableWordLevelTimestamps],
        [e.PropertyId.SpeechServiceResponse_StablePartialResultThreshold, n.QueryParameterNames.StableIntermediateThreshold]
      ])).forEach((p, d) => {
        this.setUrlParameter(d, p, o, a, i);
      });
      const u = JSON.parse(o.parameters.getProperty(t.ServicePropertiesPropertyName, "{}"));
      Object.keys(u).forEach((p) => {
        a[p] = u[p];
      });
    }
    setUrlParameter(o, a, i, c, u) {
      const p = i.parameters.getProperty(o, void 0);
      p && (!u || u.search(a) === -1) && (c[a] = p.toLocaleLowerCase());
    }
  };
  return Vr.ConnectionFactoryBase = r, Vr;
}
var bd;
function W0() {
  if (bd)
    return Wr;
  bd = 1, Object.defineProperty(Wr, "__esModule", { value: !0 }), Wr.DialogConnectionFactory = void 0;
  const t = ye(), e = A(), n = R(), r = ot(), s = A(), o = Se, a = st;
  class i extends r.ConnectionFactoryBase {
    create(u, p, d) {
      const l = u.parameters.getProperty(n.PropertyId.Conversation_ApplicationId, ""), h = u.parameters.getProperty(n.PropertyId.Conversation_DialogType), v = u.parameters.getProperty(n.PropertyId.SpeechServiceConnection_Region), g = u.parameters.getProperty(n.PropertyId.SpeechServiceConnection_RecoLanguage, "en-US"), f = u.parameters.getProperty(n.PropertyId.Conversation_Request_Bot_Status_Messages, "true"), m = {};
      m[o.HeaderNames.ConnectionId] = d, m[a.QueryParameterNames.Format] = u.parameters.getProperty(e.OutputFormatPropertyName, n.OutputFormat[n.OutputFormat.Simple]).toLowerCase(), m[a.QueryParameterNames.Language] = g, m[a.QueryParameterNames.RequestBotStatusMessages] = f, l && (m[a.QueryParameterNames.BotId] = l, h === n.DialogServiceConfig.DialogTypes.CustomCommands && (m[o.HeaderNames.CustomCommandsAppId] = l));
      const S = h === n.DialogServiceConfig.DialogTypes.CustomCommands ? "commands/" : "", y = h === n.DialogServiceConfig.DialogTypes.CustomCommands ? "v1" : h === n.DialogServiceConfig.DialogTypes.BotFramework ? "v3" : "v0", P = {};
      p.token != null && p.token !== "" && (P[p.headerName] = p.token);
      let C = u.parameters.getProperty(n.PropertyId.SpeechServiceConnection_Endpoint, "");
      if (!C) {
        const w = r.ConnectionFactoryBase.getHostSuffix(v), T = u.parameters.getProperty(n.PropertyId.SpeechServiceConnection_Host, `wss://${v}.${i.BaseUrl}${w}`);
        C = `${T.endsWith("/") ? T : T + "/"}${S}${i.ApiKey}/${y}`;
      }
      this.setCommonUrlParams(u, m, C);
      const _ = u.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
      return new t.WebsocketConnection(C, m, P, new s.WebsocketMessageFormatter(), t.ProxyInfo.fromRecognizerConfig(u), _, d);
    }
  }
  return Wr.DialogConnectionFactory = i, i.ApiKey = "api", i.BaseUrl = "convai.speech", Wr;
}
var Ad;
function V0() {
  if (Ad)
    return Hr;
  Ad = 1, Object.defineProperty(Hr, "__esModule", { value: !0 }), Hr.DialogServiceConnector = void 0;
  const t = W0(), e = A(), n = k(), r = N, s = R(), o = aa;
  let a = class extends s.Recognizer {
    /**
     * Initializes an instance of the DialogServiceConnector.
     * @constructor
     * @param {DialogServiceConfig} dialogConfig - Set of properties to configure this recognizer.
     * @param {AudioConfig} audioConfig - An optional audio config associated with the recognizer
     */
    constructor(c, u) {
      const p = c;
      r.Contracts.throwIfNull(c, "dialogConfig"), super(u, p.properties, new t.DialogConnectionFactory()), this.isTurnComplete = !0, this.privIsDisposed = !1, this.privProperties = p.properties.clone();
      const d = this.buildAgentConfig();
      this.privReco.agentConfig.set(d);
    }
    /**
     * Starts a connection to the service.
     * Users can optionally call connect() to manually set up a connection in advance, before starting interactions.
     *
     * Note: On return, the connection might not be ready yet. Please subscribe to the Connected event to
     * be notified when the connection is established.
     * @member DialogServiceConnector.prototype.connect
     * @function
     * @public
     */
    connect(c, u) {
      n.marshalPromiseToCallbacks(this.privReco.connect(), c, u);
    }
    /**
     * Closes the connection the service.
     * Users can optionally call disconnect() to manually shutdown the connection of the associated DialogServiceConnector.
     *
     * If disconnect() is called during a recognition, recognition will fail and cancel with an error.
     */
    disconnect(c, u) {
      n.marshalPromiseToCallbacks(this.privReco.disconnect(), c, u);
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member DialogServiceConnector.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(o.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Sets the authorization token used to communicate with the service.
     * @member DialogServiceConnector.prototype.authorizationToken
     * @function
     * @public
     * @param {string} token - Authorization token.
     */
    set authorizationToken(c) {
      r.Contracts.throwIfNullOrWhitespace(c, "token"), this.properties.setProperty(o.PropertyId.SpeechServiceAuthorization_Token, c);
    }
    /**
     * The collection of properties and their values defined for this DialogServiceConnector.
     * @member DialogServiceConnector.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this DialogServiceConnector.
     */
    get properties() {
      return this.privProperties;
    }
    /** Gets the template for the activity generated by service from speech.
     * Properties from the template will be stamped on the generated activity.
     * It can be empty
     */
    get speechActivityTemplate() {
      return this.properties.getProperty(o.PropertyId.Conversation_Speech_Activity_Template);
    }
    /** Sets the template for the activity generated by service from speech.
     * Properties from the template will be stamped on the generated activity.
     * It can be null or empty.
     * Note: it has to be a valid Json object.
     */
    set speechActivityTemplate(c) {
      this.properties.setProperty(o.PropertyId.Conversation_Speech_Activity_Template, c);
    }
    /**
     * Starts recognition and stops after the first utterance is recognized.
     * @member DialogServiceConnector.prototype.listenOnceAsync
     * @function
     * @public
     * @param cb - Callback that received the result when the reco has completed.
     * @param err - Callback invoked in case of an error.
     */
    listenOnceAsync(c, u) {
      if (this.isTurnComplete) {
        r.Contracts.throwIfDisposed(this.privIsDisposed);
        const d = (async () => {
          await this.privReco.connect(), await this.implRecognizerStop(), this.isTurnComplete = !1;
          const l = new n.Deferred();
          await this.privReco.recognize(e.RecognitionMode.Conversation, l.resolve, l.reject);
          const h = await l.promise;
          return await this.implRecognizerStop(), h;
        })();
        d.catch(() => {
          this.dispose(!0).catch(() => {
          });
        }), n.marshalPromiseToCallbacks(d.finally(() => {
          this.isTurnComplete = !0;
        }), c, u);
      }
    }
    sendActivityAsync(c, u, p) {
      n.marshalPromiseToCallbacks(this.privReco.sendMessage(c), u, p);
    }
    /**
     * closes all external resources held by an instance of this class.
     * @member DialogServiceConnector.prototype.close
     * @function
     * @public
     */
    close(c, u) {
      r.Contracts.throwIfDisposed(this.privIsDisposed), n.marshalPromiseToCallbacks(this.dispose(!0), c, u);
    }
    async dispose(c) {
      this.privIsDisposed || c && (this.privIsDisposed = !0, await this.implRecognizerStop(), await super.dispose(c));
    }
    createRecognizerConfig(c) {
      return new e.RecognizerConfig(c, this.privProperties);
    }
    createServiceRecognizer(c, u, p, d) {
      const l = p;
      return new e.DialogServiceAdapter(c, u, l, d, this);
    }
    buildAgentConfig() {
      return {
        botInfo: {
          commType: this.properties.getProperty("Conversation_Communication_Type", "Default"),
          commandsCulture: void 0,
          connectionId: this.properties.getProperty(o.PropertyId.Conversation_Agent_Connection_Id),
          conversationId: this.properties.getProperty(o.PropertyId.Conversation_Conversation_Id, void 0),
          fromId: this.properties.getProperty(o.PropertyId.Conversation_From_Id, void 0),
          ttsAudioFormat: this.properties.getProperty(o.PropertyId.SpeechServiceConnection_SynthOutputFormat, void 0)
        },
        version: 0.2
      };
    }
  };
  return Hr.DialogServiceConnector = a, Hr;
}
var pa = {};
Object.defineProperty(pa, "__esModule", { value: !0 });
pa.ActivityReceivedEventArgs = void 0;
class K0 {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {any} activity - The activity..
   */
  constructor(e, n) {
    this.privActivity = e, this.privAudioStream = n;
  }
  /**
   * Gets the received activity
   * @member ActivityReceivedEventArgs.prototype.activity
   * @function
   * @public
   * @returns {any} the received activity.
   */
  get activity() {
    return this.privActivity;
  }
  get audioStream() {
    return this.privAudioStream;
  }
}
pa.ActivityReceivedEventArgs = K0;
var da = {}, la = {};
Object.defineProperty(la, "__esModule", { value: !0 });
la.TurnStatusResponsePayload = void 0;
class zu {
  constructor(e) {
    this.privMessageStatusResponse = JSON.parse(e);
  }
  static fromJSON(e) {
    return new zu(e);
  }
  get interactionId() {
    return this.privMessageStatusResponse.interactionId;
  }
  get conversationId() {
    return this.privMessageStatusResponse.conversationId;
  }
  get statusCode() {
    switch (this.privMessageStatusResponse.statusCode) {
      case "Success":
        return 200;
      case "Failed":
        return 400;
      case "TimedOut":
        return 429;
      default:
        return this.privMessageStatusResponse.statusCode;
    }
  }
}
la.TurnStatusResponsePayload = zu;
Object.defineProperty(da, "__esModule", { value: !0 });
da.TurnStatusReceivedEventArgs = void 0;
const J0 = la;
class G0 {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {string} turnStatus - The JSON-encoded turn status message.
   */
  constructor(e) {
    this.privTurnStatus = J0.TurnStatusResponsePayload.fromJSON(e);
  }
  /**
   * Gets the interaction identifier associated with this turn status event.
   * @member TurnStatusReceivedEventArgs.prototype.interactionId
   * @function
   * @public
   * @returns {any} the received interaction id.
   */
  get interactionId() {
    return this.privTurnStatus.interactionId;
  }
  /**
   * Gets the conversation identifier associated with this turn status event.
   * @member TurnStatusReceivedEventArgs.prototype.conversationId
   * @function
   * @public
   * @returns {any} the received conversation id.
   */
  get conversationId() {
    return this.privTurnStatus.conversationId;
  }
  /**
   * Gets the received turn status code.
   * @member TurnStatusReceivedEventArgs.prototype.statusCode
   * @function
   * @public
   * @returns {number} the received turn status.
   */
  get statusCode() {
    return this.privTurnStatus.statusCode;
  }
}
da.TurnStatusReceivedEventArgs = G0;
var Ff = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.ServicePropertyChannel = void 0, function(e) {
    e[e.UriQueryParameter = 0] = "UriQueryParameter";
  }(t.ServicePropertyChannel || (t.ServicePropertyChannel = {}));
})(Ff);
var $f = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.ProfanityOption = void 0, function(e) {
    e[e.Masked = 0] = "Masked", e[e.Removed = 1] = "Removed", e[e.Raw = 2] = "Raw";
  }(t.ProfanityOption || (t.ProfanityOption = {}));
})($f);
var Kr = {}, Md;
function Q0() {
  if (Md)
    return Kr;
  Md = 1, Object.defineProperty(Kr, "__esModule", { value: !0 }), Kr.BaseAudioPlayer = void 0;
  const t = Ee, e = R(), n = Wt;
  let r = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {AudioStreamFormat} audioFormat audio stream format recognized by the player.
     */
    constructor(o) {
      this.audioContext = null, this.gainNode = null, this.autoUpdateBufferTimer = 0, o === void 0 && (o = e.AudioStreamFormat.getDefaultInputFormat()), this.init(o);
    }
    /**
     * play Audio sample
     * @param newAudioData audio data to be played.
     */
    playAudioSample(o, a, i) {
      try {
        this.ensureInitializedContext();
        const c = this.formatAudioData(o), u = new Float32Array(this.samples.length + c.length);
        u.set(this.samples, 0), u.set(c, this.samples.length), this.samples = u, a && a();
      } catch (c) {
        i && i(c);
      }
    }
    /**
     * stops audio and clears the buffers
     */
    stopAudio(o, a) {
      this.audioContext !== null && (this.samples = new Float32Array(), clearInterval(this.autoUpdateBufferTimer), this.audioContext.close().then(() => {
        o && o();
      }, (i) => {
        a && a(i);
      }), this.audioContext = null);
    }
    init(o) {
      this.audioFormat = o, this.samples = new Float32Array();
    }
    ensureInitializedContext() {
      if (this.audioContext === null) {
        this.createAudioContext();
        const o = 200;
        this.autoUpdateBufferTimer = setInterval(() => {
          this.updateAudioBuffer();
        }, o);
      }
    }
    createAudioContext() {
      this.audioContext = n.AudioStreamFormatImpl.getAudioContext(), this.gainNode = this.audioContext.createGain(), this.gainNode.gain.value = 1, this.gainNode.connect(this.audioContext.destination), this.startTime = this.audioContext.currentTime;
    }
    formatAudioData(o) {
      switch (this.audioFormat.bitsPerSample) {
        case 8:
          return this.formatArrayBuffer(new Int8Array(o), 128);
        case 16:
          return this.formatArrayBuffer(new Int16Array(o), 32768);
        case 32:
          return this.formatArrayBuffer(new Int32Array(o), 2147483648);
        default:
          throw new t.InvalidOperationError("Only WAVE_FORMAT_PCM (8/16/32 bps) format supported at this time");
      }
    }
    formatArrayBuffer(o, a) {
      const i = new Float32Array(o.length);
      for (let c = 0; c < o.length; c++)
        i[c] = o[c] / a;
      return i;
    }
    updateAudioBuffer() {
      if (this.samples.length === 0)
        return;
      const o = this.audioFormat.channels, a = this.audioContext.createBufferSource(), i = this.samples.length / o, c = this.audioContext.createBuffer(o, i, this.audioFormat.samplesPerSec);
      for (let u = 0; u < o; u++) {
        let p = u;
        const d = c.getChannelData(u);
        for (let l = 0; l < this.samples.length; l++, p += o)
          d[l] = this.samples[p];
      }
      this.startTime < this.audioContext.currentTime && (this.startTime = this.audioContext.currentTime), a.buffer = c, a.connect(this.gainNode), a.start(this.startTime), this.startTime += c.duration, this.samples = new Float32Array();
    }
    async playAudio(o) {
      this.audioContext === null && this.createAudioContext();
      const a = this.audioContext.createBufferSource(), i = this.audioContext.destination;
      await this.audioContext.decodeAudioData(o, (c) => {
        a.buffer = c, a.connect(i), a.start(0);
      });
    }
  };
  return Kr.BaseAudioPlayer = r, Kr;
}
var ha = {};
Object.defineProperty(ha, "__esModule", { value: !0 });
ha.ConnectionMessageEventArgs = void 0;
class Y0 {
  constructor(e) {
    this.privConnectionMessage = e;
  }
  /**
   * Gets the <see cref="ConnectionMessage"/> associated with this <see cref="ConnectionMessageEventArgs"/>.
   */
  get message() {
    return this.privConnectionMessage;
  }
  /**
   * Returns a string that represents the connection message event.
   */
  toString() {
    return "Message: " + this.privConnectionMessage.toString();
  }
}
ha.ConnectionMessageEventArgs = Y0;
var va = {};
Object.defineProperty(va, "__esModule", { value: !0 });
va.VoiceProfile = void 0;
class Z0 {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {string} profileId - profileId of this Voice Profile.
   * @param {VoiceProfileType} profileType - profileType of this Voice Profile.
   */
  constructor(e, n) {
    this.privId = e, this.privProfileType = n;
  }
  /**
   * profileId of this Voice Profile instance
   * @member VoiceProfile.prototype.profileId
   * @function
   * @public
   * @returns {string} profileId of this Voice Profile instance.
   */
  get profileId() {
    return this.privId;
  }
  /**
   * profileType of this Voice Profile instance
   * @member VoiceProfile.prototype.profileType
   * @function
   * @public
   * @returns {VoiceProfileType} profile type of this Voice Profile instance.
   */
  get profileType() {
    return this.privProfileType;
  }
}
va.VoiceProfile = Z0;
var Yt = {}, kd;
function X0() {
  if (kd)
    return Yt;
  kd = 1, Object.defineProperty(Yt, "__esModule", { value: !0 }), Yt.VoiceProfileEnrollmentCancellationDetails = Yt.VoiceProfileEnrollmentResult = void 0;
  const t = A(), e = R();
  let n = class Gc {
    constructor(o, a, i) {
      this.privReason = o, this.privProperties = new e.PropertyCollection(), this.privReason !== e.ResultReason.Canceled ? a && (this.privDetails = JSON.parse(a), this.privDetails.enrollmentStatus.toLowerCase() === "enrolling" && (this.privReason = e.ResultReason.EnrollingVoiceProfile)) : (this.privErrorDetails = i, this.privProperties.setProperty(t.CancellationErrorCodePropertyName, e.CancellationErrorCode[e.CancellationErrorCode.ServiceError]));
    }
    get reason() {
      return this.privReason;
    }
    get enrollmentsCount() {
      return this.privDetails.enrollmentsCount;
    }
    get enrollmentsLength() {
      return this.privDetails.enrollmentsLength;
    }
    get properties() {
      return this.privProperties;
    }
    get enrollmentResultDetails() {
      return this.privDetails;
    }
    get errorDetails() {
      return this.privErrorDetails;
    }
    static FromIdentificationProfileList(o) {
      const a = [];
      for (const i of o.value) {
        const c = i.enrollmentStatus.toLowerCase() === "enrolling" ? e.ResultReason.EnrollingVoiceProfile : i.enrollmentStatus.toLowerCase() === "enrolled" ? e.ResultReason.EnrolledVoiceProfile : e.ResultReason.Canceled, u = new Gc(c, null, null);
        u.privDetails = this.getIdentificationDetails(i), a.push(u);
      }
      return a;
    }
    static FromVerificationProfileList(o) {
      const a = [];
      for (const i of o.value) {
        const c = i.enrollmentStatus.toLowerCase() === "enrolling" ? e.ResultReason.EnrollingVoiceProfile : i.enrollmentStatus.toLowerCase() === "enrolled" ? e.ResultReason.EnrolledVoiceProfile : e.ResultReason.Canceled, u = new Gc(c, null, null);
        u.privDetails = this.getVerificationDetails(i), a.push(u);
      }
      return a;
    }
    static getIdentificationDetails(o) {
      return {
        audioLength: o.audioLength ? parseFloat(o.audioLength) : 0,
        audioSpeechLength: o.audioSpeechLength ? parseFloat(o.audioSpeechLength) : 0,
        enrollmentStatus: o.enrollmentStatus,
        enrollmentsCount: o.enrollmentsCount || 0,
        enrollmentsLength: o.enrollmentsLength ? parseFloat(o.enrollmentsLength) : 0,
        enrollmentsSpeechLength: o.enrollmentsSpeechLength ? parseFloat(o.enrollmentsSpeechLength) : 0,
        profileId: o.profileId || o.identificationProfileId,
        remainingEnrollmentsSpeechLength: o.remainingEnrollmentsSpeechLength ? parseFloat(o.remainingEnrollmentsSpeechLength) : 0
      };
    }
    static getVerificationDetails(o) {
      return {
        audioLength: o.audioLength ? parseFloat(o.audioLength) : 0,
        audioSpeechLength: o.audioSpeechLength ? parseFloat(o.audioSpeechLength) : 0,
        enrollmentStatus: o.enrollmentStatus,
        enrollmentsCount: o.enrollmentsCount,
        enrollmentsLength: o.enrollmentsLength ? parseFloat(o.enrollmentsLength) : 0,
        enrollmentsSpeechLength: o.enrollmentsSpeechLength ? parseFloat(o.enrollmentsSpeechLength) : 0,
        profileId: o.profileId || o.verificationProfileId,
        remainingEnrollmentsCount: o.remainingEnrollments || o.remainingEnrollmentsCount,
        remainingEnrollmentsSpeechLength: o.remainingEnrollmentsSpeechLength ? parseFloat(o.remainingEnrollmentsSpeechLength) : 0
      };
    }
  };
  Yt.VoiceProfileEnrollmentResult = n;
  class r extends e.CancellationDetailsBase {
    constructor(o, a, i) {
      super(o, a, i);
    }
    /**
     * Creates an instance of VoiceProfileEnrollmentCancellationDetails object for the canceled VoiceProfileEnrollmentResult.
     * @member VoiceProfileEnrollmentCancellationDetails.fromResult
     * @function
     * @public
     * @param {VoiceProfileEnrollmentResult} result - The result that was canceled.
     * @returns {VoiceProfileEnrollmentCancellationDetails} The cancellation details object being created.
     */
    static fromResult(o) {
      const a = e.CancellationReason.Error;
      let i = e.CancellationErrorCode.NoError;
      return o.properties && (i = e.CancellationErrorCode[o.properties.getProperty(t.CancellationErrorCodePropertyName, e.CancellationErrorCode[e.CancellationErrorCode.NoError])]), new r(a, o.errorDetails, i);
    }
  }
  return Yt.VoiceProfileEnrollmentCancellationDetails = r, Yt;
}
var Zt = {}, Od;
function eR() {
  if (Od)
    return Zt;
  Od = 1, Object.defineProperty(Zt, "__esModule", { value: !0 }), Zt.VoiceProfileCancellationDetails = Zt.VoiceProfileResult = void 0;
  const t = A(), e = N, n = R();
  let r = class {
    constructor(a, i) {
      this.privReason = a, this.privProperties = new n.PropertyCollection(), a === n.ResultReason.Canceled && (e.Contracts.throwIfNullOrUndefined(i, "statusText"), this.privErrorDetails = i, this.privProperties.setProperty(t.CancellationErrorCodePropertyName, n.CancellationErrorCode[n.CancellationErrorCode.ServiceError]));
    }
    get reason() {
      return this.privReason;
    }
    get properties() {
      return this.privProperties;
    }
    get errorDetails() {
      return this.privErrorDetails;
    }
  };
  Zt.VoiceProfileResult = r;
  class s extends n.CancellationDetailsBase {
    constructor(a, i, c) {
      super(a, i, c);
    }
    /**
     * Creates an instance of VoiceProfileCancellationDetails object for the canceled VoiceProfileResult.
     * @member VoiceProfileCancellationDetails.fromResult
     * @function
     * @public
     * @param {VoiceProfileResult} result - The result that was canceled.
     * @returns {VoiceProfileCancellationDetails} The cancellation details object being created.
     */
    static fromResult(a) {
      const i = n.CancellationReason.Error;
      let c = n.CancellationErrorCode.NoError;
      return a.properties && (c = n.CancellationErrorCode[a.properties.getProperty(t.CancellationErrorCodePropertyName, n.CancellationErrorCode[n.CancellationErrorCode.NoError])]), new s(i, a.errorDetails, c);
    }
  }
  return Zt.VoiceProfileCancellationDetails = s, Zt;
}
var Jr = {}, Dd;
function tR() {
  if (Dd)
    return Jr;
  Dd = 1, Object.defineProperty(Jr, "__esModule", { value: !0 }), Jr.VoiceProfilePhraseResult = void 0;
  const t = N, e = R();
  let n = class extends e.VoiceProfileResult {
    constructor(s, o, a, i) {
      super(s, o), this.privPhrases = [], t.Contracts.throwIfNullOrUndefined(i, "phrase array"), this.privType = a, i && i[0] && (this.privPhrases = i);
    }
    get phrases() {
      return this.privPhrases;
    }
    get type() {
      return this.privType;
    }
  };
  return Jr.VoiceProfilePhraseResult = n, Jr;
}
var Gr = {}, Nd;
function nR() {
  if (Nd)
    return Gr;
  Nd = 1, Object.defineProperty(Gr, "__esModule", { value: !0 }), Gr.VoiceProfileClient = void 0;
  const t = A(), e = Pf(), n = N, r = R();
  let s = class extends r.Recognizer {
    /**
     * VoiceProfileClient constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - An set of initial properties for this synthesizer (authentication key, region, &c)
     */
    constructor(a) {
      n.Contracts.throwIfNullOrUndefined(a, "speechConfig");
      const i = a;
      n.Contracts.throwIfNull(i, "speechConfig"), super(e.AudioConfig.fromStreamInput(r.AudioInputStream.createPushStream()), i.properties, new t.VoiceProfileConnectionFactory()), this.privProperties = i.properties.clone(), this.privVoiceAdapter = this.privReco, this.privDisposedVoiceAdapter = !1;
    }
    /**
     * The collection of properties and their values defined for this VoiceProfileClient.
     * @member VoiceProfileClient.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this VoiceProfileClient.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member VoiceProfileClient.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(r.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * @member VoiceProfileClient.prototype.authorizationToken
     * @function
     * @public
     * @param {string} token - Authorization token.
     */
    set authorizationToken(a) {
      n.Contracts.throwIfNullOrWhitespace(a, "token"), this.properties.setProperty(r.PropertyId.SpeechServiceAuthorization_Token, a);
    }
    /**
     * Create a speaker recognition voice profile
     * @member VoiceProfileClient.prototype.createProfileAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfileType} profileType Type of Voice Profile to be created
     * @param {string} lang Language string (locale) for Voice Profile
     * @return {Promise<VoiceProfile>} - Promise of a VoiceProfile.
     */
    async createProfileAsync(a, i) {
      const c = await this.privVoiceAdapter.createProfile(a, i);
      return new r.VoiceProfile(c[0], a);
    }
    /**
     * Get current information of a voice profile
     * @member VoiceProfileClient.prototype.retrieveEnrollmentResultAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfile} profile Voice Profile to retrieve info for
     * @return {Promise<VoiceProfileEnrollmentResult>} - Promise of a VoiceProfileEnrollmentResult.
     */
    async retrieveEnrollmentResultAsync(a) {
      return this.privVoiceAdapter.retrieveEnrollmentResult(a);
    }
    /**
     * Get all voice profiles on account with given voice profile type
     * @member VoiceProfileClient.prototype.getAllProfilesAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfileType} profileType profile type (identification/verification) for which to list profiles
     * @return {Promise<VoiceProfileEnrollmentResult[]>} - Promise of an array of VoiceProfileEnrollmentResults.
     */
    async getAllProfilesAsync(a) {
      return this.privVoiceAdapter.getAllProfiles(a);
    }
    /**
     * Get valid authorization phrases for voice profile enrollment
     * @member VoiceProfileClient.prototype.getActivationPhrasesAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfileType} profileType Profile Type to get activation phrases for
     * @param {string} lang Language string (locale) for Voice Profile
     */
    async getActivationPhrasesAsync(a, i) {
      return this.privVoiceAdapter.getActivationPhrases(a, i);
    }
    /**
     * Create a speaker recognition voice profile
     * @member VoiceProfileClient.prototype.enrollProfileAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfile} profile Voice Profile to create enrollment for
     * @param {AudioConfig} audioConfig source info from which to create enrollment
     * @return {Promise<VoiceProfileEnrollmentResult>} - Promise of a VoiceProfileEnrollmentResult.
     */
    async enrollProfileAsync(a, i) {
      const c = i;
      return n.Contracts.throwIfNullOrUndefined(c, "audioConfig"), this.audioConfig = i, this.privVoiceAdapter.SpeakerAudioSource = c, this.privVoiceAdapter.enrollProfile(a);
    }
    /**
     * Delete a speaker recognition voice profile
     * @member VoiceProfileClient.prototype.deleteProfileAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfile} profile Voice Profile to be deleted
     * @return {Promise<VoiceProfileResult>} - Promise of a VoiceProfileResult.
     */
    async deleteProfileAsync(a) {
      return this.privVoiceAdapter.deleteProfile(a);
    }
    /**
     * Remove all enrollments for a speaker recognition voice profile
     * @member VoiceProfileClient.prototype.resetProfileAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfile} profile Voice Profile to be reset
     * @return {Promise<VoiceProfileResult>} - Promise of a VoiceProfileResult.
     */
    async resetProfileAsync(a) {
      return this.privVoiceAdapter.resetProfile(a);
    }
    /**
     * Clean up object and close underlying connection
     * @member VoiceProfileClient.prototype.close
     * @function
     * @async
     * @public
     */
    async close() {
      await this.dispose(!0);
    }
    createServiceRecognizer(a, i, c, u) {
      const p = c;
      return new t.VoiceServiceRecognizer(a, i, p, u, this);
    }
    async dispose(a) {
      this.privDisposedVoiceAdapter || (this.privDisposedVoiceAdapter = !0, a && await super.dispose(a));
    }
    createRecognizerConfig(a) {
      return new t.RecognizerConfig(a, this.properties);
    }
    getResult(a, i) {
      return new r.VoiceProfileResult(a.ok ? i : r.ResultReason.Canceled, a.statusText);
    }
  };
  return Gr.VoiceProfileClient = s, Gr;
}
var Qr = {}, Ld;
function rR() {
  if (Ld)
    return Qr;
  Ld = 1, Object.defineProperty(Qr, "__esModule", { value: !0 }), Qr.SpeakerRecognizer = void 0;
  const t = A(), e = N, n = R();
  let r = class extends n.Recognizer {
    /**
     * Initializes an instance of the SpeakerRecognizer.
     * @constructor
     * @param {SpeechConfig} speechConfig - The set of configuration properties.
     * @param {AudioConfig} audioConfig - An optional audio input config associated with the recognizer
     */
    constructor(o, a) {
      e.Contracts.throwIfNullOrUndefined(o, "speechConfig");
      const i = o;
      e.Contracts.throwIfNullOrUndefined(i, "speechConfig"), super(a, i.properties, new t.SpeakerRecognitionConnectionFactory()), this.privAudioConfigImpl = a, e.Contracts.throwIfNull(this.privAudioConfigImpl, "audioConfig"), this.privDisposedSpeakerRecognizer = !1, this.privProperties = i.properties;
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member SpeakerRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(n.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * @member SpeakerRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @param {string} token - Authorization token.
     */
    set authorizationToken(o) {
      e.Contracts.throwIfNullOrWhitespace(o, "token"), this.properties.setProperty(n.PropertyId.SpeechServiceAuthorization_Token, o);
    }
    /**
     * The collection of properties and their values defined for this SpeakerRecognizer.
     * @member SpeakerRecognizer.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this SpeakerRecognizer.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Get recognition result for model using given audio
     * @member SpeakerRecognizer.prototype.recognizeOnceAsync
     * @function
     * @public
     * @async
     * @param {SpeakerIdentificationModel | SpeakerVerificationModel} model Model containing Voice Profiles to be identified
     * @param cb - Callback invoked once result is returned.
     * @param err - Callback invoked in case of an error.
     */
    async recognizeOnceAsync(o) {
      return e.Contracts.throwIfDisposed(this.privDisposedSpeakerRecognizer), this.recognizeSpeakerOnceAsyncImpl(o);
    }
    /**
     * Included for compatibility
     * @member SpeakerRecognizer.prototype.close
     * @function
     * @public
     * @async
     */
    async close() {
      e.Contracts.throwIfDisposed(this.privDisposedSpeakerRecognizer), await this.dispose(!0);
    }
    async recognizeSpeakerOnceAsyncImpl(o) {
      e.Contracts.throwIfDisposed(this.privDisposedSpeakerRecognizer), await this.implRecognizerStop();
      const a = await this.privReco.recognizeSpeaker(o);
      return await this.implRecognizerStop(), a;
    }
    async implRecognizerStop() {
      this.privReco && await this.privReco.stopRecognizing();
    }
    createRecognizerConfig(o) {
      return new t.RecognizerConfig(o, this.privProperties);
    }
    createServiceRecognizer(o, a, i, c) {
      const u = i;
      return new t.SpeakerServiceRecognizer(o, a, u, c, this);
    }
    async dispose(o) {
      this.privDisposedSpeakerRecognizer || o && (this.privDisposedSpeakerRecognizer = !0, await super.dispose(o));
    }
  };
  return Qr.SpeakerRecognizer = r, Qr;
}
var Yr = {}, zd;
function iR() {
  if (zd)
    return Yr;
  zd = 1, Object.defineProperty(Yr, "__esModule", { value: !0 }), Yr.SpeakerIdentificationModel = void 0;
  const t = N, e = R();
  let n = class Uf {
    constructor(s) {
      if (this.privVoiceProfiles = [], this.privProfileIds = [], t.Contracts.throwIfNullOrUndefined(s, "VoiceProfiles"), s.length === 0)
        throw new Error("Empty Voice Profiles array");
      for (const o of s) {
        if (o.profileType !== e.VoiceProfileType.TextIndependentIdentification)
          throw new Error("Identification model can only be created from Identification profile: " + o.profileId);
        this.privVoiceProfiles.push(o), this.privProfileIds.push(o.profileId);
      }
    }
    static fromProfiles(s) {
      return new Uf(s);
    }
    get voiceProfileIds() {
      return this.privProfileIds.join(",");
    }
    get profileIds() {
      return this.privProfileIds;
    }
    get scenario() {
      return "TextIndependentIdentification";
    }
  };
  return Yr.SpeakerIdentificationModel = n, Yr;
}
var Zr = {}, jd;
function sR() {
  if (jd)
    return Zr;
  jd = 1, Object.defineProperty(Zr, "__esModule", { value: !0 }), Zr.SpeakerVerificationModel = void 0;
  const t = N, e = R();
  let n = class Hf {
    constructor(s) {
      if (t.Contracts.throwIfNullOrUndefined(s, "VoiceProfile"), s.profileType === e.VoiceProfileType.TextIndependentIdentification)
        throw new Error("Verification model cannot be created from Identification profile");
      this.privVoiceProfile = s;
    }
    static fromProfile(s) {
      return new Hf(s);
    }
    get voiceProfile() {
      return this.privVoiceProfile;
    }
    get profileIds() {
      return [this.voiceProfile.profileId];
    }
    get scenario() {
      return this.voiceProfile.profileType === e.VoiceProfileType.TextDependentVerification ? "TextDependentVerification" : "TextIndependentVerification";
    }
  };
  return Zr.SpeakerVerificationModel = n, Zr;
}
var Xr = {}, ju = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.LanguageIdMode = void 0, function(e) {
    e[e.AtStart = 0] = "AtStart", e[e.Continuous = 1] = "Continuous";
  }(t.LanguageIdMode || (t.LanguageIdMode = {}));
})(ju);
var xd;
function oR() {
  if (xd)
    return Xr;
  xd = 1, Object.defineProperty(Xr, "__esModule", { value: !0 }), Xr.AutoDetectSourceLanguageConfig = void 0;
  const t = A(), e = N, n = R(), r = ju;
  let s = class io {
    constructor() {
      this.privProperties = new n.PropertyCollection(), this.privProperties.setProperty(n.PropertyId.SpeechServiceConnection_LanguageIdMode, "AtStart"), this.privLanguageIdMode = r.LanguageIdMode.AtStart;
    }
    /**
     * @member AutoDetectSourceLanguageConfig.fromOpenRange
     * @function
     * @public
     * Only [[SpeechSynthesizer]] supports source language auto detection from open range,
     * for [[Recognizer]], please use AutoDetectSourceLanguageConfig with specific source languages.
     * @return {AutoDetectSourceLanguageConfig} Instance of AutoDetectSourceLanguageConfig
     * @summary Creates an instance of the AutoDetectSourceLanguageConfig with open range.
     */
    static fromOpenRange() {
      const a = new io();
      return a.properties.setProperty(n.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, t.AutoDetectSourceLanguagesOpenRangeOptionName), a;
    }
    /**
     * @member AutoDetectSourceLanguageConfig.fromLanguages
     * @function
     * @public
     * @param {string[]} languages Comma-separated string of languages (eg. "en-US,fr-FR") to populate properties of config.
     * @return {AutoDetectSourceLanguageConfig} Instance of AutoDetectSourceLanguageConfig
     * @summary Creates an instance of the AutoDetectSourceLanguageConfig with given languages.
     */
    static fromLanguages(a) {
      e.Contracts.throwIfArrayEmptyOrWhitespace(a, "languages");
      const i = new io();
      return i.properties.setProperty(n.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, a.join()), i;
    }
    /**
     * @member AutoDetectSourceLanguageConfig.fromSourceLanguageConfigs
     * @function
     * @public
     * @param {SourceLanguageConfig[]} configs SourceLanguageConfigs to populate properties of config.
     * @return {AutoDetectSourceLanguageConfig} Instance of AutoDetectSourceLanguageConfig
     * @summary Creates an instance of the AutoDetectSourceLanguageConfig with given SourceLanguageConfigs.
     */
    static fromSourceLanguageConfigs(a) {
      if (a.length < 1)
        throw new Error("Expected non-empty SourceLanguageConfig array.");
      const i = new io(), c = [];
      return a.forEach((u) => {
        if (c.push(u.language), u.endpointId !== void 0 && u.endpointId !== "") {
          const p = u.language + n.PropertyId.SpeechServiceConnection_EndpointId.toString();
          i.properties.setProperty(p, u.endpointId);
        }
      }), i.properties.setProperty(n.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, c.join()), i;
    }
    /**
     * @member AutoDetectSourceLanguageConfig.prototype.properties
     * @function
     * @public
     * @return {PropertyCollection} Properties of the config.
     * @summary Gets an auto detected language config properties
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * @member AutoDetectSourceLanguageConfig.prototype.mode
     * @function
     * @public
     * @param {LanguageIdMode} mode LID mode desired.
     * @summary Sets LID operation to desired mode
     */
    set mode(a) {
      a === r.LanguageIdMode.Continuous ? (this.privProperties.setProperty(n.PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, "2"), this.privProperties.setProperty(n.PropertyId.SpeechServiceConnection_LanguageIdMode, "Continuous")) : (this.privProperties.setProperty(n.PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, "1"), this.privProperties.setProperty(n.PropertyId.SpeechServiceConnection_LanguageIdMode, "AtStart")), this.privLanguageIdMode = a;
    }
  };
  return Xr.AutoDetectSourceLanguageConfig = s, Xr;
}
var fa = {};
Object.defineProperty(fa, "__esModule", { value: !0 });
fa.AutoDetectSourceLanguageResult = void 0;
const Bd = N;
class go {
  constructor(e, n) {
    Bd.Contracts.throwIfNullOrUndefined(e, "language"), Bd.Contracts.throwIfNullOrUndefined(n, "languageDetectionConfidence"), this.privLanguage = e, this.privLanguageDetectionConfidence = n;
  }
  /**
   * Creates an instance of AutoDetectSourceLanguageResult object from a SpeechRecognitionResult instance.
   * @member AutoDetectSourceLanguageResult.fromResult
   * @function
   * @public
   * @param {SpeechRecognitionResult} result - The recognition result.
   * @returns {AutoDetectSourceLanguageResult} AutoDetectSourceLanguageResult object being created.
   */
  static fromResult(e) {
    return new go(e.language, e.languageDetectionConfidence);
  }
  /**
   * Creates an instance of AutoDetectSourceLanguageResult object from a ConversationTranscriptionResult instance.
   * @member AutoDetectSourceLanguageResult.fromConversationTranscriptionResult
   * @function
   * @public
   * @param {ConversationTranscriptionResult} result - The transcription result.
   * @returns {AutoDetectSourceLanguageResult} AutoDetectSourceLanguageResult object being created.
   */
  static fromConversationTranscriptionResult(e) {
    return new go(e.language, e.languageDetectionConfidence);
  }
  get language() {
    return this.privLanguage;
  }
  get languageDetectionConfidence() {
    return this.privLanguageDetectionConfidence;
  }
}
fa.AutoDetectSourceLanguageResult = go;
var ga = {};
Object.defineProperty(ga, "__esModule", { value: !0 });
ga.SourceLanguageConfig = void 0;
const aR = N;
class xu {
  constructor(e, n) {
    aR.Contracts.throwIfNullOrUndefined(e, "language"), this.privLanguage = e, this.privEndpointId = n;
  }
  /**
   * @member SourceLanguageConfig.fromLanguage
   * @function
   * @public
   * @param {string} language language (eg. "en-US") value of config.
   * @param {string?} endpointId endpointId of model bound to given language of config.
   * @return {SourceLanguageConfig} Instance of SourceLanguageConfig
   * @summary Creates an instance of the SourceLanguageConfig with the given language and optional endpointId.
   * Added in version 1.13.0.
   */
  static fromLanguage(e, n) {
    return new xu(e, n);
  }
  get language() {
    return this.privLanguage;
  }
  get endpointId() {
    return this.privEndpointId;
  }
}
ga.SourceLanguageConfig = xu;
var yc = {}, qd;
function cR() {
  return qd || (qd = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.SpeakerRecognitionCancellationDetails = t.SpeakerRecognitionResult = t.SpeakerRecognitionResultType = void 0;
    const e = A(), n = R();
    var r;
    (function(a) {
      a[a.Verify = 0] = "Verify", a[a.Identify = 1] = "Identify";
    })(r = t.SpeakerRecognitionResultType || (t.SpeakerRecognitionResultType = {}));
    class s {
      constructor(i, c = n.ResultReason.RecognizedSpeaker, u = n.CancellationErrorCode.NoError, p = "") {
        this.privProperties = new n.PropertyCollection();
        const d = i.scenario === "TextIndependentIdentification" ? r.Identify : r.Verify;
        this.privReason = c, this.privReason !== n.ResultReason.Canceled ? d === r.Identify ? (this.privProfileId = i.identificationResult.identifiedProfile.profileId, this.privScore = i.identificationResult.identifiedProfile.score, this.privReason = n.ResultReason.RecognizedSpeakers) : (this.privScore = i.verificationResult.score, i.verificationResult.recognitionResult.toLowerCase() !== "accept" && (this.privReason = n.ResultReason.NoMatch), i.verificationResult.profileId !== void 0 && i.verificationResult.profileId !== "" && (this.privProfileId = i.verificationResult.profileId)) : (this.privErrorDetails = p, this.privProperties.setProperty(e.CancellationErrorCodePropertyName, n.CancellationErrorCode[u])), this.privProperties.setProperty(n.PropertyId.SpeechServiceResponse_JsonResult, JSON.stringify(i));
      }
      get properties() {
        return this.privProperties;
      }
      get reason() {
        return this.privReason;
      }
      get profileId() {
        return this.privProfileId;
      }
      get errorDetails() {
        return this.privErrorDetails;
      }
      get score() {
        return this.privScore;
      }
    }
    t.SpeakerRecognitionResult = s;
    class o extends n.CancellationDetailsBase {
      constructor(i, c, u) {
        super(i, c, u);
      }
      /**
       * Creates an instance of SpeakerRecognitionCancellationDetails object for the canceled SpeakerRecognitionResult
       * @member SpeakerRecognitionCancellationDetails.fromResult
       * @function
       * @public
       * @param {SpeakerRecognitionResult} result - The result that was canceled.
       * @returns {SpeakerRecognitionCancellationDetails} The cancellation details object being created.
       */
      static fromResult(i) {
        const c = n.CancellationReason.Error;
        let u = n.CancellationErrorCode.NoError;
        return i.properties && (u = n.CancellationErrorCode[i.properties.getProperty(e.CancellationErrorCodePropertyName, n.CancellationErrorCode[n.CancellationErrorCode.NoError])]), new o(c, i.errorDetails, u);
      }
    }
    t.SpeakerRecognitionCancellationDetails = o;
  }(yc)), yc;
}
var Cc = {}, Xt = {}, Fd;
function Wf() {
  if (Fd)
    return Xt;
  Fd = 1, Object.defineProperty(Xt, "__esModule", { value: !0 }), Xt.ConversationImpl = Xt.Conversation = void 0;
  const t = A(), e = k(), n = N, r = R();
  let s = class {
    constructor() {
    }
    /**
     * Create a conversation
     * @param speechConfig
     * @param cb
     * @param err
     */
    static createConversationAsync(i, c, u, p) {
      n.Contracts.throwIfNullOrUndefined(i, t.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "config")), n.Contracts.throwIfNullOrUndefined(i.region, t.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "SpeechServiceConnection_Region")), !i.subscriptionKey && !i.getProperty(r.PropertyId[r.PropertyId.SpeechServiceAuthorization_Token]) && n.Contracts.throwIfNullOrUndefined(i.subscriptionKey, t.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "SpeechServiceConnection_Key"));
      let d, l, h;
      return typeof c == "string" ? (d = new o(i, c), e.marshalPromiseToCallbacks((async () => {
      })(), u, p)) : (d = new o(i), l = c, h = u, d.createConversationAsync(() => {
        l && l();
      }, (v) => {
        h && h(v);
      })), d;
    }
  };
  Xt.Conversation = s;
  class o extends s {
    /**
     * Create a conversation impl
     * @param speechConfig
     * @param {string} id - optional conversationId
     */
    constructor(i, c) {
      if (super(), this.privErrors = t.ConversationConnectionConfig.restErrors, this.onConnected = (d) => {
        var l;
        this.privIsConnected = !0;
        try {
          (l = this.privConversationTranslator) != null && l.sessionStarted && this.privConversationTranslator.sessionStarted(this.privConversationTranslator, d);
        } catch {
        }
      }, this.onDisconnected = (d) => {
        var l;
        try {
          (l = this.privConversationTranslator) != null && l.sessionStopped && this.privConversationTranslator.sessionStopped(this.privConversationTranslator, d);
        } catch {
        } finally {
          this.close(!1);
        }
      }, this.onCanceled = (d, l) => {
        var h;
        try {
          (h = this.privConversationTranslator) != null && h.canceled && this.privConversationTranslator.canceled(this.privConversationTranslator, l);
        } catch {
        }
      }, this.onParticipantUpdateCommandReceived = (d, l) => {
        try {
          const h = this.privParticipants.getParticipant(l.id);
          if (h !== void 0) {
            switch (l.key) {
              case t.ConversationTranslatorCommandTypes.changeNickname:
                h.displayName = l.value;
                break;
              case t.ConversationTranslatorCommandTypes.setUseTTS:
                h.isUsingTts = l.value;
                break;
              case t.ConversationTranslatorCommandTypes.setProfanityFiltering:
                h.profanity = l.value;
                break;
              case t.ConversationTranslatorCommandTypes.setMute:
                h.isMuted = l.value;
                break;
              case t.ConversationTranslatorCommandTypes.setTranslateToLanguages:
                h.translateToLanguages = l.value;
                break;
            }
            this.privParticipants.addOrUpdateParticipant(h), this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new r.ConversationParticipantsChangedEventArgs(r.ParticipantChangedReason.Updated, [this.toParticipant(h)], l.sessionId));
          }
        } catch {
        }
      }, this.onLockRoomCommandReceived = () => {
      }, this.onMuteAllCommandReceived = (d, l) => {
        try {
          this.privParticipants.participants.forEach((h) => h.isMuted = h.isHost ? !1 : l.isMuted), this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new r.ConversationParticipantsChangedEventArgs(r.ParticipantChangedReason.Updated, this.toParticipants(!1), l.sessionId));
        } catch {
        }
      }, this.onParticipantJoinCommandReceived = (d, l) => {
        try {
          const h = this.privParticipants.addOrUpdateParticipant(l.participant);
          h !== void 0 && this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new r.ConversationParticipantsChangedEventArgs(r.ParticipantChangedReason.JoinedConversation, [this.toParticipant(h)], l.sessionId));
        } catch {
        }
      }, this.onParticipantLeaveCommandReceived = (d, l) => {
        try {
          const h = this.privParticipants.getParticipant(l.participant.id);
          h !== void 0 && (this.privParticipants.deleteParticipant(l.participant.id), this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new r.ConversationParticipantsChangedEventArgs(r.ParticipantChangedReason.LeftConversation, [this.toParticipant(h)], l.sessionId)));
        } catch {
        }
      }, this.onTranslationReceived = (d, l) => {
        try {
          switch (l.command) {
            case t.ConversationTranslatorMessageTypes.final:
              this.privConversationTranslator && this.privConversationTranslator.transcribed(this.privConversationTranslator, new r.ConversationTranslationEventArgs(l.payload, void 0, l.sessionId));
              break;
            case t.ConversationTranslatorMessageTypes.partial:
              this.privConversationTranslator && this.privConversationTranslator.transcribing(this.privConversationTranslator, new r.ConversationTranslationEventArgs(l.payload, void 0, l.sessionId));
              break;
            case t.ConversationTranslatorMessageTypes.instantMessage:
              this.privConversationTranslator && this.privConversationTranslator.textMessageReceived(this.privConversationTranslator, new r.ConversationTranslationEventArgs(l.payload, void 0, l.sessionId));
              break;
          }
        } catch {
        }
      }, this.onParticipantsListReceived = (d, l) => {
        var h;
        try {
          if (l.sessionToken !== void 0 && l.sessionToken !== null && (this.privRoom.token = l.sessionToken), this.privParticipants.participants = [...l.participants], this.privParticipants.me !== void 0 && (this.privIsReady = !0), this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new r.ConversationParticipantsChangedEventArgs(r.ParticipantChangedReason.JoinedConversation, this.toParticipants(!0), l.sessionId)), this.me.isHost) {
            const v = (h = this.privConversationTranslator) == null ? void 0 : h.properties.getProperty(r.PropertyId.ConversationTranslator_Name);
            v !== void 0 && v.length > 0 && v !== this.me.displayName && this.changeNicknameAsync(v);
          }
        } catch {
        }
      }, this.onConversationExpiration = (d, l) => {
        try {
          this.privConversationTranslator && this.privConversationTranslator.conversationExpiration(this.privConversationTranslator, l);
        } catch {
        }
      }, this.privIsConnected = !1, this.privIsDisposed = !1, this.privConversationId = "", this.privProperties = new r.PropertyCollection(), this.privManager = new t.ConversationManager(), i.getProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_RecoLanguage]) || i.setProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_RecoLanguage], t.ConversationConnectionConfig.defaultLanguageCode), this.privLanguage = i.getProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_RecoLanguage]), c)
        this.privConversationId = c;
      else {
        i.targetLanguages.length === 0 && i.addTargetLanguage(this.privLanguage), i.getProperty(r.PropertyId[r.PropertyId.SpeechServiceResponse_ProfanityOption]) || i.setProfanity(r.ProfanityOption.Masked);
        let l = i.getProperty(r.PropertyId[r.PropertyId.ConversationTranslator_Name]);
        l == null && (l = "Host"), n.Contracts.throwIfNullOrTooLong(l, "nickname", 50), n.Contracts.throwIfNullOrTooShort(l, "nickname", 2), i.setProperty(r.PropertyId[r.PropertyId.ConversationTranslator_Name], l);
      }
      this.privConfig = i;
      const p = i;
      n.Contracts.throwIfNull(p, "speechConfig"), this.privProperties = p.properties.clone(), this.privIsConnected = !1, this.privParticipants = new t.InternalParticipants(), this.privIsReady = !1, this.privTextMessageMaxLength = 1e3;
    }
    // get the internal data about a conversation
    get room() {
      return this.privRoom;
    }
    // get the wrapper for connecting to the websockets
    get connection() {
      return this.privConversationRecognizer;
    }
    // get the config
    get config() {
      return this.privConfig;
    }
    // get the conversation Id
    get conversationId() {
      return this.privRoom ? this.privRoom.roomId : this.privConversationId;
    }
    // get the properties
    get properties() {
      return this.privProperties;
    }
    // get the speech language
    get speechRecognitionLanguage() {
      return this.privLanguage;
    }
    get isMutedByHost() {
      var i, c;
      return (i = this.privParticipants.me) != null && i.isHost ? !1 : (c = this.privParticipants.me) == null ? void 0 : c.isMuted;
    }
    get isConnected() {
      return this.privIsConnected && this.privIsReady;
    }
    get participants() {
      return this.toParticipants(!0);
    }
    get me() {
      return this.toParticipant(this.privParticipants.me);
    }
    get host() {
      return this.toParticipant(this.privParticipants.host);
    }
    get transcriberRecognizer() {
      return this.privTranscriberRecognizer;
    }
    get conversationInfo() {
      const i = this.conversationId, c = this.participants.map((d) => ({
        id: d.id,
        preferredLanguage: d.preferredLanguage,
        voice: d.voice
      })), u = {};
      for (const d of t.ConversationConnectionConfig.transcriptionEventKeys) {
        const l = this.properties.getProperty(d, "");
        l !== "" && (u[d] = l);
      }
      return { id: i, participants: c, conversationProperties: u };
    }
    get canSend() {
      var i;
      return this.privIsConnected && !((i = this.privParticipants.me) != null && i.isMuted);
    }
    get canSendAsHost() {
      var i;
      return this.privIsConnected && ((i = this.privParticipants.me) == null ? void 0 : i.isHost);
    }
    // get / set the speech auth token
    // eslint-disable-next-line @typescript-eslint/member-ordering
    get authorizationToken() {
      return this.privToken;
    }
    set authorizationToken(i) {
      n.Contracts.throwIfNullOrWhitespace(i, "authorizationToken"), this.privToken = i;
    }
    set conversationTranslator(i) {
      this.privConversationTranslator = i;
    }
    onToken(i) {
      this.privConversationTranslator.onToken(i);
    }
    /**
     * Create a new conversation as Host
     * @param cb
     * @param err
     */
    createConversationAsync(i, c) {
      try {
        this.privConversationRecognizer && this.handleError(new Error(this.privErrors.permissionDeniedStart), c), this.privManager.createOrJoin(this.privProperties, void 0, (u) => {
          u || this.handleError(new Error(this.privErrors.permissionDeniedConnect), c), this.privRoom = u, this.handleCallback(i, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Starts a new conversation as host.
     * @param cb
     * @param err
     */
    startConversationAsync(i, c) {
      try {
        this.privConversationRecognizer && this.handleError(new Error(this.privErrors.permissionDeniedStart), c), n.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedConnect), this.privParticipants.meId = this.privRoom.participantId, this.privConversationRecognizer = t.ConversationRecognizerFactory.fromConfig(this, this.privConfig), this.privConversationRecognizer.connected = this.onConnected, this.privConversationRecognizer.disconnected = this.onDisconnected, this.privConversationRecognizer.canceled = this.onCanceled, this.privConversationRecognizer.participantUpdateCommandReceived = this.onParticipantUpdateCommandReceived, this.privConversationRecognizer.lockRoomCommandReceived = this.onLockRoomCommandReceived, this.privConversationRecognizer.muteAllCommandReceived = this.onMuteAllCommandReceived, this.privConversationRecognizer.participantJoinCommandReceived = this.onParticipantJoinCommandReceived, this.privConversationRecognizer.participantLeaveCommandReceived = this.onParticipantLeaveCommandReceived, this.privConversationRecognizer.translationReceived = this.onTranslationReceived, this.privConversationRecognizer.participantsListReceived = this.onParticipantsListReceived, this.privConversationRecognizer.conversationExpiration = this.onConversationExpiration, this.privConversationRecognizer.connect(this.privRoom.token, () => {
          this.handleCallback(i, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Join a conversation as a participant.
     * @param { IParticipant } participant - participant to add
     * @param cb
     * @param err
     */
    addParticipantAsync(i, c, u) {
      n.Contracts.throwIfNullOrUndefined(i, "Participant"), e.marshalPromiseToCallbacks(this.addParticipantImplAsync(i), c, u);
    }
    /**
     * Join a conversation as a participant.
     * @param conversation
     * @param nickname
     * @param lang
     * @param cb
     * @param err
     */
    joinConversationAsync(i, c, u, p, d) {
      try {
        n.Contracts.throwIfNullOrWhitespace(i, this.privErrors.invalidArgs.replace("{arg}", "conversationId")), n.Contracts.throwIfNullOrWhitespace(c, this.privErrors.invalidArgs.replace("{arg}", "nickname")), n.Contracts.throwIfNullOrWhitespace(u, this.privErrors.invalidArgs.replace("{arg}", "language")), this.privManager.createOrJoin(this.privProperties, i, (l) => {
          n.Contracts.throwIfNullOrUndefined(l, this.privErrors.permissionDeniedConnect), this.privRoom = l, this.privConfig.authorizationToken = l.cognitiveSpeechAuthToken, p && p(l.cognitiveSpeechAuthToken);
        }, (l) => {
          this.handleError(l, d);
        });
      } catch (l) {
        this.handleError(l, d);
      }
    }
    /**
     * Deletes a conversation
     * @param cb
     * @param err
     */
    deleteConversationAsync(i, c) {
      e.marshalPromiseToCallbacks(this.deleteConversationImplAsync(), i, c);
    }
    async deleteConversationImplAsync() {
      n.Contracts.throwIfNullOrUndefined(this.privProperties, this.privErrors.permissionDeniedConnect), n.Contracts.throwIfNullOrWhitespace(this.privRoom.token, this.privErrors.permissionDeniedConnect), await this.privManager.leave(this.privProperties, this.privRoom.token), this.dispose();
    }
    /**
     * Issues a request to close the client websockets
     * @param cb
     * @param err
     */
    endConversationAsync(i, c) {
      e.marshalPromiseToCallbacks(this.endConversationImplAsync(), i, c);
    }
    endConversationImplAsync() {
      return this.close(!0);
    }
    /**
     * Issues a request to lock the conversation
     * @param cb
     * @param err
     */
    lockConversationAsync(i, c) {
      try {
        n.Contracts.throwIfDisposed(this.privIsDisposed), n.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), n.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "lock")), c), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getLockCommand(!0), () => {
          this.handleCallback(i, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Issues a request to mute the conversation
     * @param cb
     * @param err
     */
    muteAllParticipantsAsync(i, c) {
      try {
        n.Contracts.throwIfDisposed(this.privIsDisposed), n.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), n.Contracts.throwIfNullOrUndefined(this.privConversationRecognizer, this.privErrors.permissionDeniedSend), n.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "mute")), c), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMuteAllCommand(!0), () => {
          this.handleCallback(i, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Issues a request to mute a participant in the conversation
     * @param userId
     * @param cb
     * @param err
     */
    muteParticipantAsync(i, c, u) {
      try {
        n.Contracts.throwIfDisposed(this.privIsDisposed), n.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), n.Contracts.throwIfNullOrWhitespace(i, this.privErrors.invalidArgs.replace("{arg}", "userId")), n.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), !this.me.isHost && this.me.id !== i && this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "mute")), u), this.privParticipants.getParticipantIndex(i) === -1 && this.handleError(new Error(this.privErrors.invalidParticipantRequest), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMuteCommand(i, !0), () => {
          this.handleCallback(c, u);
        }, (d) => {
          this.handleError(d, u);
        });
      } catch (p) {
        this.handleError(p, u);
      }
    }
    /**
     * Issues a request to remove a participant from the conversation
     * @param userId
     * @param cb
     * @param err
     */
    removeParticipantAsync(i, c, u) {
      try {
        if (n.Contracts.throwIfDisposed(this.privIsDisposed), this.privTranscriberRecognizer && i.hasOwnProperty("id"))
          e.marshalPromiseToCallbacks(this.removeParticipantImplAsync(i), c, u);
        else {
          n.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), n.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "remove")), u);
          let p = "";
          typeof i == "string" ? p = i : i.hasOwnProperty("id") ? p = i.id : i.hasOwnProperty("userId") && (p = i.userId), n.Contracts.throwIfNullOrWhitespace(p, this.privErrors.invalidArgs.replace("{arg}", "userId")), this.participants.findIndex((l) => l.id === p) === -1 && this.handleError(new Error(this.privErrors.invalidParticipantRequest), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getEjectCommand(p), () => {
            this.handleCallback(c, u);
          }, (l) => {
            this.handleError(l, u);
          });
        }
      } catch (p) {
        this.handleError(p, u);
      }
    }
    /**
     * Issues a request to unlock the conversation
     * @param cb
     * @param err
     */
    unlockConversationAsync(i, c) {
      try {
        n.Contracts.throwIfDisposed(this.privIsDisposed), n.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), n.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "unlock")), c), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getLockCommand(!1), () => {
          this.handleCallback(i, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Issues a request to unmute all participants in the conversation
     * @param cb
     * @param err
     */
    unmuteAllParticipantsAsync(i, c) {
      try {
        n.Contracts.throwIfDisposed(this.privIsDisposed), n.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), n.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "unmute all")), c), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMuteAllCommand(!1), () => {
          this.handleCallback(i, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Issues a request to unmute a participant in the conversation
     * @param userId
     * @param cb
     * @param err
     */
    unmuteParticipantAsync(i, c, u) {
      try {
        n.Contracts.throwIfDisposed(this.privIsDisposed), n.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), n.Contracts.throwIfNullOrWhitespace(i, this.privErrors.invalidArgs.replace("{arg}", "userId")), n.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), !this.me.isHost && this.me.id !== i && this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "mute")), u), this.privParticipants.getParticipantIndex(i) === -1 && this.handleError(new Error(this.privErrors.invalidParticipantRequest), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMuteCommand(i, !1), () => {
          this.handleCallback(c, u);
        }, (d) => {
          this.handleError(d, u);
        });
      } catch (p) {
        this.handleError(p, u);
      }
    }
    /**
     * Send a text message
     * @param message
     * @param cb
     * @param err
     */
    sendTextMessageAsync(i, c, u) {
      try {
        n.Contracts.throwIfDisposed(this.privIsDisposed), n.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), n.Contracts.throwIfNullOrWhitespace(i, this.privErrors.invalidArgs.replace("{arg}", "message")), n.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), i.length > this.privTextMessageMaxLength && this.handleError(new Error(this.privErrors.invalidArgs.replace("{arg}", "message length")), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMessageCommand(i), () => {
          this.handleCallback(c, u);
        }, (p) => {
          this.handleError(p, u);
        });
      } catch (p) {
        this.handleError(p, u);
      }
    }
    /**
     * Set translated to languages
     * @param {string[]} languages - languages to translate to
     * @param cb
     * @param err
     */
    setTranslatedLanguagesAsync(i, c, u) {
      try {
        n.Contracts.throwIfDisposed(this.privIsDisposed), n.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), n.Contracts.throwIfArrayEmptyOrWhitespace(i, this.privErrors.invalidArgs.replace("{arg}", "languages")), n.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getSetTranslateToLanguagesCommand(i), () => {
          this.handleCallback(c, u);
        }, (p) => {
          this.handleError(p, u);
        });
      } catch (p) {
        this.handleError(p, u);
      }
    }
    /**
     * Change nickname
     * @param {string} nickname - new nickname for the room
     * @param cb
     * @param err
     */
    changeNicknameAsync(i, c, u) {
      try {
        n.Contracts.throwIfDisposed(this.privIsDisposed), n.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), n.Contracts.throwIfNullOrWhitespace(i, this.privErrors.invalidArgs.replace("{arg}", "nickname")), n.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getChangeNicknameCommand(i), () => {
          this.handleCallback(c, u);
        }, (p) => {
          this.handleError(p, u);
        });
      } catch (p) {
        this.handleError(p, u);
      }
    }
    isDisposed() {
      return this.privIsDisposed;
    }
    dispose() {
      this.isDisposed || (this.privIsDisposed = !0, this.config && this.config.close(), this.privConfig = void 0, this.privLanguage = void 0, this.privProperties = void 0, this.privRoom = void 0, this.privToken = void 0, this.privManager = void 0, this.privIsConnected = !1, this.privIsReady = !1, this.privParticipants = void 0);
    }
    async connectTranscriberRecognizer(i) {
      this.privTranscriberRecognizer && await this.privTranscriberRecognizer.close(), await i.enforceAudioGating(), this.privTranscriberRecognizer = i, this.privTranscriberRecognizer.conversation = this;
    }
    getKeepAlive() {
      const i = this.me ? this.me.displayName : "default_nickname";
      return JSON.stringify({
        id: "0",
        nickname: i,
        participantId: this.privRoom.participantId,
        roomId: this.privRoom.roomId,
        type: t.ConversationTranslatorMessageTypes.keepAlive
      });
    }
    /* eslint-enable @typescript-eslint/typedef */
    addParticipantImplAsync(i) {
      if (this.privParticipants.addOrUpdateParticipant(i) !== void 0 && this.privTranscriberRecognizer) {
        const u = this.conversationInfo;
        return u.participants = [i], this.privTranscriberRecognizer.pushConversationEvent(u, "join");
      }
    }
    removeParticipantImplAsync(i) {
      this.privParticipants.deleteParticipant(i.id);
      const c = this.conversationInfo;
      return c.participants = [i], this.privTranscriberRecognizer.pushConversationEvent(c, "leave");
    }
    async close(i) {
      var c;
      try {
        this.privIsConnected = !1, await ((c = this.privConversationRecognizer) == null ? void 0 : c.close()), this.privConversationRecognizer = void 0, this.privConversationTranslator && this.privConversationTranslator.dispose();
      } catch (u) {
        throw u;
      }
      i && this.dispose();
    }
    /** Helpers */
    handleCallback(i, c) {
      if (i) {
        try {
          i();
        } catch (u) {
          c && c(u);
        }
        i = void 0;
      }
    }
    handleError(i, c) {
      if (c)
        if (i instanceof Error) {
          const u = i;
          c(u.name + ": " + u.message);
        } else
          c(i);
    }
    /** Participant Helpers */
    toParticipants(i) {
      const c = this.privParticipants.participants.map((u) => this.toParticipant(u));
      return i ? c : c.filter((u) => u.isHost === !1);
    }
    toParticipant(i) {
      return new r.Participant(i.id, i.avatar, i.displayName, i.isHost, i.isMuted, i.isUsingTts, i.preferredLanguage, i.voice);
    }
    getMuteAllCommand(i) {
      return n.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId"), n.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), JSON.stringify({
        command: t.ConversationTranslatorCommandTypes.setMuteAll,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: t.ConversationTranslatorMessageTypes.participantCommand,
        value: i
      });
    }
    getMuteCommand(i, c) {
      return n.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId"), n.Contracts.throwIfNullOrWhitespace(i, "participantId"), JSON.stringify({
        command: t.ConversationTranslatorCommandTypes.setMute,
        // eslint-disable-next-line object-shorthand
        participantId: i,
        roomid: this.privRoom.roomId,
        type: t.ConversationTranslatorMessageTypes.participantCommand,
        value: c
      });
    }
    getLockCommand(i) {
      return n.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId"), n.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), JSON.stringify({
        command: t.ConversationTranslatorCommandTypes.setLockState,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: t.ConversationTranslatorMessageTypes.participantCommand,
        value: i
      });
    }
    getEjectCommand(i) {
      return n.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId"), n.Contracts.throwIfNullOrWhitespace(i, "participantId"), JSON.stringify({
        command: t.ConversationTranslatorCommandTypes.ejectParticipant,
        // eslint-disable-next-line object-shorthand
        participantId: i,
        roomid: this.privRoom.roomId,
        type: t.ConversationTranslatorMessageTypes.participantCommand
      });
    }
    getSetTranslateToLanguagesCommand(i) {
      return n.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId"), n.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), JSON.stringify({
        command: t.ConversationTranslatorCommandTypes.setTranslateToLanguages,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: t.ConversationTranslatorMessageTypes.participantCommand,
        value: i
      });
    }
    getChangeNicknameCommand(i) {
      return n.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId"), n.Contracts.throwIfNullOrWhitespace(i, "nickname"), n.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), JSON.stringify({
        command: t.ConversationTranslatorCommandTypes.changeNickname,
        nickname: i,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: t.ConversationTranslatorMessageTypes.participantCommand,
        value: i
      });
    }
    getMessageCommand(i) {
      return n.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId"), n.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), n.Contracts.throwIfNullOrWhitespace(i, "message"), JSON.stringify({
        participantId: this.privRoom.participantId,
        roomId: this.privRoom.roomId,
        text: i,
        type: t.ConversationTranslatorMessageTypes.instantMessage
      });
    }
  }
  return Xt.ConversationImpl = o, Xt;
}
var ma = {};
Object.defineProperty(ma, "__esModule", { value: !0 });
ma.ConversationCommon = void 0;
class uR {
  constructor(e) {
    this.privAudioConfig = e;
  }
  handleCallback(e, n) {
    if (e) {
      try {
        e();
      } catch (r) {
        n && n(r);
      }
      e = void 0;
    }
  }
  handleError(e, n) {
    if (n)
      if (e instanceof Error) {
        const r = e;
        n(r.name + ": " + r.message);
      } else
        n(e);
  }
}
ma.ConversationCommon = uR;
var ei = {}, $d;
function pR() {
  if ($d)
    return ei;
  $d = 1, Object.defineProperty(ei, "__esModule", { value: !0 }), ei.ConversationExpirationEventArgs = void 0;
  const t = R();
  let e = class extends t.SessionEventArgs {
    constructor(r, s) {
      super(s), this.privExpirationTime = r;
    }
    /** How much longer until the conversation expires (in minutes). */
    get expirationTime() {
      return this.privExpirationTime;
    }
  };
  return ei.ConversationExpirationEventArgs = e, ei;
}
var ti = {}, Ud;
function dR() {
  if (Ud)
    return ti;
  Ud = 1, Object.defineProperty(ti, "__esModule", { value: !0 }), ti.ConversationParticipantsChangedEventArgs = void 0;
  const t = R();
  let e = class extends t.SessionEventArgs {
    constructor(r, s, o) {
      super(o), this.privReason = r, this.privParticipant = s;
    }
    get reason() {
      return this.privReason;
    }
    get participants() {
      return this.privParticipant;
    }
  };
  return ti.ConversationParticipantsChangedEventArgs = e, ti;
}
var ni = {}, Hd;
function lR() {
  if (Hd)
    return ni;
  Hd = 1, Object.defineProperty(ni, "__esModule", { value: !0 }), ni.ConversationTranslationCanceledEventArgs = void 0;
  const t = Cs();
  let e = class extends t.CancellationEventArgsBase {
  };
  return ni.ConversationTranslationCanceledEventArgs = e, ni;
}
var ri = {}, Wd;
function hR() {
  if (Wd)
    return ri;
  Wd = 1, Object.defineProperty(ri, "__esModule", { value: !0 }), ri.ConversationTranslationEventArgs = void 0;
  const t = R();
  let e = class extends t.RecognitionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {ConversationTranslationResult} result - The translation recognition result.
     * @param {number} offset - The offset.
     * @param {string} sessionId - The session id.
     */
    constructor(r, s, o) {
      super(s, o), this.privResult = r;
    }
    /**
     * Specifies the recognition result.
     * @returns {ConversationTranslationResult} the recognition result.
     */
    get result() {
      return this.privResult;
    }
  };
  return ri.ConversationTranslationEventArgs = e, ri;
}
var ii = {}, Vd;
function vR() {
  if (Vd)
    return ii;
  Vd = 1, Object.defineProperty(ii, "__esModule", { value: !0 }), ii.ConversationTranslationResult = void 0;
  const t = bf();
  let e = class extends t.TranslationRecognitionResult {
    constructor(r, s, o, a, i, c, u, p, d, l, h) {
      super(s, a, i, c, u, p, void 0, void 0, d, l, h), this.privId = r, this.privOrigLang = o;
    }
    /**
     * The unique identifier for the participant this result is for.
     */
    get participantId() {
      return this.privId;
    }
    /**
     * The original language this result was in.
     */
    get originalLang() {
      return this.privOrigLang;
    }
  };
  return ii.ConversationTranslationResult = e, ii;
}
var _c = {}, si = {}, Rs = {};
Object.defineProperty(Rs, "__esModule", { value: !0 });
Rs.StringUtils = void 0;
class fR {
  /**
   * Formats a string by replacing the named {keys} in the string with the values contained in the replacement dictionary.
   * @param format The format string that contains the parts to replace surrounded by {}. For example: "wss://{region}.cts.speech.microsoft.com".
   * If your string needs to contain a { or } you can use the {{ and }} escape sequences respectively.
   * @param replacements The dictionary of replacements. If a replacement is not found, it is replaced with an empty string
   * @returns The formatted string. If you pass in a null or undefined format string, an empty string will be returned
   */
  static formatString(e, n) {
    if (!e)
      return "";
    if (!n)
      return e;
    let r = "", s = "";
    const o = (c) => {
      r += c;
    }, a = (c) => {
      s += c;
    };
    let i = o;
    for (let c = 0; c < e.length; c++) {
      const u = e[c], p = c + 1 < e.length ? e[c + 1] : "";
      switch (u) {
        case "{":
          p === "{" ? (i("{"), c++) : i = a;
          break;
        case "}":
          p === "}" ? (i("}"), c++) : (n.hasOwnProperty(s) && (r += n[s]), i = o, s = "");
          break;
        default:
          i(u);
          break;
      }
    }
    return r;
  }
}
Rs.StringUtils = fR;
var Kd;
function gR() {
  if (Kd)
    return si;
  Kd = 1, Object.defineProperty(si, "__esModule", { value: !0 }), si.ConversationTranslatorConnectionFactory = void 0;
  const t = ye(), e = Rs, n = N, r = R(), s = Se, o = st, a = ot(), i = A();
  let c = class Vf extends a.ConnectionFactoryBase {
    constructor(p) {
      super(), n.Contracts.throwIfNullOrUndefined(p, "convGetter"), this.privConvGetter = p;
    }
    create(p, d, l) {
      const h = p.parameters.getProperty("ConversationTranslator_MultiChannelAudio", "").toUpperCase() === "TRUE", v = this.privConvGetter().room, g = v.cognitiveSpeechRegion || p.parameters.getProperty(r.PropertyId.SpeechServiceConnection_Region, ""), f = {
        hostSuffix: a.ConnectionFactoryBase.getHostSuffix(g),
        path: Vf.CTS_VIRT_MIC_PATH,
        region: encodeURIComponent(g)
      };
      f[o.QueryParameterNames.Language] = encodeURIComponent(p.parameters.getProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage, "")), f[o.QueryParameterNames.CtsMeetingId] = encodeURIComponent(v.roomId), f[o.QueryParameterNames.CtsDeviceId] = encodeURIComponent(v.participantId), f[o.QueryParameterNames.CtsIsParticipant] = v.isHost ? "" : "&" + o.QueryParameterNames.CtsIsParticipant;
      let m = "";
      const S = {}, y = {};
      if (h) {
        m = p.parameters.getProperty(r.PropertyId.SpeechServiceConnection_Endpoint), m || (m = "wss://" + p.parameters.getProperty(r.PropertyId.SpeechServiceConnection_Host, "transcribe.{region}.cts.speech{hostSuffix}") + "{path}"), m = e.StringUtils.formatString(m, f);
        const C = new URL(m);
        C.searchParams.forEach((w, T) => {
          S[T] = w;
        }), new i.TranscriberConnectionFactory().setQueryParams(S, p, m), S[o.QueryParameterNames.CtsMeetingId] = f[o.QueryParameterNames.CtsMeetingId], S[o.QueryParameterNames.CtsDeviceId] = f[o.QueryParameterNames.CtsDeviceId], v.isHost || (S[o.QueryParameterNames.CtsIsParticipant] = ""), o.QueryParameterNames.Format in S || (S[o.QueryParameterNames.Format] = "simple"), C.searchParams.forEach((w, T) => {
          C.searchParams.set(T, S[T]), delete S[T];
        }), m = C.toString();
      } else {
        const C = new i.TranslationConnectionFactory();
        m = C.getEndpointUrl(p, !0), m = e.StringUtils.formatString(m, f), C.setQueryParams(S, p, m);
      }
      y[s.HeaderNames.ConnectionId] = l, y[t.RestConfigBase.configParams.token] = v.token, d.token && (y[d.headerName] = d.token);
      const P = p.parameters.getProperty("SPEECH-EnableWebsocketCompression", "").toUpperCase() === "TRUE";
      return new t.WebsocketConnection(m, S, y, new i.WebsocketMessageFormatter(), t.ProxyInfo.fromRecognizerConfig(p), P, l);
    }
  };
  return si.ConversationTranslatorConnectionFactory = c, c.CTS_VIRT_MIC_PATH = "/speech/recognition/dynamicaudio", si;
}
var Jd;
function mR() {
  return Jd || (Jd = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.ConversationTranslator = t.SpeechState = void 0;
    const e = A(), n = gR(), r = k(), s = N, o = R(), a = Wf(), i = Bu();
    var c;
    (function(d) {
      d[d.Inactive = 0] = "Inactive", d[d.Connecting = 1] = "Connecting", d[d.Connected = 2] = "Connected";
    })(c = t.SpeechState || (t.SpeechState = {}));
    class u extends o.TranslationRecognizer {
      constructor(l, h, v, g) {
        super(l, h, new n.ConversationTranslatorConnectionFactory(g)), this.privSpeechState = c.Inactive, v && (this.privTranslator = v, this.sessionStarted = () => {
          this.privSpeechState = c.Connected;
        }, this.sessionStopped = () => {
          this.privSpeechState = c.Inactive;
        }, this.recognizing = (f, m) => {
          this.privTranslator.recognizing && this.privTranslator.recognizing(this.privTranslator, m);
        }, this.recognized = async (f, m) => {
          var S;
          (S = m.result) != null && S.errorDetails ? (await this.cancelSpeech(), this.fireCancelEvent(m.result.errorDetails)) : this.privTranslator.recognized && this.privTranslator.recognized(this.privTranslator, m);
        }, this.canceled = async () => {
          if (this.privSpeechState !== c.Inactive)
            try {
              await this.cancelSpeech();
            } catch {
              this.privSpeechState = c.Inactive;
            }
        });
      }
      get state() {
        return this.privSpeechState;
      }
      set state(l) {
        this.privSpeechState = l;
      }
      set authentication(l) {
        this.privReco.authentication = l;
      }
      onConnection() {
        this.privSpeechState = c.Connected;
      }
      async onCancelSpeech() {
        this.privSpeechState = c.Inactive, await this.cancelSpeech();
      }
      /**
       * Fire a cancel event
       * @param error
       */
      fireCancelEvent(l) {
        try {
          if (this.privTranslator.canceled) {
            const h = new i.ConversationTranslationCanceledEventArgs(o.CancellationReason.Error, l, o.CancellationErrorCode.RuntimeError);
            this.privTranslator.canceled(this.privTranslator, h);
          }
        } catch {
        }
      }
      async cancelSpeech() {
        var l;
        try {
          this.stopContinuousRecognitionAsync(), await ((l = this.privReco) == null ? void 0 : l.disconnect()), this.privSpeechState = c.Inactive;
        } catch {
        }
      }
    }
    class p extends i.ConversationCommon {
      constructor(l) {
        super(l), this.privErrors = e.ConversationConnectionConfig.restErrors, this.privIsDisposed = !1, this.privIsSpeaking = !1, this.privPlaceholderKey = "abcdefghijklmnopqrstuvwxyz012345", this.privPlaceholderRegion = "westus", this.privProperties = new o.PropertyCollection();
      }
      get properties() {
        return this.privProperties;
      }
      get speechRecognitionLanguage() {
        return this.privSpeechRecognitionLanguage;
      }
      get participants() {
        var l;
        return (l = this.privConversation) == null ? void 0 : l.participants;
      }
      get canSpeak() {
        return !(!this.privConversation.isConnected || !this.privCTRecognizer || this.privIsSpeaking || this.privCTRecognizer.state === c.Connected || this.privCTRecognizer.state === c.Connecting || this.privConversation.isMutedByHost);
      }
      onToken(l) {
        this.privCTRecognizer.authentication = l;
      }
      setServiceProperty(l, h) {
        const v = JSON.parse(this.privProperties.getProperty(e.ServicePropertiesPropertyName, "{}"));
        v[l] = h, this.privProperties.setProperty(e.ServicePropertiesPropertyName, JSON.stringify(v));
      }
      joinConversationAsync(l, h, v, g, f) {
        try {
          if (typeof l == "string") {
            s.Contracts.throwIfNullOrUndefined(l, this.privErrors.invalidArgs.replace("{arg}", "conversation id")), s.Contracts.throwIfNullOrWhitespace(h, this.privErrors.invalidArgs.replace("{arg}", "nickname")), this.privConversation && this.handleError(new Error(this.privErrors.permissionDeniedStart), f);
            let m = v;
            (m == null || m === "") && (m = e.ConversationConnectionConfig.defaultLanguageCode), this.privSpeechTranslationConfig = o.SpeechTranslationConfig.fromSubscription(this.privPlaceholderKey, this.privPlaceholderRegion), this.privSpeechTranslationConfig.setProfanity(o.ProfanityOption.Masked), this.privSpeechTranslationConfig.addTargetLanguage(m), this.privSpeechTranslationConfig.setProperty(o.PropertyId[o.PropertyId.SpeechServiceConnection_RecoLanguage], m), this.privSpeechTranslationConfig.setProperty(o.PropertyId[o.PropertyId.ConversationTranslator_Name], h);
            const S = [
              o.PropertyId.SpeechServiceConnection_Host,
              o.PropertyId.ConversationTranslator_Host,
              o.PropertyId.SpeechServiceConnection_Endpoint,
              o.PropertyId.SpeechServiceConnection_ProxyHostName,
              o.PropertyId.SpeechServiceConnection_ProxyPassword,
              o.PropertyId.SpeechServiceConnection_ProxyPort,
              o.PropertyId.SpeechServiceConnection_ProxyUserName,
              "ConversationTranslator_MultiChannelAudio",
              "ConversationTranslator_Region"
            ];
            for (const P of S) {
              const C = this.privProperties.getProperty(P);
              if (C) {
                const _ = typeof P == "string" ? P : o.PropertyId[P];
                this.privSpeechTranslationConfig.setProperty(_, C);
              }
            }
            const y = JSON.parse(this.privProperties.getProperty(e.ServicePropertiesPropertyName, "{}"));
            for (const P of Object.keys(y))
              this.privSpeechTranslationConfig.setServiceProperty(P, y[P], o.ServicePropertyChannel.UriQueryParameter);
            this.privConversation = new a.ConversationImpl(this.privSpeechTranslationConfig), this.privConversation.conversationTranslator = this, this.privConversation.joinConversationAsync(l, h, m, (P) => {
              P || this.handleError(new Error(this.privErrors.permissionDeniedConnect), f), this.privSpeechTranslationConfig.authorizationToken = P, this.privConversation.room.isHost = !1, this.privConversation.startConversationAsync(() => {
                this.handleCallback(g, f);
              }, (C) => {
                this.handleError(C, f);
              });
            }, (P) => {
              this.handleError(P, f);
            });
          } else
            typeof l == "object" ? (s.Contracts.throwIfNullOrUndefined(l, this.privErrors.invalidArgs.replace("{arg}", "conversation id")), s.Contracts.throwIfNullOrWhitespace(h, this.privErrors.invalidArgs.replace("{arg}", "nickname")), this.privProperties.setProperty(o.PropertyId.ConversationTranslator_Name, h), this.privConversation = l, this.privConversation.conversationTranslator = this, this.privConversation.room.isHost = !0, s.Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedConnect), s.Contracts.throwIfNullOrUndefined(this.privConversation.room.token, this.privErrors.permissionDeniedConnect), this.privSpeechTranslationConfig = l.config, this.handleCallback(v, g)) : this.handleError(new Error(this.privErrors.invalidArgs.replace("{arg}", "invalid conversation type")), g);
        } catch (m) {
          this.handleError(m, typeof v == "string" ? f : g);
        }
      }
      /**
       * Leave the conversation
       * @param cb
       * @param err
       */
      leaveConversationAsync(l, h) {
        r.marshalPromiseToCallbacks((async () => {
          await this.cancelSpeech(), await this.privConversation.endConversationImplAsync(), await this.privConversation.deleteConversationImplAsync(), this.dispose();
        })(), l, h);
      }
      /**
       * Send a text message
       * @param message
       * @param cb
       * @param err
       */
      sendTextMessageAsync(l, h, v) {
        try {
          s.Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedSend), s.Contracts.throwIfNullOrWhitespace(l, this.privErrors.invalidArgs.replace("{arg}", l)), this.privConversation.sendTextMessageAsync(l, h, v);
        } catch (g) {
          this.handleError(g, v);
        }
      }
      /**
       * Start speaking
       * @param cb
       * @param err
       */
      startTranscribingAsync(l, h) {
        r.marshalPromiseToCallbacks((async () => {
          try {
            s.Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedSend), s.Contracts.throwIfNullOrUndefined(this.privConversation.room.token, this.privErrors.permissionDeniedConnect), this.privCTRecognizer === void 0 && await this.connectTranslatorRecognizer(), s.Contracts.throwIfNullOrUndefined(this.privCTRecognizer, this.privErrors.permissionDeniedSend), this.canSpeak || this.handleError(new Error(this.privErrors.permissionDeniedSend), h), await this.startContinuousRecognition(), this.privIsSpeaking = !0;
          } catch (v) {
            throw this.privIsSpeaking = !1, await this.cancelSpeech(), v;
          }
        })(), l, h);
      }
      /**
       * Stop speaking
       * @param cb
       * @param err
       */
      stopTranscribingAsync(l, h) {
        r.marshalPromiseToCallbacks((async () => {
          try {
            if (!this.privIsSpeaking) {
              await this.cancelSpeech();
              return;
            }
            this.privIsSpeaking = !1, await new Promise((v, g) => {
              this.privCTRecognizer.stopContinuousRecognitionAsync(v, g);
            });
          } catch {
            await this.cancelSpeech();
          }
        })(), l, h);
      }
      isDisposed() {
        return this.privIsDisposed;
      }
      dispose(l, h, v) {
        r.marshalPromiseToCallbacks((async () => {
          this.isDisposed && !this.privIsSpeaking || (await this.cancelSpeech(), this.privIsDisposed = !0, this.privSpeechTranslationConfig.close(), this.privSpeechRecognitionLanguage = void 0, this.privProperties = void 0, this.privAudioConfig = void 0, this.privSpeechTranslationConfig = void 0, this.privConversation.dispose(), this.privConversation = void 0);
        })(), h, v);
      }
      /**
       * Cancel the speech websocket
       */
      async cancelSpeech() {
        var l;
        try {
          this.privIsSpeaking = !1, await ((l = this.privCTRecognizer) == null ? void 0 : l.onCancelSpeech()), this.privCTRecognizer = void 0;
        } catch {
        }
      }
      /**
       * Connect to the speech translation recognizer.
       * Currently there is no language validation performed before sending the SpeechLanguage code to the service.
       * If it's an invalid language the raw error will be: 'Error during WebSocket handshake: Unexpected response code: 400'
       * e.g. pass in 'fr' instead of 'fr-FR', or a text-only language 'cy'
       */
      async connectTranslatorRecognizer() {
        try {
          this.privAudioConfig === void 0 && (this.privAudioConfig = o.AudioConfig.fromDefaultMicrophoneInput()), this.privSpeechTranslationConfig.getProperty(o.PropertyId[o.PropertyId.SpeechServiceConnection_Key]) === this.privPlaceholderKey && this.privSpeechTranslationConfig.setProperty(o.PropertyId[o.PropertyId.SpeechServiceConnection_Key], "");
          const l = () => this.privConversation;
          this.privCTRecognizer = new u(this.privSpeechTranslationConfig, this.privAudioConfig, this, l);
        } catch (l) {
          throw await this.cancelSpeech(), l;
        }
      }
      /**
       * Handle the start speaking request
       */
      startContinuousRecognition() {
        return new Promise((l, h) => {
          this.privCTRecognizer.startContinuousRecognitionAsync(l, h);
        });
      }
    }
    t.ConversationTranslator = p;
  }(_c)), _c;
}
var oi = {}, Gd;
function SR() {
  if (Gd)
    return oi;
  Gd = 1, Object.defineProperty(oi, "__esModule", { value: !0 }), oi.ConversationTranscriber = void 0;
  const t = A(), e = k(), n = N, r = R();
  let s = class Kf extends r.Recognizer {
    /**
     * ConversationTranscriber constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - an set of initial properties for this recognizer
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
     */
    constructor(a, i) {
      const c = a;
      n.Contracts.throwIfNull(c, "speechConfig"), n.Contracts.throwIfNullOrWhitespace(c.properties.getProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage), r.PropertyId[r.PropertyId.SpeechServiceConnection_RecoLanguage]), super(i, c.properties, new t.ConversationTranscriberConnectionFactory()), this.privProperties.setProperty(r.PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, "2"), this.privDisposedRecognizer = !1;
    }
    /**
     * ConversationTranscriber constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - an set of initial properties for this recognizer
     * @param {AutoDetectSourceLanguageConfig} autoDetectSourceLanguageConfig - An source language detection configuration associated with the recognizer
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
     */
    static FromConfig(a, i, c) {
      const u = a;
      return i.properties.mergeTo(u.properties), new Kf(a, c);
    }
    /**
     * Gets the endpoint id of a customized speech model that is used for transcription.
     * @member ConversationTranscriber.prototype.endpointId
     * @function
     * @public
     * @returns {string} the endpoint id of a customized speech model that is used for speech recognition.
     */
    get endpointId() {
      return n.Contracts.throwIfDisposed(this.privDisposedRecognizer), this.properties.getProperty(r.PropertyId.SpeechServiceConnection_EndpointId, "00000000-0000-0000-0000-000000000000");
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member ConversationTranscriber.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(r.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * @member ConversationTranscriber.prototype.authorizationToken
     * @function
     * @public
     * @param {string} token - Authorization token.
     */
    set authorizationToken(a) {
      n.Contracts.throwIfNullOrWhitespace(a, "token"), this.properties.setProperty(r.PropertyId.SpeechServiceAuthorization_Token, a);
    }
    /**
     * Gets the spoken language of transcription.
     * @member ConversationTranscriber.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @returns {string} The spoken language of transcription.
     */
    get speechRecognitionLanguage() {
      return n.Contracts.throwIfDisposed(this.privDisposedRecognizer), this.properties.getProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage);
    }
    /**
     * Gets the output format of transcription.
     * @member ConversationTranscriber.prototype.outputFormat
     * @function
     * @public
     * @returns {OutputFormat} The output format of transcription.
     */
    get outputFormat() {
      return n.Contracts.throwIfDisposed(this.privDisposedRecognizer), this.properties.getProperty(t.OutputFormatPropertyName, r.OutputFormat[r.OutputFormat.Simple]) === r.OutputFormat[r.OutputFormat.Simple] ? r.OutputFormat.Simple : r.OutputFormat.Detailed;
    }
    /**
     * The collection of properties and their values defined for this conversation transcriber.
     * @member ConversationTranscriber.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this SpeechRecognizer.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Starts conversation transcription, until stopTranscribingAsync() is called.
     * User must subscribe to events to receive transcription results.
     * @member ConversationTranscriber.prototype.startTranscribingAsync
     * @function
     * @public
     * @param cb - Callback invoked once the transcription has started.
     * @param err - Callback invoked in case of an error.
     */
    startTranscribingAsync(a, i) {
      e.marshalPromiseToCallbacks(this.startContinuousRecognitionAsyncImpl(t.RecognitionMode.Conversation), a, i);
    }
    /**
     * Stops conversation transcription.
     * @member ConversationTranscriber.prototype.stopTranscribingAsync
     * @function
     * @public
     * @param cb - Callback invoked once the transcription has stopped.
     * @param err - Callback invoked in case of an error.
     */
    stopTranscribingAsync(a, i) {
      e.marshalPromiseToCallbacks(this.stopContinuousRecognitionAsyncImpl(), a, i);
    }
    /**
     * closes all external resources held by an instance of this class.
     * @member ConversationTranscriber.prototype.close
     * @function
     * @public
     */
    close(a, i) {
      n.Contracts.throwIfDisposed(this.privDisposedRecognizer), e.marshalPromiseToCallbacks(this.dispose(!0), a, i);
    }
    /**
     * Disposes any resources held by the object.
     * @member SpeechRecognizer.prototype.dispose
     * @function
     * @public
     * @param {boolean} disposing - true if disposing the object.
     */
    async dispose(a) {
      this.privDisposedRecognizer || (a && (this.privDisposedRecognizer = !0, await this.implRecognizerStop()), await super.dispose(a));
    }
    createRecognizerConfig(a) {
      return new t.RecognizerConfig(a, this.privProperties);
    }
    createServiceRecognizer(a, i, c, u) {
      const p = c;
      return u.isSpeakerDiarizationEnabled = !0, new t.ConversationTranscriptionServiceRecognizer(a, i, p, u, this);
    }
  };
  return oi.ConversationTranscriber = s, oi;
}
var en = {}, Qd;
function yR() {
  if (Qd)
    return en;
  Qd = 1, Object.defineProperty(en, "__esModule", { value: !0 }), en.Participant = en.User = void 0;
  const t = R();
  class e {
    constructor(s) {
      this.privUserId = s;
    }
    get userId() {
      return this.privUserId;
    }
  }
  en.User = e;
  class n {
    constructor(s, o, a, i, c, u, p, d) {
      this.privId = s, this.privAvatar = o, this.privDisplayName = a, this.privIsHost = i, this.privIsMuted = c, this.privIsUsingTts = u, this.privPreferredLanguage = p, this.privVoice = d, this.privProperties = new t.PropertyCollection();
    }
    get avatar() {
      return this.privAvatar;
    }
    get displayName() {
      return this.privDisplayName;
    }
    get id() {
      return this.privId;
    }
    get preferredLanguage() {
      return this.privPreferredLanguage;
    }
    get isHost() {
      return this.privIsHost;
    }
    get isMuted() {
      return this.privIsMuted;
    }
    get isUsingTts() {
      return this.privIsUsingTts;
    }
    get voice() {
      return this.privVoice;
    }
    get properties() {
      return this.privProperties;
    }
    static From(s, o, a) {
      return new n(s, "", s, !1, !1, !1, o, a);
    }
  }
  return en.Participant = n, en;
}
var Jf = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.ParticipantChangedReason = void 0, function(e) {
    e[e.JoinedConversation = 0] = "JoinedConversation", e[e.LeftConversation = 1] = "LeftConversation", e[e.Updated = 2] = "Updated";
  }(t.ParticipantChangedReason || (t.ParticipantChangedReason = {}));
})(Jf);
var tn = {}, Yd;
function CR() {
  if (Yd)
    return tn;
  Yd = 1, Object.defineProperty(tn, "__esModule", { value: !0 }), tn.MeetingImpl = tn.Meeting = void 0;
  const t = A(), e = k(), n = N, r = R();
  let s = class {
    constructor() {
    }
    /**
     * Create a meeting
     * @param speechConfig
     * @param meetingId
     * @param cb
     * @param err
     */
    static createMeetingAsync(i, c, u, p) {
      if (n.Contracts.throwIfNullOrUndefined(i, t.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "config")), n.Contracts.throwIfNullOrUndefined(i.region, t.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "SpeechServiceConnection_Region")), n.Contracts.throwIfNull(c, "meetingId"), c.length === 0)
        throw new Error("meetingId cannot be empty");
      !i.subscriptionKey && !i.getProperty(r.PropertyId[r.PropertyId.SpeechServiceAuthorization_Token]) && n.Contracts.throwIfNullOrUndefined(i.subscriptionKey, t.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "SpeechServiceConnection_Key"));
      const d = new o(i, c);
      return e.marshalPromiseToCallbacks((async () => {
      })(), u, p), d;
    }
  };
  tn.Meeting = s;
  class o extends s {
    /**
     * Create a Meeting impl
     * @param speechConfig
     * @param {string} id - optional conversationId
     */
    constructor(i, c) {
      super(), this.privErrors = t.ConversationConnectionConfig.restErrors, this.onConnected = (d) => {
        var l;
        this.privIsConnected = !0;
        try {
          (l = this.privConversationTranslator) != null && l.sessionStarted && this.privConversationTranslator.sessionStarted(this.privConversationTranslator, d);
        } catch {
        }
      }, this.onDisconnected = (d) => {
        var l;
        try {
          (l = this.privConversationTranslator) != null && l.sessionStopped && this.privConversationTranslator.sessionStopped(this.privConversationTranslator, d);
        } catch {
        } finally {
          this.close(!1);
        }
      }, this.onCanceled = (d, l) => {
        var h;
        try {
          (h = this.privConversationTranslator) != null && h.canceled && this.privConversationTranslator.canceled(this.privConversationTranslator, l);
        } catch {
        }
      }, this.onParticipantUpdateCommandReceived = (d, l) => {
        try {
          const h = this.privParticipants.getParticipant(l.id);
          if (h !== void 0) {
            switch (l.key) {
              case t.ConversationTranslatorCommandTypes.changeNickname:
                h.displayName = l.value;
                break;
              case t.ConversationTranslatorCommandTypes.setUseTTS:
                h.isUsingTts = l.value;
                break;
              case t.ConversationTranslatorCommandTypes.setProfanityFiltering:
                h.profanity = l.value;
                break;
              case t.ConversationTranslatorCommandTypes.setMute:
                h.isMuted = l.value;
                break;
              case t.ConversationTranslatorCommandTypes.setTranslateToLanguages:
                h.translateToLanguages = l.value;
                break;
            }
            this.privParticipants.addOrUpdateParticipant(h), this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new r.ConversationParticipantsChangedEventArgs(r.ParticipantChangedReason.Updated, [this.toParticipant(h)], l.sessionId));
          }
        } catch {
        }
      }, this.onLockRoomCommandReceived = () => {
      }, this.onMuteAllCommandReceived = (d, l) => {
        try {
          this.privParticipants.participants.forEach((h) => h.isMuted = h.isHost ? !1 : l.isMuted), this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new r.ConversationParticipantsChangedEventArgs(r.ParticipantChangedReason.Updated, this.toParticipants(!1), l.sessionId));
        } catch {
        }
      }, this.onParticipantJoinCommandReceived = (d, l) => {
        try {
          const h = this.privParticipants.addOrUpdateParticipant(l.participant);
          h !== void 0 && this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new r.ConversationParticipantsChangedEventArgs(r.ParticipantChangedReason.JoinedConversation, [this.toParticipant(h)], l.sessionId));
        } catch {
        }
      }, this.onParticipantLeaveCommandReceived = (d, l) => {
        try {
          const h = this.privParticipants.getParticipant(l.participant.id);
          h !== void 0 && (this.privParticipants.deleteParticipant(l.participant.id), this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new r.ConversationParticipantsChangedEventArgs(r.ParticipantChangedReason.LeftConversation, [this.toParticipant(h)], l.sessionId)));
        } catch {
        }
      }, this.onTranslationReceived = (d, l) => {
        try {
          switch (l.command) {
            case t.ConversationTranslatorMessageTypes.final:
              this.privConversationTranslator && this.privConversationTranslator.transcribed(this.privConversationTranslator, new r.ConversationTranslationEventArgs(l.payload, void 0, l.sessionId));
              break;
            case t.ConversationTranslatorMessageTypes.partial:
              this.privConversationTranslator && this.privConversationTranslator.transcribing(this.privConversationTranslator, new r.ConversationTranslationEventArgs(l.payload, void 0, l.sessionId));
              break;
            case t.ConversationTranslatorMessageTypes.instantMessage:
              this.privConversationTranslator && this.privConversationTranslator.textMessageReceived(this.privConversationTranslator, new r.ConversationTranslationEventArgs(l.payload, void 0, l.sessionId));
              break;
          }
        } catch {
        }
      }, this.onParticipantsListReceived = (d, l) => {
        var h;
        try {
          if (l.sessionToken !== void 0 && l.sessionToken !== null && (this.privRoom.token = l.sessionToken), this.privParticipants.participants = [...l.participants], this.privParticipants.me !== void 0 && (this.privIsReady = !0), this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new r.ConversationParticipantsChangedEventArgs(r.ParticipantChangedReason.JoinedConversation, this.toParticipants(!0), l.sessionId)), this.me.isHost) {
            const v = (h = this.privConversationTranslator) == null ? void 0 : h.properties.getProperty(r.PropertyId.ConversationTranslator_Name);
            v !== void 0 && v.length > 0 && v !== this.me.displayName && this.changeNicknameAsync(v);
          }
        } catch {
        }
      }, this.onConversationExpiration = (d, l) => {
        try {
          this.privConversationTranslator && this.privConversationTranslator.conversationExpiration(this.privConversationTranslator, l);
        } catch {
        }
      }, this.privIsConnected = !1, this.privIsDisposed = !1, this.privConversationId = "", this.privProperties = new r.PropertyCollection(), this.privManager = new t.ConversationManager(), i.getProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_RecoLanguage]) || i.setProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_RecoLanguage], t.ConversationConnectionConfig.defaultLanguageCode), this.privLanguage = i.getProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_RecoLanguage]), this.privConversationId = c, this.privConfig = i;
      const p = i;
      n.Contracts.throwIfNull(p, "speechConfig"), this.privProperties = p.properties.clone(), this.privIsConnected = !1, this.privParticipants = new t.InternalParticipants(), this.privIsReady = !1, this.privTextMessageMaxLength = 1e3;
    }
    // get the internal data about a conversation
    get room() {
      return this.privRoom;
    }
    // get the wrapper for connecting to the websockets
    get connection() {
      return this.privConversationRecognizer;
    }
    // get the config
    get config() {
      return this.privConfig;
    }
    // get the meeting Id
    get meetingId() {
      return this.privRoom ? this.privRoom.roomId : this.privConversationId;
    }
    // get the properties
    get properties() {
      return this.privProperties;
    }
    // get the speech language
    get speechRecognitionLanguage() {
      return this.privLanguage;
    }
    get isMutedByHost() {
      var i, c;
      return (i = this.privParticipants.me) != null && i.isHost ? !1 : (c = this.privParticipants.me) == null ? void 0 : c.isMuted;
    }
    get isConnected() {
      return this.privIsConnected && this.privIsReady;
    }
    get participants() {
      return this.toParticipants(!0);
    }
    get me() {
      return this.toParticipant(this.privParticipants.me);
    }
    get host() {
      return this.toParticipant(this.privParticipants.host);
    }
    get transcriberRecognizer() {
      return this.privTranscriberRecognizer;
    }
    get meetingInfo() {
      const i = this.meetingId, c = this.participants.map((d) => ({
        id: d.id,
        preferredLanguage: d.preferredLanguage,
        voice: d.voice
      })), u = {};
      for (const d of t.ConversationConnectionConfig.transcriptionEventKeys) {
        const l = this.properties.getProperty(d, "");
        l !== "" && (u[d] = l);
      }
      return { id: i, participants: c, meetingProperties: u };
    }
    get canSend() {
      var i;
      return this.privIsConnected && !((i = this.privParticipants.me) != null && i.isMuted);
    }
    get canSendAsHost() {
      var i;
      return this.privIsConnected && ((i = this.privParticipants.me) == null ? void 0 : i.isHost);
    }
    // get / set the speech auth token
    // eslint-disable-next-line @typescript-eslint/member-ordering
    get authorizationToken() {
      return this.privToken;
    }
    set authorizationToken(i) {
      n.Contracts.throwIfNullOrWhitespace(i, "authorizationToken"), this.privToken = i;
    }
    /**
     * Create a new meeting as Host
     * @param cb
     * @param err
     */
    createMeetingAsync(i, c) {
      try {
        this.privConversationRecognizer && this.handleError(new Error(this.privErrors.permissionDeniedStart), c), this.privManager.createOrJoin(this.privProperties, void 0, (u) => {
          u || this.handleError(new Error(this.privErrors.permissionDeniedConnect), c), this.privRoom = u, this.handleCallback(i, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Starts a new meeting as host.
     * @param cb
     * @param err
     */
    startMeetingAsync(i, c) {
      try {
        this.privConversationRecognizer && this.handleError(new Error(this.privErrors.permissionDeniedStart), c), n.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedConnect), this.privParticipants.meId = this.privRoom.participantId, this.privConversationRecognizer.connected = this.onConnected, this.privConversationRecognizer.disconnected = this.onDisconnected, this.privConversationRecognizer.canceled = this.onCanceled, this.privConversationRecognizer.participantUpdateCommandReceived = this.onParticipantUpdateCommandReceived, this.privConversationRecognizer.lockRoomCommandReceived = this.onLockRoomCommandReceived, this.privConversationRecognizer.muteAllCommandReceived = this.onMuteAllCommandReceived, this.privConversationRecognizer.participantJoinCommandReceived = this.onParticipantJoinCommandReceived, this.privConversationRecognizer.participantLeaveCommandReceived = this.onParticipantLeaveCommandReceived, this.privConversationRecognizer.translationReceived = this.onTranslationReceived, this.privConversationRecognizer.participantsListReceived = this.onParticipantsListReceived, this.privConversationRecognizer.conversationExpiration = this.onConversationExpiration, this.privConversationRecognizer.connect(this.privRoom.token, () => {
          this.handleCallback(i, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Join a meeting as a participant.
     * @param { IParticipant } participant - participant to add
     * @param cb
     * @param err
     */
    addParticipantAsync(i, c, u) {
      n.Contracts.throwIfNullOrUndefined(i, "Participant"), e.marshalPromiseToCallbacks(this.addParticipantImplAsync(i), c, u);
    }
    /**
     * Join a meeting as a participant.
     * @param meeting
     * @param nickname
     * @param lang
     * @param cb
     * @param err
     */
    joinMeetingAsync(i, c, u, p, d) {
      try {
        n.Contracts.throwIfNullOrWhitespace(i, this.privErrors.invalidArgs.replace("{arg}", "conversationId")), n.Contracts.throwIfNullOrWhitespace(c, this.privErrors.invalidArgs.replace("{arg}", "nickname")), n.Contracts.throwIfNullOrWhitespace(u, this.privErrors.invalidArgs.replace("{arg}", "language")), this.privManager.createOrJoin(this.privProperties, i, (l) => {
          n.Contracts.throwIfNullOrUndefined(l, this.privErrors.permissionDeniedConnect), this.privRoom = l, this.privConfig.authorizationToken = l.cognitiveSpeechAuthToken, p && p(l.cognitiveSpeechAuthToken);
        }, (l) => {
          this.handleError(l, d);
        });
      } catch (l) {
        this.handleError(l, d);
      }
    }
    /**
     * Deletes a meeting
     * @param cb
     * @param err
     */
    deleteMeetingAsync(i, c) {
      e.marshalPromiseToCallbacks(this.deleteMeetingImplAsync(), i, c);
    }
    async deleteMeetingImplAsync() {
      n.Contracts.throwIfNullOrUndefined(this.privProperties, this.privErrors.permissionDeniedConnect), n.Contracts.throwIfNullOrWhitespace(this.privRoom.token, this.privErrors.permissionDeniedConnect), await this.privManager.leave(this.privProperties, this.privRoom.token), this.dispose();
    }
    /**
     * Issues a request to close the client websockets
     * @param cb
     * @param err
     */
    endMeetingAsync(i, c) {
      e.marshalPromiseToCallbacks(this.endMeetingImplAsync(), i, c);
    }
    endMeetingImplAsync() {
      return this.close(!0);
    }
    /**
     * Issues a request to lock the conversation
     * @param cb
     * @param err
     */
    lockMeetingAsync(i, c) {
      try {
        n.Contracts.throwIfDisposed(this.privIsDisposed), n.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), n.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "lock")), c), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getLockCommand(!0), () => {
          this.handleCallback(i, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Issues a request to mute the meeting
     * @param cb
     * @param err
     */
    muteAllParticipantsAsync(i, c) {
      try {
        n.Contracts.throwIfDisposed(this.privIsDisposed), n.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), n.Contracts.throwIfNullOrUndefined(this.privConversationRecognizer, this.privErrors.permissionDeniedSend), n.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "mute")), c), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMuteAllCommand(!0), () => {
          this.handleCallback(i, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Issues a request to mute a participant in the meeting
     * @param userId
     * @param cb
     * @param err
     */
    muteParticipantAsync(i, c, u) {
      try {
        n.Contracts.throwIfDisposed(this.privIsDisposed), n.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), n.Contracts.throwIfNullOrWhitespace(i, this.privErrors.invalidArgs.replace("{arg}", "userId")), n.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), !this.me.isHost && this.me.id !== i && this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "mute")), u), this.privParticipants.getParticipantIndex(i) === -1 && this.handleError(new Error(this.privErrors.invalidParticipantRequest), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMuteCommand(i, !0), () => {
          this.handleCallback(c, u);
        }, (d) => {
          this.handleError(d, u);
        });
      } catch (p) {
        this.handleError(p, u);
      }
    }
    /**
     * Issues a request to remove a participant from the conversation
     * @param userId
     * @param cb
     * @param err
     */
    removeParticipantAsync(i, c, u) {
      try {
        if (n.Contracts.throwIfDisposed(this.privIsDisposed), this.privTranscriberRecognizer && i.hasOwnProperty("id"))
          e.marshalPromiseToCallbacks(this.removeParticipantImplAsync(i), c, u);
        else {
          n.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), n.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "remove")), u);
          let p = "";
          typeof i == "string" ? p = i : i.hasOwnProperty("id") ? p = i.id : i.hasOwnProperty("userId") && (p = i.userId), n.Contracts.throwIfNullOrWhitespace(p, this.privErrors.invalidArgs.replace("{arg}", "userId")), this.participants.findIndex((l) => l.id === p) === -1 && this.handleError(new Error(this.privErrors.invalidParticipantRequest), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getEjectCommand(p), () => {
            this.handleCallback(c, u);
          }, (l) => {
            this.handleError(l, u);
          });
        }
      } catch (p) {
        this.handleError(p, u);
      }
    }
    /**
     * Issues a request to unlock the meeting
     * @param cb
     * @param err
     */
    unlockMeetingAsync(i, c) {
      try {
        n.Contracts.throwIfDisposed(this.privIsDisposed), n.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), n.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "unlock")), c), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getLockCommand(!1), () => {
          this.handleCallback(i, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Issues a request to unmute all participants in the meeting
     * @param cb
     * @param err
     */
    unmuteAllParticipantsAsync(i, c) {
      try {
        n.Contracts.throwIfDisposed(this.privIsDisposed), n.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), n.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "unmute all")), c), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMuteAllCommand(!1), () => {
          this.handleCallback(i, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Issues a request to unmute a participant in the meeting
     * @param userId
     * @param cb
     * @param err
     */
    unmuteParticipantAsync(i, c, u) {
      try {
        n.Contracts.throwIfDisposed(this.privIsDisposed), n.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), n.Contracts.throwIfNullOrWhitespace(i, this.privErrors.invalidArgs.replace("{arg}", "userId")), n.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), !this.me.isHost && this.me.id !== i && this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "mute")), u), this.privParticipants.getParticipantIndex(i) === -1 && this.handleError(new Error(this.privErrors.invalidParticipantRequest), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMuteCommand(i, !1), () => {
          this.handleCallback(c, u);
        }, (d) => {
          this.handleError(d, u);
        });
      } catch (p) {
        this.handleError(p, u);
      }
    }
    /**
     * Send a text message
     * @param message
     * @param cb
     * @param err
     */
    sendTextMessageAsync(i, c, u) {
      try {
        n.Contracts.throwIfDisposed(this.privIsDisposed), n.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), n.Contracts.throwIfNullOrWhitespace(i, this.privErrors.invalidArgs.replace("{arg}", "message")), n.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), i.length > this.privTextMessageMaxLength && this.handleError(new Error(this.privErrors.invalidArgs.replace("{arg}", "message length")), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMessageCommand(i), () => {
          this.handleCallback(c, u);
        }, (p) => {
          this.handleError(p, u);
        });
      } catch (p) {
        this.handleError(p, u);
      }
    }
    /**
     * Set translated to languages
     * @param {string[]} languages - languages to translate to
     * @param cb
     * @param err
     */
    setTranslatedLanguagesAsync(i, c, u) {
      try {
        n.Contracts.throwIfDisposed(this.privIsDisposed), n.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), n.Contracts.throwIfArrayEmptyOrWhitespace(i, this.privErrors.invalidArgs.replace("{arg}", "languages")), n.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getSetTranslateToLanguagesCommand(i), () => {
          this.handleCallback(c, u);
        }, (p) => {
          this.handleError(p, u);
        });
      } catch (p) {
        this.handleError(p, u);
      }
    }
    /**
     * Change nickname
     * @param {string} nickname - new nickname for the room
     * @param cb
     * @param err
     */
    changeNicknameAsync(i, c, u) {
      try {
        n.Contracts.throwIfDisposed(this.privIsDisposed), n.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), n.Contracts.throwIfNullOrWhitespace(i, this.privErrors.invalidArgs.replace("{arg}", "nickname")), n.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getChangeNicknameCommand(i), () => {
          this.handleCallback(c, u);
        }, (p) => {
          this.handleError(p, u);
        });
      } catch (p) {
        this.handleError(p, u);
      }
    }
    isDisposed() {
      return this.privIsDisposed;
    }
    dispose() {
      this.isDisposed || (this.privIsDisposed = !0, this.config && this.config.close(), this.privConfig = void 0, this.privLanguage = void 0, this.privProperties = void 0, this.privRoom = void 0, this.privToken = void 0, this.privManager = void 0, this.privIsConnected = !1, this.privIsReady = !1, this.privParticipants = void 0);
    }
    async connectTranscriberRecognizer(i) {
      this.privTranscriberRecognizer && await this.privTranscriberRecognizer.close(), await i.enforceAudioGating(), this.privTranscriberRecognizer = i, this.privTranscriberRecognizer.meeting = this;
    }
    getKeepAlive() {
      const i = this.me ? this.me.displayName : "default_nickname";
      return JSON.stringify({
        id: "0",
        nickname: i,
        participantId: this.privRoom.participantId,
        roomId: this.privRoom.roomId,
        type: t.ConversationTranslatorMessageTypes.keepAlive
      });
    }
    /* eslint-enable @typescript-eslint/typedef */
    addParticipantImplAsync(i) {
      if (this.privParticipants.addOrUpdateParticipant(i) !== void 0 && this.privTranscriberRecognizer) {
        const u = this.meetingInfo;
        return u.participants = [i], this.privTranscriberRecognizer.pushMeetingEvent(u, "join");
      }
    }
    removeParticipantImplAsync(i) {
      this.privParticipants.deleteParticipant(i.id);
      const c = this.meetingInfo;
      return c.participants = [i], this.privTranscriberRecognizer.pushMeetingEvent(c, "leave");
    }
    async close(i) {
      var c;
      try {
        this.privIsConnected = !1, await ((c = this.privConversationRecognizer) == null ? void 0 : c.close()), this.privConversationRecognizer = void 0, this.privConversationTranslator && this.privConversationTranslator.dispose();
      } catch (u) {
        throw u;
      }
      i && this.dispose();
    }
    /** Helpers */
    handleCallback(i, c) {
      if (i) {
        try {
          i();
        } catch (u) {
          c && c(u);
        }
        i = void 0;
      }
    }
    handleError(i, c) {
      if (c)
        if (i instanceof Error) {
          const u = i;
          c(u.name + ": " + u.message);
        } else
          c(i);
    }
    /** Participant Helpers */
    toParticipants(i) {
      const c = this.privParticipants.participants.map((u) => this.toParticipant(u));
      return i ? c : c.filter((u) => u.isHost === !1);
    }
    toParticipant(i) {
      return new r.Participant(i.id, i.avatar, i.displayName, i.isHost, i.isMuted, i.isUsingTts, i.preferredLanguage, i.voice);
    }
    getMuteAllCommand(i) {
      return n.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingd"), n.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), JSON.stringify({
        command: t.ConversationTranslatorCommandTypes.setMuteAll,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: t.ConversationTranslatorMessageTypes.participantCommand,
        value: i
      });
    }
    getMuteCommand(i, c) {
      return n.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId"), n.Contracts.throwIfNullOrWhitespace(i, "participantId"), JSON.stringify({
        command: t.ConversationTranslatorCommandTypes.setMute,
        // eslint-disable-next-line object-shorthand
        participantId: i,
        roomid: this.privRoom.roomId,
        type: t.ConversationTranslatorMessageTypes.participantCommand,
        value: c
      });
    }
    getLockCommand(i) {
      return n.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingId"), n.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), JSON.stringify({
        command: t.ConversationTranslatorCommandTypes.setLockState,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: t.ConversationTranslatorMessageTypes.participantCommand,
        value: i
      });
    }
    getEjectCommand(i) {
      return n.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingId"), n.Contracts.throwIfNullOrWhitespace(i, "participantId"), JSON.stringify({
        command: t.ConversationTranslatorCommandTypes.ejectParticipant,
        // eslint-disable-next-line object-shorthand
        participantId: i,
        roomid: this.privRoom.roomId,
        type: t.ConversationTranslatorMessageTypes.participantCommand
      });
    }
    getSetTranslateToLanguagesCommand(i) {
      return n.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingId"), n.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), JSON.stringify({
        command: t.ConversationTranslatorCommandTypes.setTranslateToLanguages,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: t.ConversationTranslatorMessageTypes.participantCommand,
        value: i
      });
    }
    getChangeNicknameCommand(i) {
      return n.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingId"), n.Contracts.throwIfNullOrWhitespace(i, "nickname"), n.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), JSON.stringify({
        command: t.ConversationTranslatorCommandTypes.changeNickname,
        nickname: i,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: t.ConversationTranslatorMessageTypes.participantCommand,
        value: i
      });
    }
    getMessageCommand(i) {
      return n.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingId"), n.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), n.Contracts.throwIfNullOrWhitespace(i, "message"), JSON.stringify({
        participantId: this.privRoom.participantId,
        roomId: this.privRoom.roomId,
        text: i,
        type: t.ConversationTranslatorMessageTypes.instantMessage
      });
    }
  }
  return tn.MeetingImpl = o, tn;
}
var ai = {}, Zd;
function _R() {
  if (Zd)
    return ai;
  Zd = 1, Object.defineProperty(ai, "__esModule", { value: !0 }), ai.MeetingTranscriptionCanceledEventArgs = void 0;
  const t = Cs();
  class e extends t.CancellationEventArgsBase {
  }
  return ai.MeetingTranscriptionCanceledEventArgs = e, ai;
}
var ci = {}, Xd;
function RR() {
  if (Xd)
    return ci;
  Xd = 1, Object.defineProperty(ci, "__esModule", { value: !0 }), ci.MeetingTranscriber = void 0;
  const t = A(), e = k(), n = N, r = R(), s = Bu();
  let o = class {
    /**
     * MeetingTranscriber constructor.
     * @constructor
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
     */
    constructor(i) {
      this.privAudioConfig = i, this.privProperties = new r.PropertyCollection(), this.privRecognizer = void 0, this.privDisposedRecognizer = !1;
    }
    /**
     * Gets the spoken language of recognition.
     * @member MeetingTranscriber.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @returns {string} The spoken language of recognition.
     */
    get speechRecognitionLanguage() {
      return n.Contracts.throwIfDisposed(this.privDisposedRecognizer), this.properties.getProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage);
    }
    /**
     * The collection of properties and their values defined for this MeetingTranscriber.
     * @member MeetingTranscriber.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this MeetingTranscriber.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * @Internal
     * Internal data member to support fromRecognizer* pattern methods on other classes.
     * Do not use externally, object returned will change without warning or notice.
     */
    get internalData() {
      return this.privRecognizer.internalData;
    }
    /**
     * @Deprecated
     * @Obsolete
     * Please use the Connection.fromRecognizer pattern to obtain a connection object
     */
    get connection() {
      return r.Connection.fromRecognizer(this.privRecognizer);
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member MeetingTranscriber.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(r.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * @member MeetingTranscriber.prototype.authorizationToken
     * @function
     * @public
     * @param {string} token - Authorization token.
     */
    set authorizationToken(i) {
      n.Contracts.throwIfNullOrWhitespace(i, "token"), this.properties.setProperty(r.PropertyId.SpeechServiceAuthorization_Token, i);
    }
    /**
     * @param {Meeting} meeting - meeting to be recognized
     */
    joinMeetingAsync(i, c, u) {
      const p = i;
      n.Contracts.throwIfNullOrUndefined(s.MeetingImpl, "Meeting"), this.privRecognizer = new t.TranscriberRecognizer(i.config, this.privAudioConfig), n.Contracts.throwIfNullOrUndefined(this.privRecognizer, "Recognizer"), this.privRecognizer.connectMeetingCallbacks(this), e.marshalPromiseToCallbacks(p.connectTranscriberRecognizer(this.privRecognizer), c, u);
    }
    /**
     * Starts meeting transcription, until stopTranscribingAsync() is called.
     * User must subscribe to events to receive transcription results.
     * @member MeetingTranscriber.prototype.startTranscribingAsync
     * @function
     * @public
     * @param cb - Callback invoked once the transcription has started.
     * @param err - Callback invoked in case of an error.
     */
    startTranscribingAsync(i, c) {
      this.privRecognizer.startContinuousRecognitionAsync(i, c);
    }
    /**
     * Starts meeting transcription, until stopTranscribingAsync() is called.
     * User must subscribe to events to receive transcription results.
     * @member MeetingTranscriber.prototype.stopTranscribingAsync
     * @function
     * @public
     * @param cb - Callback invoked once the transcription has started.
     * @param err - Callback invoked in case of an error.
     */
    stopTranscribingAsync(i, c) {
      this.privRecognizer.stopContinuousRecognitionAsync(i, c);
    }
    /**
     * Leave the current meeting. After this is called, you will no longer receive any events.
     */
    leaveMeetingAsync(i, c) {
      this.privRecognizer.disconnectCallbacks(), e.marshalPromiseToCallbacks((async () => {
      })(), i, c);
    }
    /**
     * closes all external resources held by an instance of this class.
     * @member MeetingTranscriber.prototype.close
     * @function
     * @public
     */
    close(i, c) {
      n.Contracts.throwIfDisposed(this.privDisposedRecognizer), e.marshalPromiseToCallbacks(this.dispose(!0), i, c);
    }
    /**
     * Disposes any resources held by the object.
     * @member MeetingTranscriber.prototype.dispose
     * @function
     * @public
     * @param {boolean} disposing - true if disposing the object.
     */
    async dispose(i) {
      this.privDisposedRecognizer || (this.privRecognizer && (await this.privRecognizer.close(), this.privRecognizer = void 0), i && (this.privDisposedRecognizer = !0));
    }
  };
  return ci.MeetingTranscriber = o, ci;
}
var ui = {}, el;
function PR() {
  if (el)
    return ui;
  el = 1, Object.defineProperty(ui, "__esModule", { value: !0 }), ui.ConversationTranscriptionResult = void 0;
  const t = R();
  let e = class extends t.RecognitionResult {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @public
     * @param {string} resultId - The result id.
     * @param {ResultReason} reason - The reason.
     * @param {string} text - The recognized text.
     * @param {number} duration - The duration.
     * @param {number} offset - The offset into the stream.
     * @param {string} language - Primary Language detected, if provided.
     * @param {string} languageDetectionConfidence - Primary Language confidence ("Unknown," "Low," "Medium," "High"...), if provided.
     * @param {string} speakerId - speaker id for conversation transcription.
     * @param {string} errorDetails - Error details, if provided.
     * @param {string} json - Additional Json, if provided.
     * @param {PropertyCollection} properties - Additional properties, if provided.
     */
    constructor(r, s, o, a, i, c, u, p, d, l, h) {
      super(r, s, o, a, i, c, u, d, l, h), this.privSpeakerId = p;
    }
    /**
     * speaker id
     * @member ConversationTranscriptionResult.prototype.speakerId
     * @function
     * @public
     * @returns {string} id of speaker in given result
     */
    get speakerId() {
      return this.privSpeakerId;
    }
  };
  return ui.ConversationTranscriptionResult = e, ui;
}
var tl;
function Bu() {
  return tl || (tl = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 });
    var e = Wf();
    Object.defineProperty(t, "Conversation", { enumerable: !0, get: function() {
      return e.Conversation;
    } }), Object.defineProperty(t, "ConversationImpl", { enumerable: !0, get: function() {
      return e.ConversationImpl;
    } });
    var n = ma;
    Object.defineProperty(t, "ConversationCommon", { enumerable: !0, get: function() {
      return n.ConversationCommon;
    } });
    var r = pR();
    Object.defineProperty(t, "ConversationExpirationEventArgs", { enumerable: !0, get: function() {
      return r.ConversationExpirationEventArgs;
    } });
    var s = dR();
    Object.defineProperty(t, "ConversationParticipantsChangedEventArgs", { enumerable: !0, get: function() {
      return s.ConversationParticipantsChangedEventArgs;
    } });
    var o = lR();
    Object.defineProperty(t, "ConversationTranslationCanceledEventArgs", { enumerable: !0, get: function() {
      return o.ConversationTranslationCanceledEventArgs;
    } });
    var a = hR();
    Object.defineProperty(t, "ConversationTranslationEventArgs", { enumerable: !0, get: function() {
      return a.ConversationTranslationEventArgs;
    } });
    var i = vR();
    Object.defineProperty(t, "ConversationTranslationResult", { enumerable: !0, get: function() {
      return i.ConversationTranslationResult;
    } });
    var c = mR();
    Object.defineProperty(t, "ConversationTranslator", { enumerable: !0, get: function() {
      return c.ConversationTranslator;
    } });
    var u = SR();
    Object.defineProperty(t, "ConversationTranscriber", { enumerable: !0, get: function() {
      return u.ConversationTranscriber;
    } });
    var p = yR();
    Object.defineProperty(t, "Participant", { enumerable: !0, get: function() {
      return p.Participant;
    } }), Object.defineProperty(t, "User", { enumerable: !0, get: function() {
      return p.User;
    } });
    var d = Jf;
    Object.defineProperty(t, "ParticipantChangedReason", { enumerable: !0, get: function() {
      return d.ParticipantChangedReason;
    } });
    var l = CR();
    Object.defineProperty(t, "Meeting", { enumerable: !0, get: function() {
      return l.Meeting;
    } }), Object.defineProperty(t, "MeetingImpl", { enumerable: !0, get: function() {
      return l.MeetingImpl;
    } });
    var h = _R();
    Object.defineProperty(t, "MeetingTranscriptionCanceledEventArgs", { enumerable: !0, get: function() {
      return h.MeetingTranscriptionCanceledEventArgs;
    } });
    var v = RR();
    Object.defineProperty(t, "MeetingTranscriber", { enumerable: !0, get: function() {
      return v.MeetingTranscriber;
    } });
    var g = PR();
    Object.defineProperty(t, "ConversationTranscriptionResult", { enumerable: !0, get: function() {
      return g.ConversationTranscriptionResult;
    } });
  }(Cc)), Cc;
}
var nn = {}, nl;
function qu() {
  if (nl)
    return nn;
  nl = 1, Object.defineProperty(nn, "__esModule", { value: !0 }), nn.SynthesisRequest = nn.Synthesizer = void 0;
  const t = A(), e = k(), n = N, r = R();
  let s = class Gf {
    /**
     * Creates and initializes an instance of a Recognizer
     * @constructor
     * @param {SpeechConfig} speechConfig - The speech config to initialize the synthesizer.
     */
    constructor(i) {
      const c = i;
      n.Contracts.throwIfNull(c, "speechConfig"), this.privProperties = c.properties.clone(), this.privDisposed = !1, this.privSynthesizing = !1, this.synthesisRequestQueue = new e.Queue();
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member Synthesizer.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(r.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * @member Synthesizer.prototype.authorizationToken
     * @function
     * @public
     * @param {string} token - Authorization token.
     */
    set authorizationToken(i) {
      n.Contracts.throwIfNullOrWhitespace(i, "token"), this.properties.setProperty(r.PropertyId.SpeechServiceAuthorization_Token, i);
    }
    /**
     * The collection of properties and their values defined for this Synthesizer.
     * @member Synthesizer.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this SpeechSynthesizer.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Indicates if auto detect source language is enabled
     * @member Synthesizer.prototype.autoDetectSourceLanguage
     * @function
     * @public
     * @returns {boolean} if auto detect source language is enabled
     */
    get autoDetectSourceLanguage() {
      return this.properties.getProperty(r.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages) === t.AutoDetectSourceLanguagesOpenRangeOptionName;
    }
    buildSsml(i) {
      const c = {
        "af-ZA": "af-ZA-AdriNeural",
        "am-ET": "am-ET-AmehaNeural",
        "ar-AE": "ar-AE-FatimaNeural",
        "ar-BH": "ar-BH-AliNeural",
        "ar-DZ": "ar-DZ-AminaNeural",
        "ar-EG": "ar-EG-SalmaNeural",
        "ar-IQ": "ar-IQ-BasselNeural",
        "ar-JO": "ar-JO-SanaNeural",
        "ar-KW": "ar-KW-FahedNeural",
        "ar-LY": "ar-LY-ImanNeural",
        "ar-MA": "ar-MA-JamalNeural",
        "ar-QA": "ar-QA-AmalNeural",
        "ar-SA": "ar-SA-HamedNeural",
        "ar-SY": "ar-SY-AmanyNeural",
        "ar-TN": "ar-TN-HediNeural",
        "ar-YE": "ar-YE-MaryamNeural",
        "bg-BG": "bg-BG-BorislavNeural",
        "bn-BD": "bn-BD-NabanitaNeural",
        "bn-IN": "bn-IN-BashkarNeural",
        "ca-ES": "ca-ES-JoanaNeural",
        "cs-CZ": "cs-CZ-AntoninNeural",
        "cy-GB": "cy-GB-AledNeural",
        "da-DK": "da-DK-ChristelNeural",
        "de-AT": "de-AT-IngridNeural",
        "de-CH": "de-CH-JanNeural",
        "de-DE": "de-DE-KatjaNeural",
        "el-GR": "el-GR-AthinaNeural",
        "en-AU": "en-AU-NatashaNeural",
        "en-CA": "en-CA-ClaraNeural",
        "en-GB": "en-GB-LibbyNeural",
        "en-HK": "en-HK-SamNeural",
        "en-IE": "en-IE-ConnorNeural",
        "en-IN": "en-IN-NeerjaNeural",
        "en-KE": "en-KE-AsiliaNeural",
        "en-NG": "en-NG-AbeoNeural",
        "en-NZ": "en-NZ-MitchellNeural",
        "en-PH": "en-PH-JamesNeural",
        "en-SG": "en-SG-LunaNeural",
        "en-TZ": "en-TZ-ElimuNeural",
        "en-US": "en-US-AvaMultilingualNeural",
        "en-ZA": "en-ZA-LeahNeural",
        "es-AR": "es-AR-ElenaNeural",
        "es-BO": "es-BO-MarceloNeural",
        "es-CL": "es-CL-CatalinaNeural",
        "es-CO": "es-CO-GonzaloNeural",
        "es-CR": "es-CR-JuanNeural",
        "es-CU": "es-CU-BelkysNeural",
        "es-DO": "es-DO-EmilioNeural",
        "es-EC": "es-EC-AndreaNeural",
        "es-ES": "es-ES-AlvaroNeural",
        "es-GQ": "es-GQ-JavierNeural",
        "es-GT": "es-GT-AndresNeural",
        "es-HN": "es-HN-CarlosNeural",
        "es-MX": "es-MX-DaliaNeural",
        "es-NI": "es-NI-FedericoNeural",
        "es-PA": "es-PA-MargaritaNeural",
        "es-PE": "es-PE-AlexNeural",
        "es-PR": "es-PR-KarinaNeural",
        "es-PY": "es-PY-MarioNeural",
        "es-SV": "es-SV-LorenaNeural",
        "es-US": "es-US-AlonsoNeural",
        "es-UY": "es-UY-MateoNeural",
        "es-VE": "es-VE-PaolaNeural",
        "et-EE": "et-EE-AnuNeural",
        "fa-IR": "fa-IR-DilaraNeural",
        "fi-FI": "fi-FI-SelmaNeural",
        "fil-PH": "fil-PH-AngeloNeural",
        "fr-BE": "fr-BE-CharlineNeural",
        "fr-CA": "fr-CA-SylvieNeural",
        "fr-CH": "fr-CH-ArianeNeural",
        "fr-FR": "fr-FR-DeniseNeural",
        "ga-IE": "ga-IE-ColmNeural",
        "gl-ES": "gl-ES-RoiNeural",
        "gu-IN": "gu-IN-DhwaniNeural",
        "he-IL": "he-IL-AvriNeural",
        "hi-IN": "hi-IN-MadhurNeural",
        "hr-HR": "hr-HR-GabrijelaNeural",
        "hu-HU": "hu-HU-NoemiNeural",
        "id-ID": "id-ID-ArdiNeural",
        "is-IS": "is-IS-GudrunNeural",
        "it-IT": "it-IT-IsabellaNeural",
        "ja-JP": "ja-JP-NanamiNeural",
        "jv-ID": "jv-ID-DimasNeural",
        "kk-KZ": "kk-KZ-AigulNeural",
        "km-KH": "km-KH-PisethNeural",
        "kn-IN": "kn-IN-GaganNeural",
        "ko-KR": "ko-KR-SunHiNeural",
        "lo-LA": "lo-LA-ChanthavongNeural",
        "lt-LT": "lt-LT-LeonasNeural",
        "lv-LV": "lv-LV-EveritaNeural",
        "mk-MK": "mk-MK-AleksandarNeural",
        "ml-IN": "ml-IN-MidhunNeural",
        "mr-IN": "mr-IN-AarohiNeural",
        "ms-MY": "ms-MY-OsmanNeural",
        "mt-MT": "mt-MT-GraceNeural",
        "my-MM": "my-MM-NilarNeural",
        "nb-NO": "nb-NO-PernilleNeural",
        "nl-BE": "nl-BE-ArnaudNeural",
        "nl-NL": "nl-NL-ColetteNeural",
        "pl-PL": "pl-PL-AgnieszkaNeural",
        "ps-AF": "ps-AF-GulNawazNeural",
        "pt-BR": "pt-BR-FranciscaNeural",
        "pt-PT": "pt-PT-DuarteNeural",
        "ro-RO": "ro-RO-AlinaNeural",
        "ru-RU": "ru-RU-SvetlanaNeural",
        "si-LK": "si-LK-SameeraNeural",
        "sk-SK": "sk-SK-LukasNeural",
        "sl-SI": "sl-SI-PetraNeural",
        "so-SO": "so-SO-MuuseNeural",
        "sr-RS": "sr-RS-NicholasNeural",
        "su-ID": "su-ID-JajangNeural",
        "sv-SE": "sv-SE-SofieNeural",
        "sw-KE": "sw-KE-RafikiNeural",
        "sw-TZ": "sw-TZ-DaudiNeural",
        "ta-IN": "ta-IN-PallaviNeural",
        "ta-LK": "ta-LK-KumarNeural",
        "ta-SG": "ta-SG-AnbuNeural",
        "te-IN": "te-IN-MohanNeural",
        "th-TH": "th-TH-PremwadeeNeural",
        "tr-TR": "tr-TR-AhmetNeural",
        "uk-UA": "uk-UA-OstapNeural",
        "ur-IN": "ur-IN-GulNeural",
        "ur-PK": "ur-PK-AsadNeural",
        "uz-UZ": "uz-UZ-MadinaNeural",
        "vi-VN": "vi-VN-HoaiMyNeural",
        "zh-CN": "zh-CN-XiaoxiaoNeural",
        "zh-HK": "zh-HK-HiuMaanNeural",
        "zh-TW": "zh-TW-HsiaoChenNeural",
        "zu-ZA": "zu-ZA-ThandoNeural"
      };
      let u = this.properties.getProperty(r.PropertyId.SpeechServiceConnection_SynthLanguage, "en-US"), p = this.properties.getProperty(r.PropertyId.SpeechServiceConnection_SynthVoice, ""), d = Gf.XMLEncode(i);
      return this.autoDetectSourceLanguage ? u = "en-US" : p = p || c[u], p && (d = `<voice name='${p}'>${d}</voice>`), d = `<speak version='1.0' xmlns='http://www.w3.org/2001/10/synthesis' xmlns:mstts='http://www.w3.org/2001/mstts' xmlns:emo='http://www.w3.org/2009/10/emotionml' xml:lang='${u}'>${d}</speak>`, d;
    }
    /**
     * This method performs cleanup of resources.
     * The Boolean parameter disposing indicates whether the method is called
     * from Dispose (if disposing is true) or from the finalizer (if disposing is false).
     * Derived classes should override this method to dispose resource if needed.
     * @member Synthesizer.prototype.dispose
     * @function
     * @public
     * @param {boolean} disposing - Flag to request disposal.
     */
    async dispose(i) {
      this.privDisposed || (i && this.privAdapter && await this.privAdapter.dispose(), this.privDisposed = !0);
    }
    async adapterSpeak() {
      if (!this.privDisposed && !this.privSynthesizing) {
        this.privSynthesizing = !0;
        const i = await this.synthesisRequestQueue.dequeue();
        return this.privAdapter.Speak(i.text, i.isSSML, i.requestId, i.cb, i.err, i.dataStream);
      }
    }
    createSynthesizerConfig(i) {
      return new t.SynthesizerConfig(i, this.privProperties);
    }
    // Does the generic synthesizer setup that is common across all synthesizer types.
    implCommonSynthesizeSetup() {
      let i = typeof window < "u" ? "Browser" : "Node", c = "unknown", u = "unknown";
      typeof navigator < "u" && (i = i + "/" + navigator.platform, c = navigator.userAgent, u = navigator.appVersion);
      const p = this.createSynthesizerConfig(new t.SpeechServiceConfig(new t.Context(new t.OS(i, c, u)))), d = this.privProperties.getProperty(r.PropertyId.SpeechServiceConnection_Key, void 0), l = d && d !== "" ? new t.CognitiveSubscriptionKeyAuthentication(d) : new t.CognitiveTokenAuthentication(() => {
        const h = this.privProperties.getProperty(r.PropertyId.SpeechServiceAuthorization_Token, void 0);
        return Promise.resolve(h);
      }, () => {
        const h = this.privProperties.getProperty(r.PropertyId.SpeechServiceAuthorization_Token, void 0);
        return Promise.resolve(h);
      });
      this.privAdapter = this.createSynthesisAdapter(l, this.privConnectionFactory, p), this.privRestAdapter = this.createRestSynthesisAdapter(l, p);
    }
    static XMLEncode(i) {
      return i.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
    }
  };
  nn.Synthesizer = s;
  class o {
    constructor(i, c, u, p, d, l) {
      this.requestId = i, this.text = c, this.isSSML = u, this.cb = p, this.err = d, this.dataStream = l;
    }
  }
  return nn.SynthesisRequest = o, nn;
}
var pi = {}, rl;
function ER() {
  if (rl)
    return pi;
  rl = 1, Object.defineProperty(pi, "__esModule", { value: !0 }), pi.SpeechSynthesizer = void 0;
  const t = A(), e = k(), n = ys, r = Vt, s = Re, o = N, a = R(), i = qu();
  let c = class Qf extends a.Synthesizer {
    /**
     * SpeechSynthesizer constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - An set of initial properties for this synthesizer.
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the synthesizer.
     */
    constructor(p, d) {
      super(p), d !== null && (d === void 0 ? this.audioConfig = typeof window > "u" ? void 0 : a.AudioConfig.fromDefaultSpeakerOutput() : this.audioConfig = d), this.privConnectionFactory = new t.SpeechSynthesisConnectionFactory(), this.implCommonSynthesizeSetup();
    }
    /**
     * SpeechSynthesizer constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - an set of initial properties for this synthesizer
     * @param {AutoDetectSourceLanguageConfig} autoDetectSourceLanguageConfig - An source language detection configuration associated with the synthesizer
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the synthesizer
     */
    static FromConfig(p, d, l) {
      const h = p;
      return d.properties.mergeTo(h.properties), new Qf(p, l);
    }
    /**
     * Executes speech synthesis on plain text.
     * The task returns the synthesis result.
     * @member SpeechSynthesizer.prototype.speakTextAsync
     * @function
     * @public
     * @param text - Text to be synthesized.
     * @param cb - Callback that received the SpeechSynthesisResult.
     * @param err - Callback invoked in case of an error.
     * @param stream - AudioOutputStream to receive the synthesized audio.
     */
    speakTextAsync(p, d, l, h) {
      this.speakImpl(p, !1, d, l, h);
    }
    /**
     * Executes speech synthesis on SSML.
     * The task returns the synthesis result.
     * @member SpeechSynthesizer.prototype.speakSsmlAsync
     * @function
     * @public
     * @param ssml - SSML to be synthesized.
     * @param cb - Callback that received the SpeechSynthesisResult.
     * @param err - Callback invoked in case of an error.
     * @param stream - AudioOutputStream to receive the synthesized audio.
     */
    speakSsmlAsync(p, d, l, h) {
      this.speakImpl(p, !0, d, l, h);
    }
    /**
     * Get list of synthesis voices available.
     * The task returns the synthesis voice result.
     * @member SpeechSynthesizer.prototype.getVoicesAsync
     * @function
     * @async
     * @public
     * @param locale - Locale of voices in BCP-47 format; if left empty, get all available voices.
     * @return {Promise<SynthesisVoicesResult>} - Promise of a SynthesisVoicesResult.
     */
    async getVoicesAsync(p = "") {
      return this.getVoices(p);
    }
    /**
     * Dispose of associated resources.
     * @member SpeechSynthesizer.prototype.close
     * @function
     * @public
     */
    close(p, d) {
      o.Contracts.throwIfDisposed(this.privDisposed), e.marshalPromiseToCallbacks(this.dispose(!0), p, d);
    }
    /**
     * @Internal
     * Do not use externally, object returned will change without warning or notice.
     */
    get internalData() {
      return this.privAdapter;
    }
    //
    // ################################################################################################################
    // IMPLEMENTATION.
    // ################################################################################################################
    //
    // Creates the synthesis adapter
    createSynthesisAdapter(p, d, l) {
      return new t.SpeechSynthesisAdapter(p, d, l, this, this.audioConfig);
    }
    createRestSynthesisAdapter(p, d) {
      return new t.SynthesisRestAdapter(d, p);
    }
    implCommonSynthesizeSetup() {
      super.implCommonSynthesizeSetup(), this.privAdapter.audioOutputFormat = r.AudioOutputFormatImpl.fromSpeechSynthesisOutputFormat(a.SpeechSynthesisOutputFormat[this.properties.getProperty(a.PropertyId.SpeechServiceConnection_SynthOutputFormat, void 0)]);
    }
    speakImpl(p, d, l, h, v) {
      try {
        o.Contracts.throwIfDisposed(this.privDisposed);
        const g = e.createNoDashGuid();
        let f;
        v instanceof a.PushAudioOutputStreamCallback ? f = new s.PushAudioOutputStreamImpl(v) : v instanceof a.PullAudioOutputStream ? f = v : v !== void 0 ? f = new n.AudioFileWriter(v) : f = void 0, this.synthesisRequestQueue.enqueue(new i.SynthesisRequest(g, p, d, (m) => {
          if (this.privSynthesizing = !1, l)
            try {
              l(m);
            } catch (S) {
              h && h(S);
            }
          l = void 0, this.adapterSpeak().catch(() => {
          });
        }, (m) => {
          h && h(m);
        }, f)), this.adapterSpeak().catch(() => {
        });
      } catch (g) {
        if (h)
          if (g instanceof Error) {
            const f = g;
            h(f.name + ": " + f.message);
          } else
            h(g);
        this.dispose(!0).catch(() => {
        });
      }
    }
    async getVoices(p) {
      const d = e.createNoDashGuid(), l = await this.privRestAdapter.getVoicesList(d);
      if (l.ok && Array.isArray(l.json)) {
        let h = l.json;
        return p && p.length > 0 && (h = h.filter((v) => !!v.Locale && v.Locale.toLowerCase() === p.toLowerCase())), new a.SynthesisVoicesResult(d, h, void 0);
      } else
        return new a.SynthesisVoicesResult(d, void 0, `Error: ${l.status}: ${l.statusText}`);
    }
  };
  return pi.SpeechSynthesizer = c, pi;
}
var Sa = {};
Object.defineProperty(Sa, "__esModule", { value: !0 });
Sa.SynthesisResult = void 0;
class TR {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {string} resultId - The result id.
   * @param {ResultReason} reason - The reason.
   * @param {string} errorDetails - Error details, if provided.
   * @param {PropertyCollection} properties - Additional properties, if provided.
   */
  constructor(e, n, r, s) {
    this.privResultId = e, this.privReason = n, this.privErrorDetails = r, this.privProperties = s;
  }
  /**
   * Specifies the result identifier.
   * @member SynthesisResult.prototype.resultId
   * @function
   * @public
   * @returns {string} Specifies the result identifier.
   */
  get resultId() {
    return this.privResultId;
  }
  /**
   * Specifies status of the result.
   * @member SynthesisResult.prototype.reason
   * @function
   * @public
   * @returns {ResultReason} Specifies status of the result.
   */
  get reason() {
    return this.privReason;
  }
  /**
   * In case of an unsuccessful synthesis, provides details of the occurred error.
   * @member SynthesisResult.prototype.errorDetails
   * @function
   * @public
   * @returns {string} a brief description of an error.
   */
  get errorDetails() {
    return this.privErrorDetails;
  }
  /**
   * The set of properties exposed in the result.
   * @member SynthesisResult.prototype.properties
   * @function
   * @public
   * @returns {PropertyCollection} The set of properties exposed in the result.
   */
  get properties() {
    return this.privProperties;
  }
}
Sa.SynthesisResult = TR;
var di = {}, il;
function IR() {
  if (il)
    return di;
  il = 1, Object.defineProperty(di, "__esModule", { value: !0 }), di.SpeechSynthesisResult = void 0;
  const t = R();
  let e = class extends t.SynthesisResult {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} resultId - The result id.
     * @param {ResultReason} reason - The reason.
     * @param {ArrayBuffer} audioData - The synthesized audio binary.
     * @param {string} errorDetails - Error details, if provided.
     * @param {PropertyCollection} properties - Additional properties, if provided.
     * @param {number} audioDuration - The audio duration.
     */
    constructor(r, s, o, a, i, c) {
      super(r, s, a, i), this.privAudioData = o, this.privAudioDuration = c;
    }
    /**
     * The synthesized audio data
     * @member SpeechSynthesisResult.prototype.audioData
     * @function
     * @public
     * @returns {ArrayBuffer} The synthesized audio data.
     */
    get audioData() {
      return this.privAudioData;
    }
    /**
     * The time duration of synthesized audio, in ticks (100 nanoseconds).
     * @member SpeechSynthesisResult.prototype.audioDuration
     * @function
     * @public
     * @returns {number} The time duration of synthesized audio.
     */
    get audioDuration() {
      return this.privAudioDuration;
    }
  };
  return di.SpeechSynthesisResult = e, di;
}
var ya = {};
Object.defineProperty(ya, "__esModule", { value: !0 });
ya.SpeechSynthesisEventArgs = void 0;
class wR {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {SpeechSynthesisResult} result - The speech synthesis result.
   */
  constructor(e) {
    this.privResult = e;
  }
  /**
   * Specifies the synthesis result.
   * @member SpeechSynthesisEventArgs.prototype.result
   * @function
   * @public
   * @returns {SpeechSynthesisResult} the synthesis result.
   */
  get result() {
    return this.privResult;
  }
}
ya.SpeechSynthesisEventArgs = wR;
var Ca = {};
Object.defineProperty(Ca, "__esModule", { value: !0 });
Ca.SpeechSynthesisWordBoundaryEventArgs = void 0;
class bR {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {number} audioOffset - The audio offset.
   * @param {number} duration - The audio duration.
   * @param {string} text - The text.
   * @param {number} wordLength - The length of the word.
   * @param {number} textOffset - The text offset.
   * @param {SpeechSynthesisBoundaryType} boundaryType - The boundary type
   */
  constructor(e, n, r, s, o, a) {
    this.privAudioOffset = e, this.privDuration = n, this.privText = r, this.privWordLength = s, this.privTextOffset = o, this.privBoundaryType = a;
  }
  /**
   * Specifies the audio offset.
   * @member SpeechSynthesisWordBoundaryEventArgs.prototype.audioOffset
   * @function
   * @public
   * @returns {number} the audio offset.
   */
  get audioOffset() {
    return this.privAudioOffset;
  }
  /**
   * Specifies the duration, in ticks (100 nanoseconds).
   * @member SpeechSynthesisWordBoundaryEventArgs.prototype.duration
   * @function
   * @public
   * @returns {number} Duration in 100 nanosecond increments.
   */
  get duration() {
    return this.privDuration;
  }
  /**
   * Specifies the text of the word boundary event.
   * @member SpeechSynthesisWordBoundaryEventArgs.prototype.text
   * @function
   * @public
   * @returns {string} the text.
   */
  get text() {
    return this.privText;
  }
  /**
   * Specifies the word length
   * @member SpeechSynthesisWordBoundaryEventArgs.prototype.wordLength
   * @function
   * @public
   * @returns {number} the word length
   */
  get wordLength() {
    return this.privWordLength;
  }
  /**
   * Specifies the text offset.
   * @member SpeechSynthesisWordBoundaryEventArgs.prototype.textOffset
   * @function
   * @public
   * @returns {number} the text offset.
   */
  get textOffset() {
    return this.privTextOffset;
  }
  /**
   * Specifies the boundary type.
   * @member SpeechSynthesisWordBoundaryEventArgs.prototype.boundaryType
   * @function
   * @public
   * @returns {SpeechSynthesisBoundaryType} the boundary type.
   */
  get boundaryType() {
    return this.privBoundaryType;
  }
}
Ca.SpeechSynthesisWordBoundaryEventArgs = bR;
var _a = {};
Object.defineProperty(_a, "__esModule", { value: !0 });
_a.SpeechSynthesisBookmarkEventArgs = void 0;
class AR {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {number} audioOffset - The audio offset.
   * @param {string} text - The bookmark text.
   */
  constructor(e, n) {
    this.privAudioOffset = e, this.privText = n;
  }
  /**
   * Specifies the audio offset.
   * @member SpeechSynthesisBookmarkEventArgs.prototype.audioOffset
   * @function
   * @public
   * @returns {number} the audio offset.
   */
  get audioOffset() {
    return this.privAudioOffset;
  }
  /**
   * Specifies the bookmark.
   * @member SpeechSynthesisBookmarkEventArgs.prototype.text
   * @function
   * @public
   * @returns {string} the bookmark text.
   */
  get text() {
    return this.privText;
  }
}
_a.SpeechSynthesisBookmarkEventArgs = AR;
var Ra = {};
Object.defineProperty(Ra, "__esModule", { value: !0 });
Ra.SpeechSynthesisVisemeEventArgs = void 0;
class MR {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {number} audioOffset - The audio offset.
   * @param {number} visemeId - The viseme ID.
   * @param {string} animation - The animation, could be in svg or other format.
   */
  constructor(e, n, r) {
    this.privAudioOffset = e, this.privVisemeId = n, this.privAnimation = r;
  }
  /**
   * Specifies the audio offset.
   * @member SpeechSynthesisVisemeEventArgs.prototype.audioOffset
   * @function
   * @public
   * @returns {number} the audio offset.
   */
  get audioOffset() {
    return this.privAudioOffset;
  }
  /**
   * Specifies the viseme ID.
   * @member SpeechSynthesisVisemeEventArgs.prototype.visemeId
   * @function
   * @public
   * @returns {number} the viseme ID.
   */
  get visemeId() {
    return this.privVisemeId;
  }
  /**
   * Specifies the animation.
   * @member SpeechSynthesisVisemeEventArgs.prototype.animation
   * @function
   * @public
   * @returns {string} the animation, could be in svg or other format.
   */
  get animation() {
    return this.privAnimation;
  }
}
Ra.SpeechSynthesisVisemeEventArgs = MR;
var Yf = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.SpeechSynthesisBoundaryType = void 0, function(e) {
    e.Word = "WordBoundary", e.Punctuation = "PunctuationBoundary", e.Sentence = "SentenceBoundary";
  }(t.SpeechSynthesisBoundaryType || (t.SpeechSynthesisBoundaryType = {}));
})(Yf);
var li = {}, sl;
function kR() {
  if (sl)
    return li;
  sl = 1, Object.defineProperty(li, "__esModule", { value: !0 }), li.SynthesisVoicesResult = void 0;
  const t = R();
  let e = class extends t.SynthesisResult {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param requestId - result id for request.
     * @param json - json payload from endpoint.
     */
    constructor(r, s, o) {
      if (Array.isArray(s)) {
        super(r, t.ResultReason.VoicesListRetrieved, void 0, new t.PropertyCollection()), this.privVoices = [];
        for (const a of s)
          this.privVoices.push(new t.VoiceInfo(a));
      } else
        super(r, t.ResultReason.Canceled, o || "Error information unavailable", new t.PropertyCollection());
    }
    /**
     * The list of voices
     * @member SynthesisVoicesResult.prototype.voices
     * @function
     * @public
     * @returns {VoiceInfo[]} List of synthesized voices.
     */
    get voices() {
      return this.privVoices;
    }
  };
  return li.SynthesisVoicesResult = e, li;
}
var Zf = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.VoiceInfo = t.SynthesisVoiceType = t.SynthesisVoiceGender = void 0;
  var e;
  (function(o) {
    o[o.Unknown = 0] = "Unknown", o[o.Female = 1] = "Female", o[o.Male = 2] = "Male", o[o.Neutral = 3] = "Neutral";
  })(e = t.SynthesisVoiceGender || (t.SynthesisVoiceGender = {}));
  var n;
  (function(o) {
    o[o.OnlineNeural = 1] = "OnlineNeural", o[o.OnlineStandard = 2] = "OnlineStandard", o[o.OfflineNeural = 3] = "OfflineNeural", o[o.OfflineStandard = 4] = "OfflineStandard";
  })(n = t.SynthesisVoiceType || (t.SynthesisVoiceType = {}));
  const r = {
    [e[e.Neutral]]: e.Neutral,
    [e[e.Male]]: e.Male,
    [e[e.Female]]: e.Female
  };
  class s {
    constructor(a) {
      if (this.privStyleList = [], a) {
        if (this.privName = a.Name, this.privLocale = a.Locale, this.privShortName = a.ShortName, this.privLocaleName = a.LocaleName, this.privDisplayName = a.DisplayName, this.privLocalName = a.LocalName, this.privVoiceType = a.VoiceType.endsWith("Standard") ? n.OnlineStandard : n.OnlineNeural, this.privGender = r[a.Gender] || e.Unknown, a.StyleList && Array.isArray(a.StyleList))
          for (const i of a.StyleList)
            this.privStyleList.push(i);
        this.privSampleRateHertz = a.SampleRateHertz, this.privStatus = a.Status, a.ExtendedPropertyMap && (this.privExtendedPropertyMap = a.ExtendedPropertyMap), this.privWordsPerMinute = a.WordsPerMinute, Array.isArray(a.SecondaryLocaleList) && (this.privSecondaryLocaleList = [...a.SecondaryLocaleList]), Array.isArray(a.RolePlayList) && (this.privRolePlayList = [...a.RolePlayList]);
      }
    }
    get name() {
      return this.privName;
    }
    get locale() {
      return this.privLocale;
    }
    get shortName() {
      return this.privShortName;
    }
    get displayName() {
      return this.privDisplayName;
    }
    get localName() {
      return this.privLocalName;
    }
    get localeName() {
      return this.privLocaleName;
    }
    get gender() {
      return this.privGender;
    }
    get voiceType() {
      return this.privVoiceType;
    }
    get styleList() {
      return this.privStyleList;
    }
    get sampleRateHertz() {
      return this.privSampleRateHertz;
    }
    get status() {
      return this.privStatus;
    }
    get extendedPropertyMap() {
      return this.privExtendedPropertyMap;
    }
    get wordsPerMinute() {
      return this.privWordsPerMinute;
    }
    get secondaryLocaleList() {
      return this.privSecondaryLocaleList;
    }
    get rolePlayList() {
      return this.privRolePlayList;
    }
  }
  t.VoiceInfo = s;
})(Zf);
var Pa = {};
Object.defineProperty(Pa, "__esModule", { value: !0 });
Pa.SpeakerAudioDestination = void 0;
const rn = k(), OR = Re, Fe = Wt, DR = 60 * 30, ol = {
  [Fe.AudioFormatTag.PCM]: "audio/wav",
  [Fe.AudioFormatTag.MuLaw]: "audio/x-wav",
  [Fe.AudioFormatTag.MP3]: "audio/mpeg",
  [Fe.AudioFormatTag.OGG_OPUS]: "audio/ogg",
  [Fe.AudioFormatTag.WEBM_OPUS]: "audio/webm; codecs=opus",
  [Fe.AudioFormatTag.ALaw]: "audio/x-wav",
  [Fe.AudioFormatTag.FLAC]: "audio/flac",
  [Fe.AudioFormatTag.AMR_WB]: "audio/amr-wb",
  [Fe.AudioFormatTag.G722]: "audio/G722"
};
class NR {
  constructor(e) {
    this.privPlaybackStarted = !1, this.privAppendingToBuffer = !1, this.privMediaSourceOpened = !1, this.privBytesReceived = 0, this.privId = e || rn.createNoDashGuid(), this.privIsPaused = !1, this.privIsClosed = !1;
  }
  id() {
    return this.privId;
  }
  write(e, n, r) {
    this.privAudioBuffer !== void 0 ? (this.privAudioBuffer.push(e), this.updateSourceBuffer().then(() => {
      n && n();
    }, (s) => {
      r && r(s);
    })) : this.privAudioOutputStream !== void 0 && (this.privAudioOutputStream.write(e), this.privBytesReceived += e.byteLength);
  }
  close(e, n) {
    if (this.privIsClosed = !0, this.privSourceBuffer !== void 0)
      this.handleSourceBufferUpdateEnd().then(() => {
        e && e();
      }, (r) => {
        n && n(r);
      });
    else if (this.privAudioOutputStream !== void 0 && typeof window < "u")
      if ((this.privFormat.formatTag === Fe.AudioFormatTag.PCM || this.privFormat.formatTag === Fe.AudioFormatTag.MuLaw || this.privFormat.formatTag === Fe.AudioFormatTag.ALaw) && this.privFormat.hasHeader === !1)
        console.warn("Play back is not supported for raw PCM, mulaw or alaw format without header."), this.onAudioEnd && this.onAudioEnd(this);
      else {
        let r = new ArrayBuffer(this.privBytesReceived);
        this.privAudioOutputStream.read(r).then(() => {
          r = this.privFormat.addHeader(r);
          const s = new Blob([r], { type: ol[this.privFormat.formatTag] });
          this.privAudio.src = window.URL.createObjectURL(s), this.notifyPlayback().then(() => {
            e && e();
          }, (o) => {
            n && n(o);
          });
        }, (s) => {
          n && n(s);
        });
      }
    else
      this.onAudioEnd && this.onAudioEnd(this);
  }
  set format(e) {
    if (typeof AudioContext < "u" || typeof window < "u" && typeof window.webkitAudioContext < "u") {
      this.privFormat = e;
      const n = ol[this.privFormat.formatTag];
      n === void 0 ? console.warn(`Unknown mimeType for format ${Fe.AudioFormatTag[this.privFormat.formatTag]}; playback is not supported.`) : typeof MediaSource < "u" && MediaSource.isTypeSupported(n) ? (this.privAudio = new Audio(), this.privAudioBuffer = [], this.privMediaSource = new MediaSource(), this.privAudio.src = URL.createObjectURL(this.privMediaSource), this.privAudio.load(), this.privMediaSource.onsourceopen = () => {
        this.privMediaSourceOpened = !0, this.privMediaSource.duration = DR, this.privSourceBuffer = this.privMediaSource.addSourceBuffer(n), this.privSourceBuffer.onupdate = () => {
          this.updateSourceBuffer().catch((r) => {
            rn.Events.instance.onEvent(new rn.BackgroundEvent(r));
          });
        }, this.privSourceBuffer.onupdateend = () => {
          this.handleSourceBufferUpdateEnd().catch((r) => {
            rn.Events.instance.onEvent(new rn.BackgroundEvent(r));
          });
        }, this.privSourceBuffer.onupdatestart = () => {
          this.privAppendingToBuffer = !1;
        };
      }, this.updateSourceBuffer().catch((r) => {
        rn.Events.instance.onEvent(new rn.BackgroundEvent(r));
      })) : (console.warn(`Format ${Fe.AudioFormatTag[this.privFormat.formatTag]} could not be played by MSE, streaming playback is not enabled.`), this.privAudioOutputStream = new OR.PullAudioOutputStreamImpl(), this.privAudioOutputStream.format = this.privFormat, this.privAudio = new Audio());
    }
  }
  get volume() {
    var e;
    return ((e = this.privAudio) == null ? void 0 : e.volume) ?? -1;
  }
  set volume(e) {
    this.privAudio && (this.privAudio.volume = e);
  }
  mute() {
    this.privAudio && (this.privAudio.muted = !0);
  }
  unmute() {
    this.privAudio && (this.privAudio.muted = !1);
  }
  get isClosed() {
    return this.privIsClosed;
  }
  get currentTime() {
    return this.privAudio !== void 0 ? this.privAudio.currentTime : -1;
  }
  pause() {
    !this.privIsPaused && this.privAudio !== void 0 && (this.privAudio.pause(), this.privIsPaused = !0);
  }
  resume(e, n) {
    this.privIsPaused && this.privAudio !== void 0 && (this.privAudio.play().then(() => {
      e && e();
    }, (r) => {
      n && n(r);
    }), this.privIsPaused = !1);
  }
  get internalAudio() {
    return this.privAudio;
  }
  async updateSourceBuffer() {
    if (this.privAudioBuffer !== void 0 && this.privAudioBuffer.length > 0 && this.sourceBufferAvailable()) {
      this.privAppendingToBuffer = !0;
      const e = this.privAudioBuffer.shift();
      try {
        this.privSourceBuffer.appendBuffer(e);
      } catch {
        this.privAudioBuffer.unshift(e), console.log("buffer filled, pausing addition of binaries until space is made");
        return;
      }
      await this.notifyPlayback();
    } else
      this.canEndStream() && await this.handleSourceBufferUpdateEnd();
  }
  async handleSourceBufferUpdateEnd() {
    this.canEndStream() && this.sourceBufferAvailable() && (this.privMediaSource.endOfStream(), await this.notifyPlayback());
  }
  async notifyPlayback() {
    !this.privPlaybackStarted && this.privAudio !== void 0 && (this.privPlaybackStarted = !0, this.onAudioStart && this.onAudioStart(this), this.privAudio.onended = () => {
      this.onAudioEnd && this.onAudioEnd(this);
    }, this.privIsPaused || await this.privAudio.play());
  }
  canEndStream() {
    return this.isClosed && this.privSourceBuffer !== void 0 && this.privAudioBuffer.length === 0 && this.privMediaSourceOpened && !this.privAppendingToBuffer && this.privMediaSource.readyState === "open";
  }
  sourceBufferAvailable() {
    return this.privSourceBuffer !== void 0 && !this.privSourceBuffer.updating;
  }
}
Pa.SpeakerAudioDestination = NR;
var hi = {}, al;
function LR() {
  if (al)
    return hi;
  al = 1, Object.defineProperty(hi, "__esModule", { value: !0 }), hi.ConversationTranscriptionCanceledEventArgs = void 0;
  const t = Cs();
  let e = class extends t.CancellationEventArgsBase {
  };
  return hi.ConversationTranscriptionCanceledEventArgs = e, hi;
}
var vi = {}, cl;
function zR() {
  if (cl)
    return vi;
  cl = 1, Object.defineProperty(vi, "__esModule", { value: !0 }), vi.MeetingTranscriptionCanceledEventArgs = void 0;
  const t = Cs();
  let e = class extends t.CancellationEventArgsBase {
  };
  return vi.MeetingTranscriptionCanceledEventArgs = e, vi;
}
var Xf = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.PronunciationAssessmentGradingSystem = void 0, function(e) {
    e[e.FivePoint = 1] = "FivePoint", e[e.HundredMark = 2] = "HundredMark";
  }(t.PronunciationAssessmentGradingSystem || (t.PronunciationAssessmentGradingSystem = {}));
})(Xf);
var eg = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.PronunciationAssessmentGranularity = void 0, function(e) {
    e[e.Phoneme = 1] = "Phoneme", e[e.Word = 2] = "Word", e[e.FullText = 3] = "FullText";
  }(t.PronunciationAssessmentGranularity || (t.PronunciationAssessmentGranularity = {}));
})(eg);
var fi = {}, ul;
function jR() {
  if (ul)
    return fi;
  ul = 1, Object.defineProperty(fi, "__esModule", { value: !0 }), fi.PronunciationAssessmentConfig = void 0;
  const t = N, e = R();
  let n = class tg {
    /**
     * PronunciationAssessmentConfig constructor.
     * @constructor
     * @param {string} referenceText
     * @param gradingSystem
     * @param granularity
     * @param enableMiscue
     */
    constructor(s, o = e.PronunciationAssessmentGradingSystem.FivePoint, a = e.PronunciationAssessmentGranularity.Phoneme, i = !1) {
      t.Contracts.throwIfNullOrUndefined(s, "referenceText"), this.privProperties = new e.PropertyCollection(), this.privProperties.setProperty(e.PropertyId.PronunciationAssessment_ReferenceText, s), this.privProperties.setProperty(e.PropertyId.PronunciationAssessment_GradingSystem, e.PronunciationAssessmentGradingSystem[o]), this.privProperties.setProperty(e.PropertyId.PronunciationAssessment_Granularity, e.PronunciationAssessmentGranularity[a]), this.privProperties.setProperty(e.PropertyId.PronunciationAssessment_EnableMiscue, String(i));
    }
    /**
     * @member PronunciationAssessmentConfig.fromJSON
     * @function
     * @public
     * @param {string} json The json string containing the pronunciation assessment parameters.
     * @return {PronunciationAssessmentConfig} Instance of PronunciationAssessmentConfig
     * @summary Creates an instance of the PronunciationAssessmentConfig from json.
     * This method is designed to support the pronunciation assessment parameters still in preview.
     * Under normal circumstances, use the constructor instead.
     */
    static fromJSON(s) {
      t.Contracts.throwIfNullOrUndefined(s, "json");
      const o = new tg("");
      return o.privProperties = new e.PropertyCollection(), o.properties.setProperty(e.PropertyId.PronunciationAssessment_Json, s), o;
    }
    toJSON() {
      return this.updateJson(), this.privProperties.getProperty(e.PropertyId.PronunciationAssessment_Params);
    }
    applyTo(s) {
      this.updateJson();
      const o = s.internalData;
      o.expectContentAssessmentResponse = !!this.privContentAssessmentTopic, o.speechContext.setPronunciationAssessmentParams(this.properties.getProperty(e.PropertyId.PronunciationAssessment_Params), this.privContentAssessmentTopic, o.isSpeakerDiarizationEnabled);
    }
    /**
     * Gets the reference text.
     * @member PronunciationAssessmentConfig.prototype.referenceText
     * @function
     * @public
     * @returns {string} Reference text.
     */
    get referenceText() {
      return this.properties.getProperty(e.PropertyId.PronunciationAssessment_ReferenceText);
    }
    /**
     * Gets/Sets the reference text.
     * @member PronunciationAssessmentConfig.prototype.referenceText
     * @function
     * @public
     * @param {string} referenceText - Reference text.
     */
    set referenceText(s) {
      t.Contracts.throwIfNullOrWhitespace(s, "referenceText"), this.properties.setProperty(e.PropertyId.PronunciationAssessment_ReferenceText, s);
    }
    /**
     * Sets the phoneme alphabet.
     * The valid values are "SAPI" (default) and "IPA".
     * Added in version 1.20.0
     * @member PronunciationAssessmentConfig.prototype.phonemeAlphabet
     * @function
     * @public
     * @param {string} phonemeAlphabet - Phoneme alphabet.
     */
    set phonemeAlphabet(s) {
      t.Contracts.throwIfNullOrWhitespace(s, "phonemeAlphabet"), this.privPhonemeAlphabet = s;
    }
    /**
     * Sets the boolean enableMiscue property.
     * Added in version 1.26.0
     * @member PronunciationAssessmentConfig.prototype.enableMiscue
     * @function
     * @public
     * @param {boolean} enableMiscue - enable miscue.
     */
    set enableMiscue(s) {
      const o = s ? "true" : "false";
      this.properties.setProperty(e.PropertyId.PronunciationAssessment_EnableMiscue, o);
    }
    /**
     * Gets the boolean enableMiscue property.
     * Added in version 1.26.0
     * @member PronunciationAssessmentConfig.prototype.enableMiscue
     * @function
     * @public
     * @return {boolean} enableMiscue - enable miscue.
     */
    get enableMiscue() {
      return this.properties.getProperty(e.PropertyId.PronunciationAssessment_EnableMiscue, "false").toLowerCase() === "true";
    }
    /**
     * Sets the nbest phoneme count
     * Added in version 1.20.0
     * @member PronunciationAssessmentConfig.prototype.nbestPhonemeCount
     * @function
     * @public
     * @param {number} nbestPhonemeCount - NBest phoneme count.
     */
    set nbestPhonemeCount(s) {
      this.privNBestPhonemeCount = s;
    }
    /**
     * Enables the prosody assessment.
     * Added in version 1.34.0
     * @member PronunciationAssessmentConfig.prototype.enableProsodyAssessment
     * @function
     * @public
     * @param {boolean} enableProsodyAssessment - enable prosody assessment.
     */
    set enableProsodyAssessment(s) {
      this.privEnableProsodyAssessment = s;
    }
    /**
     * Enables content assessment and sets the topic.
     * Added in version 1.34.0
     * @member PronunciationAssessmentConfig.prototype.enableContentAssessmentWithTopic
     * @function
     * @public
     * @param {string} topic - Topic for content assessment.
     */
    enableContentAssessmentWithTopic(s) {
      this.privContentAssessmentTopic = s;
    }
    /**
     * @member PronunciationAssessmentConfig.prototype.properties
     * @function
     * @public
     * @return {PropertyCollection} Properties of the config.
     * @summary Gets a pronunciation assessment config properties
     */
    get properties() {
      return this.privProperties;
    }
    updateJson() {
      const s = this.privProperties.getProperty(e.PropertyId.PronunciationAssessment_Json, "{}"), o = JSON.parse(s), a = this.privProperties.getProperty(e.PropertyId.PronunciationAssessment_ReferenceText);
      a && (o.referenceText = a);
      const i = this.privProperties.getProperty(e.PropertyId.PronunciationAssessment_GradingSystem);
      i && (o.gradingSystem = i);
      const c = this.privProperties.getProperty(e.PropertyId.PronunciationAssessment_Granularity);
      c && (o.granularity = c), this.privPhonemeAlphabet && (o.phonemeAlphabet = this.privPhonemeAlphabet), this.privNBestPhonemeCount && (o.nbestPhonemeCount = this.privNBestPhonemeCount), o.enableProsodyAssessment = this.privEnableProsodyAssessment, o.dimension = "Comprehensive", this.privProperties.getProperty(e.PropertyId.PronunciationAssessment_EnableMiscue) && (o.enableMiscue = this.enableMiscue), this.privProperties.setProperty(e.PropertyId.PronunciationAssessment_Params, JSON.stringify(o));
    }
  };
  return fi.PronunciationAssessmentConfig = n, fi;
}
var sn = {}, pl;
function xR() {
  if (pl)
    return sn;
  pl = 1, Object.defineProperty(sn, "__esModule", { value: !0 }), sn.PronunciationAssessmentResult = sn.ContentAssessmentResult = void 0;
  const t = N, e = R();
  class n {
    /**
     * @Internal
     * Do not use externally.
     */
    constructor(o) {
      this.privPronJson = o;
    }
    /**
     * Correctness in using grammar and variety of sentence patterns.
     * Grammatical errors are jointly evaluated by lexical accuracy,
     * grammatical accuracy and diversity of sentence structures.
     * @member ContentAssessmentResult.prototype.grammarScore
     * @function
     * @public
     * @returns {number} Grammar score.
     */
    get grammarScore() {
      return this.privPronJson.ContentAssessment.GrammarScore;
    }
    /**
     * Proficiency in lexical usage. It evaluates the speaker's effective usage
     * of words and their appropriateness within the given context to express
     * ideas accurately, as well as level of lexical complexity.
     * @member ContentAssessmentResult.prototype.vocabularyScore
     * @function
     * @public
     * @returns {number} Vocabulary score.
     */
    get vocabularyScore() {
      return this.privPronJson.ContentAssessment.VocabularyScore;
    }
    /**
     * Level of understanding and engagement with the topic, which provides
     * insights into the speaker’s ability to express their thoughts and ideas
     * effectively and the ability to engage with the topic.
     * @member ContentAssessmentResult.prototype.topicScore
     * @function
     * @public
     * @returns {number} Topic score.
     */
    get topicScore() {
      return this.privPronJson.ContentAssessment.TopicScore;
    }
  }
  sn.ContentAssessmentResult = n;
  let r = class ng {
    constructor(o) {
      const a = JSON.parse(o);
      t.Contracts.throwIfNullOrUndefined(a.NBest[0], "NBest"), this.privPronJson = a.NBest[0];
    }
    /**
     * @member PronunciationAssessmentResult.fromResult
     * @function
     * @public
     * @param {RecognitionResult} result The recognition result.
     * @return {PronunciationAssessmentConfig} Instance of PronunciationAssessmentConfig
     * @summary Creates an instance of the PronunciationAssessmentResult from recognition result.
     */
    static fromResult(o) {
      t.Contracts.throwIfNullOrUndefined(o, "result");
      const a = o.properties.getProperty(e.PropertyId.SpeechServiceResponse_JsonResult);
      return t.Contracts.throwIfNullOrUndefined(a, "json"), new ng(a);
    }
    /**
     * Gets the detail result of pronunciation assessment.
     * @member PronunciationAssessmentConfig.prototype.detailResult
     * @function
     * @public
     * @returns {DetailResult} detail result.
     */
    get detailResult() {
      return this.privPronJson;
    }
    /**
     * The score indicating the pronunciation accuracy of the given speech, which indicates
     * how closely the phonemes match a native speaker's pronunciation.
     * @member PronunciationAssessmentResult.prototype.accuracyScore
     * @function
     * @public
     * @returns {number} Accuracy score.
     */
    get accuracyScore() {
      var o;
      return (o = this.detailResult.PronunciationAssessment) == null ? void 0 : o.AccuracyScore;
    }
    /**
     * The overall score indicating the pronunciation quality of the given speech.
     * This is calculated from AccuracyScore, FluencyScore and CompletenessScore with weight.
     * @member PronunciationAssessmentResult.prototype.pronunciationScore
     * @function
     * @public
     * @returns {number} Pronunciation score.
     */
    get pronunciationScore() {
      var o;
      return (o = this.detailResult.PronunciationAssessment) == null ? void 0 : o.PronScore;
    }
    /**
     * The score indicating the completeness of the given speech by calculating the ratio of pronounced words towards entire input.
     * @member PronunciationAssessmentResult.prototype.completenessScore
     * @function
     * @public
     * @returns {number} Completeness score.
     */
    get completenessScore() {
      var o;
      return (o = this.detailResult.PronunciationAssessment) == null ? void 0 : o.CompletenessScore;
    }
    /**
     * The score indicating the fluency of the given speech.
     * @member PronunciationAssessmentResult.prototype.fluencyScore
     * @function
     * @public
     * @returns {number} Fluency score.
     */
    get fluencyScore() {
      var o;
      return (o = this.detailResult.PronunciationAssessment) == null ? void 0 : o.FluencyScore;
    }
    /**
     * The prosody score, which indicates how nature of the given speech, including stress, intonation, speaking speed and rhythm.
     * @member PronunciationAssessmentResult.prototype.prosodyScore
     * @function
     * @public
     * @returns {number} Prosody score.
     */
    get prosodyScore() {
      var o;
      return (o = this.detailResult.PronunciationAssessment) == null ? void 0 : o.ProsodyScore;
    }
    /**
     * The concent assessment result.
     * Only available when content assessment is enabled.
     * @member PronunciationAssessmentResult.prototype.contentAssessmentResult
     * @function
     * @public
     * @returns {ContentAssessmentResult} Content assessment result.
     */
    get contentAssessmentResult() {
      if (this.detailResult.ContentAssessment !== void 0)
        return new n(this.detailResult);
    }
  };
  return sn.PronunciationAssessmentResult = r, sn;
}
var gi = {}, dl;
function BR() {
  if (dl)
    return gi;
  dl = 1, Object.defineProperty(gi, "__esModule", { value: !0 }), gi.AvatarConfig = void 0;
  const t = N, e = R();
  let n = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} character - The avatar character.
     * @param {string} style - The avatar style.
     * @param {AvatarVideoFormat} videoFormat - The talking avatar output video format.
     */
    constructor(s, o, a) {
      this.privCustomized = !1, t.Contracts.throwIfNullOrWhitespace(s, "character"), this.character = s, this.style = o, a === void 0 && (a = new e.AvatarVideoFormat()), this.videoFormat = a;
    }
    /**
     * Indicates if the talking avatar is customized.
     */
    get customized() {
      return this.privCustomized;
    }
    /**
     * Sets if the talking avatar is customized.
     */
    set customized(s) {
      this.privCustomized = s;
    }
    /**
     * Gets the background color.
     */
    get backgroundColor() {
      return this.privBackgroundColor;
    }
    /**
     * Sets the background color.
     */
    set backgroundColor(s) {
      this.privBackgroundColor = s;
    }
    /**
     * Gets the background image.
     */
    get backgroundImage() {
      return this.privBackgroundImage;
    }
    /**
     * Sets the background image.
     * @param {URL} value - The background image.
     */
    set backgroundImage(s) {
      this.privBackgroundImage = s;
    }
    /**
     * Gets the remote ICE servers.
     * @remarks This method is designed to be used internally in the SDK.
     * @returns {RTCIceServer[]} The remote ICE servers.
     */
    get remoteIceServers() {
      return this.privRemoteIceServers;
    }
    /**
     * Sets the remote ICE servers.
     * @remarks Normally, the ICE servers are gathered from the PeerConnection,
     * set this property to override the ICE servers. E.g., the ICE servers are
     * different in client and server side.
     * @param {RTCIceServer[]} value - The remote ICE servers.
     */
    set remoteIceServers(s) {
      this.privRemoteIceServers = s;
    }
  };
  return gi.AvatarConfig = n, gi;
}
var rg = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.AvatarEventArgs = t.AvatarEventTypes = void 0, function(n) {
    n.SwitchedToSpeaking = "SwitchedToSpeaking", n.SwitchedToIdle = "SwitchedToIdle", n.SessionClosed = "SessionClosed";
  }(t.AvatarEventTypes || (t.AvatarEventTypes = {}));
  class e {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {number} audioOffset - The audio offset.
     * @param {string} description - The description of the event.
     */
    constructor(r, s) {
      this.privOffset = r, this.privDescription = s;
    }
    /**
     * The type of the event.
     * @public
     * @returns {AvatarEventTypes} The type of the event.
     */
    get type() {
      return this.privType;
    }
    /**
     * The time offset associated with this event.
     * @public
     * @returns {number} The time offset associated with this event.
     */
    get offset() {
      return this.privOffset;
    }
    /**
     * The description of the event.
     * @public
     * @returns {string} The description of the event.
     */
    get description() {
      return this.privDescription;
    }
  }
  t.AvatarEventArgs = e;
})(rg);
var mi = {}, Si = {}, ll;
function ig() {
  if (ll)
    return Si;
  ll = 1, Object.defineProperty(Si, "__esModule", { value: !0 }), Si.SpeechSynthesisConnectionFactory = void 0;
  const t = ye(), e = R(), n = ot(), r = A(), s = Se, o = st;
  let a = class {
    constructor() {
      this.synthesisUri = "/cognitiveservices/websocket/v1";
    }
    create(c, u, p) {
      let d = c.parameters.getProperty(e.PropertyId.SpeechServiceConnection_Endpoint, void 0);
      const l = c.parameters.getProperty(e.PropertyId.SpeechServiceConnection_Region, void 0), h = n.ConnectionFactoryBase.getHostSuffix(l), v = c.parameters.getProperty(e.PropertyId.SpeechServiceConnection_EndpointId, void 0), g = v === void 0 ? "tts" : "voice", f = c.parameters.getProperty(e.PropertyId.SpeechServiceConnection_Host, "wss://" + l + "." + g + ".speech" + h), m = {}, S = {};
      u.token !== void 0 && u.token !== "" && (S[u.headerName] = u.token), S[s.HeaderNames.ConnectionId] = p, v !== void 0 && v !== "" && (!d || d.search(o.QueryParameterNames.CustomVoiceDeploymentId) === -1) && (m[o.QueryParameterNames.CustomVoiceDeploymentId] = v), c.avatarEnabled && (!d || d.search(o.QueryParameterNames.EnableAvatar) === -1) && (m[o.QueryParameterNames.EnableAvatar] = "true"), d || (d = f + this.synthesisUri), c.parameters.setProperty(e.PropertyId.SpeechServiceConnection_Url, d);
      const y = c.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
      return new t.WebsocketConnection(d, m, S, new r.WebsocketMessageFormatter(), t.ProxyInfo.fromParameters(c.parameters), y, p);
    }
  };
  return Si.SpeechSynthesisConnectionFactory = a, Si;
}
var hl;
function qR() {
  if (hl)
    return mi;
  hl = 1, Object.defineProperty(mi, "__esModule", { value: !0 }), mi.AvatarSynthesizer = void 0;
  const t = ig(), e = A(), n = k(), r = Vt, s = R(), o = N, a = qu();
  let i = class extends s.Synthesizer {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {SpeechConfig} speechConfig - The speech config.
     * @param {AvatarConfig} avatarConfig - The talking avatar config.
     */
    constructor(u, p) {
      super(u), o.Contracts.throwIfNullOrUndefined(p, "avatarConfig"), this.privConnectionFactory = new t.SpeechSynthesisConnectionFactory(), this.privAvatarConfig = p, this.implCommonSynthesizeSetup();
    }
    implCommonSynthesizeSetup() {
      super.implCommonSynthesizeSetup(), this.privAdapter.audioOutputFormat = r.AudioOutputFormatImpl.fromSpeechSynthesisOutputFormat(s.SpeechSynthesisOutputFormat.Riff24Khz16BitMonoPcm);
    }
    /**
     * Starts the talking avatar session and establishes the WebRTC connection.
     * @member AvatarSynthesizer.prototype.startAvatarAsync
     * @function
     * @public
     * @param {AvatarWebRTCConnectionInfo} peerConnection - The peer connection.
     * @returns {Promise<SynthesisResult>} The promise of the connection result.
     */
    async startAvatarAsync(u) {
      o.Contracts.throwIfNullOrUndefined(u, "peerConnection"), this.privIceServers = u.getConfiguration().iceServers, o.Contracts.throwIfNullOrUndefined(this.privIceServers, "Ice servers must be set.");
      const p = new n.Deferred();
      u.onicegatheringstatechange = () => {
        n.Events.instance.onEvent(new n.PlatformEvent("peer connection: ice gathering state: " + u.iceGatheringState, n.EventType.Debug)), u.iceGatheringState === "complete" && (n.Events.instance.onEvent(new n.PlatformEvent("peer connection: ice gathering complete.", n.EventType.Info)), p.resolve());
      }, u.onicecandidate = (g) => {
        g.candidate ? n.Events.instance.onEvent(new n.PlatformEvent("peer connection: ice candidate: " + g.candidate.candidate, n.EventType.Debug)) : (n.Events.instance.onEvent(new n.PlatformEvent("peer connection: ice candidate: complete", n.EventType.Debug)), p.resolve());
      }, setTimeout(() => {
        u.iceGatheringState !== "complete" && (n.Events.instance.onEvent(new n.PlatformEvent("peer connection: ice gathering timeout.", n.EventType.Warning)), p.resolve());
      }, 2e3);
      const d = await u.createOffer();
      await u.setLocalDescription(d), await p.promise, n.Events.instance.onEvent(new n.PlatformEvent("peer connection: got local SDP.", n.EventType.Info)), this.privProperties.setProperty(s.PropertyId.TalkingAvatarService_WebRTC_SDP, JSON.stringify(u.localDescription));
      const l = await this.speak("", !1);
      if (l.reason !== s.ResultReason.SynthesizingAudioCompleted)
        return new s.SynthesisResult(l.resultId, l.reason, l.errorDetails, l.properties);
      const h = atob(l.properties.getProperty(s.PropertyId.TalkingAvatarService_WebRTC_SDP)), v = new RTCSessionDescription(JSON.parse(h));
      return await u.setRemoteDescription(v), new s.SynthesisResult(l.resultId, l.reason, void 0, l.properties);
    }
    /**
     * Speaks plain text asynchronously. The rendered audio and video will be sent via the WebRTC connection.
     * @member AvatarSynthesizer.prototype.speakTextAsync
     * @function
     * @public
     * @param {string} text - The plain text to speak.
     * @returns {Promise<SynthesisResult>} The promise of the synthesis result.
     */
    async speakTextAsync(u) {
      const p = await this.speak(u, !1);
      return new s.SynthesisResult(p.resultId, p.reason, p.errorDetails, p.properties);
    }
    /**
     * Speaks SSML asynchronously. The rendered audio and video will be sent via the WebRTC connection.
     * @member AvatarSynthesizer.prototype.speakSsmlAsync
     * @function
     * @public
     * @param {string} ssml - The SSML text to speak.
     * @returns {Promise<SynthesisResult>} The promise of the synthesis result.
     */
    async speakSsmlAsync(u) {
      const p = await this.speak(u, !0);
      return new s.SynthesisResult(p.resultId, p.reason, p.errorDetails, p.properties);
    }
    /**
     * Speaks text asynchronously. The avatar will switch to idle state.
     * @member AvatarSynthesizer.prototype.stopSpeakingAsync
     * @function
     * @public
     * @returns {Promise<void>} The promise of the void result.
     */
    async stopSpeakingAsync() {
      for (; this.synthesisRequestQueue.length() > 0; )
        (await this.synthesisRequestQueue.dequeue()).err("Synthesis is canceled by user.");
      return this.privAdapter.stopSpeaking();
    }
    /**
     * Stops the talking avatar session and closes the WebRTC connection.
     * For now, this is the same as close().
     * You need to create a new AvatarSynthesizer instance to start a new session.
     * @member AvatarSynthesizer.prototype.stopAvatarAsync
     * @function
     * @public
     * @returns {Promise<void>} The promise of the void result.
     */
    async stopAvatarAsync() {
      return o.Contracts.throwIfDisposed(this.privDisposed), this.dispose(!0);
    }
    /**
     * Dispose of associated resources.
     * @member AvatarSynthesizer.prototype.close
     * @function
     * @public
     */
    async close() {
      if (!this.privDisposed)
        return this.dispose(!0);
    }
    /**
     * Gets the ICE servers. Internal use only.
     */
    get iceServers() {
      return this.privIceServers;
    }
    // Creates the synthesis adapter
    createSynthesisAdapter(u, p, d) {
      return new e.AvatarSynthesisAdapter(u, p, d, this, this.privAvatarConfig);
    }
    createRestSynthesisAdapter(u, p) {
    }
    createSynthesizerConfig(u) {
      const p = super.createSynthesizerConfig(u);
      return p.avatarEnabled = !0, p;
    }
    async speak(u, p) {
      const d = n.createNoDashGuid(), l = new n.Deferred();
      return this.synthesisRequestQueue.enqueue(new a.SynthesisRequest(d, u, p, (h) => {
        l.resolve(h), this.privSynthesizing = !1, this.adapterSpeak();
      }, (h) => {
        l.reject(h), this.privSynthesizing = !1;
      })), this.adapterSpeak(), l.promise;
    }
  };
  return mi.AvatarSynthesizer = i, mi;
}
var Hn = {};
Object.defineProperty(Hn, "__esModule", { value: !0 });
Hn.AvatarVideoFormat = Hn.Coordinate = void 0;
class FR {
  constructor(e, n) {
    this.x = e, this.y = n;
  }
}
Hn.Coordinate = FR;
class $R {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param {string} codec - The video codec.
   * @param {number} bitrate - The video bitrate.
   * @param {number} width - The video width.
   * @param {number} height - The video height.
   */
  constructor(e = "H264", n = 2e6, r = 1920, s = 1080) {
    this.codec = e, this.bitrate = n, this.width = r, this.height = s;
  }
  /**
   * Sets the video crop range.
   */
  setCropRange(e, n) {
    this.cropRange = {
      bottomRight: n,
      topLeft: e
    };
  }
}
Hn.AvatarVideoFormat = $R;
var yi = {}, vl;
function UR() {
  if (vl)
    return yi;
  vl = 1, Object.defineProperty(yi, "__esModule", { value: !0 }), yi.AvatarWebRTCConnectionResult = void 0;
  const t = R();
  let e = class extends t.SynthesisResult {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {RTCSessionDescriptionInit} SDPAnswer - The SDP answer of WebRTC connection.
     * @param {string} resultId - The result id.
     * @param {ResultReason} reason - The reason.
     * @param {string} errorDetails - Error details, if provided.
     * @param {PropertyCollection} properties - Additional properties, if provided.
     */
    constructor(r, s, o, a, i) {
      super(s, o, a, i), this.privSDPAnswer = r;
    }
    /**
     * Specifies SDP (Session Description Protocol) answer of WebRTC connection.
     * @member AvatarWebRTCConnectionResult.prototype.SDPAnswer
     * @function
     * @public
     * @returns {RTCSessionDescriptionInit} Specifies the SDP answer of WebRTC connection.
     */
    get SDPAnswer() {
      return this.privSDPAnswer;
    }
  };
  return yi.AvatarWebRTCConnectionResult = e, yi;
}
var Ci = {}, fl;
function HR() {
  if (fl)
    return Ci;
  fl = 1, Object.defineProperty(Ci, "__esModule", { value: !0 }), Ci.Diagnostics = void 0;
  const t = ye(), e = k();
  let n = class {
    static SetLoggingLevel(s) {
      this.privListener = new t.ConsoleLoggingListener(s), e.Events.instance.attachConsoleListener(this.privListener);
    }
    static StartConsoleOutput() {
      this.privListener && (this.privListener.enableConsoleOutput = !0);
    }
    static StopConsoleOutput() {
      this.privListener && (this.privListener.enableConsoleOutput = !1);
    }
    static SetLogOutputPath(s) {
      if (typeof window > "u")
        this.privListener && (this.privListener.logPath = s);
      else
        throw new Error("File system logging not available in browser.");
    }
    static set onLogOutput(s) {
      this.privListener && (this.privListener.logCallback = s);
    }
  };
  return Ci.Diagnostics = n, n.privListener = void 0, Ci;
}
var gl;
function R() {
  return gl || (gl = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 });
    var e = Pf();
    Object.defineProperty(t, "AudioConfig", { enumerable: !0, get: function() {
      return e.AudioConfig;
    } });
    var n = Wt;
    Object.defineProperty(t, "AudioStreamFormat", { enumerable: !0, get: function() {
      return n.AudioStreamFormat;
    } }), Object.defineProperty(t, "AudioFormatTag", { enumerable: !0, get: function() {
      return n.AudioFormatTag;
    } });
    var r = Sf();
    Object.defineProperty(t, "AudioInputStream", { enumerable: !0, get: function() {
      return r.AudioInputStream;
    } }), Object.defineProperty(t, "PullAudioInputStream", { enumerable: !0, get: function() {
      return r.PullAudioInputStream;
    } }), Object.defineProperty(t, "PushAudioInputStream", { enumerable: !0, get: function() {
      return r.PushAudioInputStream;
    } });
    var s = Re;
    Object.defineProperty(t, "AudioOutputStream", { enumerable: !0, get: function() {
      return s.AudioOutputStream;
    } }), Object.defineProperty(t, "PullAudioOutputStream", { enumerable: !0, get: function() {
      return s.PullAudioOutputStream;
    } }), Object.defineProperty(t, "PushAudioOutputStream", { enumerable: !0, get: function() {
      return s.PushAudioOutputStream;
    } });
    var o = Ef;
    Object.defineProperty(t, "CancellationReason", { enumerable: !0, get: function() {
      return o.CancellationReason;
    } });
    var a = ta;
    Object.defineProperty(t, "PullAudioInputStreamCallback", { enumerable: !0, get: function() {
      return a.PullAudioInputStreamCallback;
    } });
    var i = na;
    Object.defineProperty(t, "PushAudioOutputStreamCallback", { enumerable: !0, get: function() {
      return i.PushAudioOutputStreamCallback;
    } });
    var c = ra;
    Object.defineProperty(t, "KeywordRecognitionModel", { enumerable: !0, get: function() {
      return c.KeywordRecognitionModel;
    } });
    var u = ia;
    Object.defineProperty(t, "SessionEventArgs", { enumerable: !0, get: function() {
      return u.SessionEventArgs;
    } });
    var p = y0();
    Object.defineProperty(t, "RecognitionEventArgs", { enumerable: !0, get: function() {
      return p.RecognitionEventArgs;
    } });
    var d = Tf;
    Object.defineProperty(t, "OutputFormat", { enumerable: !0, get: function() {
      return d.OutputFormat;
    } });
    var l = C0();
    Object.defineProperty(t, "IntentRecognitionEventArgs", { enumerable: !0, get: function() {
      return l.IntentRecognitionEventArgs;
    } });
    var h = sa;
    Object.defineProperty(t, "RecognitionResult", { enumerable: !0, get: function() {
      return h.RecognitionResult;
    } });
    var v = R0();
    Object.defineProperty(t, "SpeechRecognitionResult", { enumerable: !0, get: function() {
      return v.SpeechRecognitionResult;
    } });
    var g = P0();
    Object.defineProperty(t, "IntentRecognitionResult", { enumerable: !0, get: function() {
      return g.IntentRecognitionResult;
    } });
    var f = Un;
    Object.defineProperty(t, "LanguageUnderstandingModel", { enumerable: !0, get: function() {
      return f.LanguageUnderstandingModel;
    } });
    var m = E0();
    Object.defineProperty(t, "SpeechRecognitionEventArgs", { enumerable: !0, get: function() {
      return m.SpeechRecognitionEventArgs;
    } }), Object.defineProperty(t, "ConversationTranscriptionEventArgs", { enumerable: !0, get: function() {
      return m.ConversationTranscriptionEventArgs;
    } }), Object.defineProperty(t, "MeetingTranscriptionEventArgs", { enumerable: !0, get: function() {
      return m.MeetingTranscriptionEventArgs;
    } });
    var S = T0();
    Object.defineProperty(t, "SpeechRecognitionCanceledEventArgs", { enumerable: !0, get: function() {
      return S.SpeechRecognitionCanceledEventArgs;
    } });
    var y = I0();
    Object.defineProperty(t, "TranslationRecognitionEventArgs", { enumerable: !0, get: function() {
      return y.TranslationRecognitionEventArgs;
    } });
    var P = w0();
    Object.defineProperty(t, "TranslationSynthesisEventArgs", { enumerable: !0, get: function() {
      return P.TranslationSynthesisEventArgs;
    } });
    var C = bf();
    Object.defineProperty(t, "TranslationRecognitionResult", { enumerable: !0, get: function() {
      return C.TranslationRecognitionResult;
    } });
    var _ = oa;
    Object.defineProperty(t, "TranslationSynthesisResult", { enumerable: !0, get: function() {
      return _.TranslationSynthesisResult;
    } });
    var w = Af;
    Object.defineProperty(t, "ResultReason", { enumerable: !0, get: function() {
      return w.ResultReason;
    } });
    var T = A0();
    Object.defineProperty(t, "SpeechConfig", { enumerable: !0, get: function() {
      return T.SpeechConfig;
    } }), Object.defineProperty(t, "SpeechConfigImpl", { enumerable: !0, get: function() {
      return T.SpeechConfigImpl;
    } });
    var O = M0();
    Object.defineProperty(t, "SpeechTranslationConfig", { enumerable: !0, get: function() {
      return O.SpeechTranslationConfig;
    } }), Object.defineProperty(t, "SpeechTranslationConfigImpl", { enumerable: !0, get: function() {
      return O.SpeechTranslationConfigImpl;
    } });
    var G = kf();
    Object.defineProperty(t, "PropertyCollection", { enumerable: !0, get: function() {
      return G.PropertyCollection;
    } });
    var X = aa;
    Object.defineProperty(t, "PropertyId", { enumerable: !0, get: function() {
      return X.PropertyId;
    } });
    var q = k0();
    Object.defineProperty(t, "Recognizer", { enumerable: !0, get: function() {
      return q.Recognizer;
    } });
    var b = O0();
    Object.defineProperty(t, "SpeechRecognizer", { enumerable: !0, get: function() {
      return b.SpeechRecognizer;
    } });
    var x = D0();
    Object.defineProperty(t, "IntentRecognizer", { enumerable: !0, get: function() {
      return x.IntentRecognizer;
    } });
    var ee = Df;
    Object.defineProperty(t, "VoiceProfileType", { enumerable: !0, get: function() {
      return ee.VoiceProfileType;
    } });
    var Z = N0();
    Object.defineProperty(t, "TranslationRecognizer", { enumerable: !0, get: function() {
      return Z.TranslationRecognizer;
    } });
    var L = L0();
    Object.defineProperty(t, "Translations", { enumerable: !0, get: function() {
      return L.Translations;
    } });
    var re = jf;
    Object.defineProperty(t, "NoMatchReason", { enumerable: !0, get: function() {
      return re.NoMatchReason;
    } });
    var ce = z0();
    Object.defineProperty(t, "NoMatchDetails", { enumerable: !0, get: function() {
      return ce.NoMatchDetails;
    } });
    var et = ca;
    Object.defineProperty(t, "TranslationRecognitionCanceledEventArgs", { enumerable: !0, get: function() {
      return et.TranslationRecognitionCanceledEventArgs;
    } });
    var We = x0();
    Object.defineProperty(t, "IntentRecognitionCanceledEventArgs", { enumerable: !0, get: function() {
      return We.IntentRecognitionCanceledEventArgs;
    } });
    var Ya = _s;
    Object.defineProperty(t, "CancellationDetailsBase", { enumerable: !0, get: function() {
      return Ya.CancellationDetailsBase;
    } });
    var ks = q0();
    Object.defineProperty(t, "CancellationDetails", { enumerable: !0, get: function() {
      return ks.CancellationDetails;
    } });
    var Os = qf;
    Object.defineProperty(t, "CancellationErrorCode", { enumerable: !0, get: function() {
      return Os.CancellationErrorCode;
    } });
    var Ds = F0();
    Object.defineProperty(t, "ConnectionEventArgs", { enumerable: !0, get: function() {
      return Ds.ConnectionEventArgs;
    } });
    var Dn = $0();
    Object.defineProperty(t, "ServiceEventArgs", { enumerable: !0, get: function() {
      return Dn.ServiceEventArgs;
    } });
    var Za = Lf();
    Object.defineProperty(t, "Connection", { enumerable: !0, get: function() {
      return Za.Connection;
    } });
    var Xa = ua;
    Object.defineProperty(t, "PhraseListGrammar", { enumerable: !0, get: function() {
      return Xa.PhraseListGrammar;
    } });
    var ec = Lu();
    Object.defineProperty(t, "DialogServiceConfig", { enumerable: !0, get: function() {
      return ec.DialogServiceConfig;
    } });
    var tc = U0();
    Object.defineProperty(t, "BotFrameworkConfig", { enumerable: !0, get: function() {
      return tc.BotFrameworkConfig;
    } });
    var Ns = H0();
    Object.defineProperty(t, "CustomCommandsConfig", { enumerable: !0, get: function() {
      return Ns.CustomCommandsConfig;
    } });
    var Ls = V0();
    Object.defineProperty(t, "DialogServiceConnector", { enumerable: !0, get: function() {
      return Ls.DialogServiceConnector;
    } });
    var zs = pa;
    Object.defineProperty(t, "ActivityReceivedEventArgs", { enumerable: !0, get: function() {
      return zs.ActivityReceivedEventArgs;
    } });
    var js = da;
    Object.defineProperty(t, "TurnStatusReceivedEventArgs", { enumerable: !0, get: function() {
      return js.TurnStatusReceivedEventArgs;
    } });
    var xs = Ff;
    Object.defineProperty(t, "ServicePropertyChannel", { enumerable: !0, get: function() {
      return xs.ServicePropertyChannel;
    } });
    var Bs = $f;
    Object.defineProperty(t, "ProfanityOption", { enumerable: !0, get: function() {
      return Bs.ProfanityOption;
    } });
    var J = Q0();
    Object.defineProperty(t, "BaseAudioPlayer", { enumerable: !0, get: function() {
      return J.BaseAudioPlayer;
    } });
    var De = ha;
    Object.defineProperty(t, "ConnectionMessageEventArgs", { enumerable: !0, get: function() {
      return De.ConnectionMessageEventArgs;
    } });
    var ht = Nf();
    Object.defineProperty(t, "ConnectionMessage", { enumerable: !0, get: function() {
      return ht.ConnectionMessage;
    } });
    var Ce = va;
    Object.defineProperty(t, "VoiceProfile", { enumerable: !0, get: function() {
      return Ce.VoiceProfile;
    } });
    var vt = X0();
    Object.defineProperty(t, "VoiceProfileEnrollmentResult", { enumerable: !0, get: function() {
      return vt.VoiceProfileEnrollmentResult;
    } }), Object.defineProperty(t, "VoiceProfileEnrollmentCancellationDetails", { enumerable: !0, get: function() {
      return vt.VoiceProfileEnrollmentCancellationDetails;
    } });
    var bt = eR();
    Object.defineProperty(t, "VoiceProfileResult", { enumerable: !0, get: function() {
      return bt.VoiceProfileResult;
    } }), Object.defineProperty(t, "VoiceProfileCancellationDetails", { enumerable: !0, get: function() {
      return bt.VoiceProfileCancellationDetails;
    } });
    var lr = tR();
    Object.defineProperty(t, "VoiceProfilePhraseResult", { enumerable: !0, get: function() {
      return lr.VoiceProfilePhraseResult;
    } });
    var nc = nR();
    Object.defineProperty(t, "VoiceProfileClient", { enumerable: !0, get: function() {
      return nc.VoiceProfileClient;
    } });
    var qs = rR();
    Object.defineProperty(t, "SpeakerRecognizer", { enumerable: !0, get: function() {
      return qs.SpeakerRecognizer;
    } });
    var Mm = iR();
    Object.defineProperty(t, "SpeakerIdentificationModel", { enumerable: !0, get: function() {
      return Mm.SpeakerIdentificationModel;
    } });
    var km = sR();
    Object.defineProperty(t, "SpeakerVerificationModel", { enumerable: !0, get: function() {
      return km.SpeakerVerificationModel;
    } });
    var Om = oR();
    Object.defineProperty(t, "AutoDetectSourceLanguageConfig", { enumerable: !0, get: function() {
      return Om.AutoDetectSourceLanguageConfig;
    } });
    var Dm = fa;
    Object.defineProperty(t, "AutoDetectSourceLanguageResult", { enumerable: !0, get: function() {
      return Dm.AutoDetectSourceLanguageResult;
    } });
    var Nm = ga;
    Object.defineProperty(t, "SourceLanguageConfig", { enumerable: !0, get: function() {
      return Nm.SourceLanguageConfig;
    } });
    var rc = cR();
    Object.defineProperty(t, "SpeakerRecognitionResult", { enumerable: !0, get: function() {
      return rc.SpeakerRecognitionResult;
    } }), Object.defineProperty(t, "SpeakerRecognitionResultType", { enumerable: !0, get: function() {
      return rc.SpeakerRecognitionResultType;
    } }), Object.defineProperty(t, "SpeakerRecognitionCancellationDetails", { enumerable: !0, get: function() {
      return rc.SpeakerRecognitionCancellationDetails;
    } });
    var Be = Bu();
    Object.defineProperty(t, "Conversation", { enumerable: !0, get: function() {
      return Be.Conversation;
    } }), Object.defineProperty(t, "ConversationExpirationEventArgs", { enumerable: !0, get: function() {
      return Be.ConversationExpirationEventArgs;
    } }), Object.defineProperty(t, "ConversationParticipantsChangedEventArgs", { enumerable: !0, get: function() {
      return Be.ConversationParticipantsChangedEventArgs;
    } }), Object.defineProperty(t, "ConversationTranslationCanceledEventArgs", { enumerable: !0, get: function() {
      return Be.ConversationTranslationCanceledEventArgs;
    } }), Object.defineProperty(t, "ConversationTranslationEventArgs", { enumerable: !0, get: function() {
      return Be.ConversationTranslationEventArgs;
    } }), Object.defineProperty(t, "ConversationTranslationResult", { enumerable: !0, get: function() {
      return Be.ConversationTranslationResult;
    } }), Object.defineProperty(t, "ConversationTranslator", { enumerable: !0, get: function() {
      return Be.ConversationTranslator;
    } }), Object.defineProperty(t, "ConversationTranscriber", { enumerable: !0, get: function() {
      return Be.ConversationTranscriber;
    } }), Object.defineProperty(t, "ConversationTranscriptionResult", { enumerable: !0, get: function() {
      return Be.ConversationTranscriptionResult;
    } }), Object.defineProperty(t, "Meeting", { enumerable: !0, get: function() {
      return Be.Meeting;
    } }), Object.defineProperty(t, "MeetingTranscriber", { enumerable: !0, get: function() {
      return Be.MeetingTranscriber;
    } }), Object.defineProperty(t, "Participant", { enumerable: !0, get: function() {
      return Be.Participant;
    } }), Object.defineProperty(t, "ParticipantChangedReason", { enumerable: !0, get: function() {
      return Be.ParticipantChangedReason;
    } }), Object.defineProperty(t, "User", { enumerable: !0, get: function() {
      return Be.User;
    } });
    var Lm = qu();
    Object.defineProperty(t, "Synthesizer", { enumerable: !0, get: function() {
      return Lm.Synthesizer;
    } });
    var zm = ku;
    Object.defineProperty(t, "SpeechSynthesisOutputFormat", { enumerable: !0, get: function() {
      return zm.SpeechSynthesisOutputFormat;
    } });
    var jm = ER();
    Object.defineProperty(t, "SpeechSynthesizer", { enumerable: !0, get: function() {
      return jm.SpeechSynthesizer;
    } });
    var xm = Sa;
    Object.defineProperty(t, "SynthesisResult", { enumerable: !0, get: function() {
      return xm.SynthesisResult;
    } });
    var Bm = IR();
    Object.defineProperty(t, "SpeechSynthesisResult", { enumerable: !0, get: function() {
      return Bm.SpeechSynthesisResult;
    } });
    var qm = ya;
    Object.defineProperty(t, "SpeechSynthesisEventArgs", { enumerable: !0, get: function() {
      return qm.SpeechSynthesisEventArgs;
    } });
    var Fm = Ca;
    Object.defineProperty(t, "SpeechSynthesisWordBoundaryEventArgs", { enumerable: !0, get: function() {
      return Fm.SpeechSynthesisWordBoundaryEventArgs;
    } });
    var $m = _a;
    Object.defineProperty(t, "SpeechSynthesisBookmarkEventArgs", { enumerable: !0, get: function() {
      return $m.SpeechSynthesisBookmarkEventArgs;
    } });
    var Um = Ra;
    Object.defineProperty(t, "SpeechSynthesisVisemeEventArgs", { enumerable: !0, get: function() {
      return Um.SpeechSynthesisVisemeEventArgs;
    } });
    var Hm = Yf;
    Object.defineProperty(t, "SpeechSynthesisBoundaryType", { enumerable: !0, get: function() {
      return Hm.SpeechSynthesisBoundaryType;
    } });
    var Wm = kR();
    Object.defineProperty(t, "SynthesisVoicesResult", { enumerable: !0, get: function() {
      return Wm.SynthesisVoicesResult;
    } });
    var Vm = Zf;
    Object.defineProperty(t, "VoiceInfo", { enumerable: !0, get: function() {
      return Vm.VoiceInfo;
    } });
    var Km = Pa;
    Object.defineProperty(t, "SpeakerAudioDestination", { enumerable: !0, get: function() {
      return Km.SpeakerAudioDestination;
    } });
    var Jm = LR();
    Object.defineProperty(t, "ConversationTranscriptionCanceledEventArgs", { enumerable: !0, get: function() {
      return Jm.ConversationTranscriptionCanceledEventArgs;
    } });
    var Gm = zR();
    Object.defineProperty(t, "MeetingTranscriptionCanceledEventArgs", { enumerable: !0, get: function() {
      return Gm.MeetingTranscriptionCanceledEventArgs;
    } });
    var Qm = Xf;
    Object.defineProperty(t, "PronunciationAssessmentGradingSystem", { enumerable: !0, get: function() {
      return Qm.PronunciationAssessmentGradingSystem;
    } });
    var Ym = eg;
    Object.defineProperty(t, "PronunciationAssessmentGranularity", { enumerable: !0, get: function() {
      return Ym.PronunciationAssessmentGranularity;
    } });
    var Zm = jR();
    Object.defineProperty(t, "PronunciationAssessmentConfig", { enumerable: !0, get: function() {
      return Zm.PronunciationAssessmentConfig;
    } });
    var Xm = xR();
    Object.defineProperty(t, "PronunciationAssessmentResult", { enumerable: !0, get: function() {
      return Xm.PronunciationAssessmentResult;
    } });
    var eS = ju;
    Object.defineProperty(t, "LanguageIdMode", { enumerable: !0, get: function() {
      return eS.LanguageIdMode;
    } });
    var tS = BR();
    Object.defineProperty(t, "AvatarConfig", { enumerable: !0, get: function() {
      return tS.AvatarConfig;
    } });
    var nS = rg;
    Object.defineProperty(t, "AvatarEventArgs", { enumerable: !0, get: function() {
      return nS.AvatarEventArgs;
    } });
    var rS = qR();
    Object.defineProperty(t, "AvatarSynthesizer", { enumerable: !0, get: function() {
      return rS.AvatarSynthesizer;
    } });
    var Sp = Hn;
    Object.defineProperty(t, "AvatarVideoFormat", { enumerable: !0, get: function() {
      return Sp.AvatarVideoFormat;
    } }), Object.defineProperty(t, "Coordinate", { enumerable: !0, get: function() {
      return Sp.Coordinate;
    } });
    var iS = UR();
    Object.defineProperty(t, "AvatarWebRTCConnectionResult", { enumerable: !0, get: function() {
      return iS.AvatarWebRTCConnectionResult;
    } });
    var sS = HR();
    Object.defineProperty(t, "Diagnostics", { enumerable: !0, get: function() {
      return sS.Diagnostics;
    } });
    var oS = Au;
    Object.defineProperty(t, "LogLevel", { enumerable: !0, get: function() {
      return oS.LogLevel;
    } });
  }(mc)), mc;
}
var ml;
function WR() {
  if (ml)
    return yr;
  ml = 1, Object.defineProperty(yr, "__esModule", { value: !0 }), yr.ProxyInfo = void 0;
  const t = R();
  let e = class sg {
    constructor(r, s, o, a) {
      this.privProxyHostName = r, this.privProxyPort = s, this.privProxyUserName = o, this.privProxyPassword = a;
    }
    static fromParameters(r) {
      return new sg(r.getProperty(t.PropertyId.SpeechServiceConnection_ProxyHostName), parseInt(r.getProperty(t.PropertyId.SpeechServiceConnection_ProxyPort), 10), r.getProperty(t.PropertyId.SpeechServiceConnection_ProxyUserName), r.getProperty(t.PropertyId.SpeechServiceConnection_ProxyPassword));
    }
    static fromRecognizerConfig(r) {
      return this.fromParameters(r.parameters);
    }
    get HostName() {
      return this.privProxyHostName;
    }
    get Port() {
      return this.privProxyPort;
    }
    get UserName() {
      return this.privProxyUserName;
    }
    get Password() {
      return this.privProxyPassword;
    }
  };
  return yr.ProxyInfo = e, yr;
}
var og = {};
const VR = /* @__PURE__ */ new Set(["json", "buffer", "string"]);
var KR = (t) => (...e) => {
  const n = /* @__PURE__ */ new Set();
  let r, s, o, a = "";
  return e.forEach((i) => {
    if (typeof i == "string")
      if (i.toUpperCase() === i)
        if (r) {
          const c = `Can't set method to ${i}, already set to ${r}.`;
          throw new Error(c);
        } else
          r = i;
      else if (i.startsWith("http:") || i.startsWith("https:"))
        a = i;
      else if (VR.has(i))
        s = i;
      else
        throw new Error(`Unknown encoding, ${i}`);
    else if (typeof i == "number")
      n.add(i);
    else if (typeof i == "object")
      if (Array.isArray(i) || i instanceof Set)
        i.forEach((c) => n.add(c));
      else {
        if (o)
          throw new Error("Cannot set headers twice.");
        o = i;
      }
    else
      throw new Error(`Unknown type: ${typeof i}`);
  }), r || (r = "GET"), n.size === 0 && n.add(200), t(n, r, s, o, a);
};
const JR = KR;
class Fu extends Error {
  constructor(e, ...n) {
    super(...n), Error.captureStackTrace && Error.captureStackTrace(this, Fu), this.name = "StatusError", this.message = e.statusMessage, this.statusCode = e.status, this.res = e, this.json = e.json.bind(e), this.text = e.text.bind(e), this.arrayBuffer = e.arrayBuffer.bind(e);
    let r;
    Object.defineProperty(this, "responseBody", { get: () => (r || (r = this.arrayBuffer()), r) }), this.headers = {};
    for (const [o, a] of e.headers.entries())
      this.headers[o.toLowerCase()] = a;
  }
}
const GR = (t, e, n, r, s) => async (o, a, i = {}) => {
  o = s + (o || "");
  let c = new URL(o);
  if (r || (r = {}), c.username && (r.Authorization = "Basic " + btoa(c.username + ":" + c.password), c = new URL(c.protocol + "//" + c.host + c.pathname + c.search)), c.protocol !== "https:" && c.protocol !== "http:")
    throw new Error(`Unknown protocol, ${c.protocol}`);
  if (a && !(a instanceof ArrayBuffer || ArrayBuffer.isView(a) || typeof a == "string"))
    if (typeof a == "object")
      a = JSON.stringify(a), r["Content-Type"] = "application/json";
    else
      throw new Error("Unknown body type.");
  i = new Headers({ ...r || {}, ...i });
  const u = await fetch(c, { method: e, headers: i, body: a });
  if (u.statusCode = u.status, !t.has(u.status))
    throw new Fu(u);
  return n === "json" ? u.json() : n === "buffer" ? u.arrayBuffer() : n === "string" ? u.text() : u;
};
var QR = JR(GR);
(function(t) {
  var e = W && W.__importDefault || function(a) {
    return a && a.__esModule ? a : { default: a };
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.RestMessageAdapter = t.RestRequestType = void 0;
  const n = e(QR), r = k();
  var s;
  (function(a) {
    a.Get = "GET", a.Post = "POST", a.Delete = "DELETE", a.File = "file";
  })(s = t.RestRequestType || (t.RestRequestType = {}));
  class o {
    constructor(i) {
      if (!i)
        throw new r.ArgumentNullError("configParams");
      this.privHeaders = i.headers, this.privIgnoreCache = i.ignoreCache;
    }
    static extractHeaderValue(i, c) {
      let u = "";
      try {
        const p = c.trim().split(/[\r\n]+/), d = {};
        p.forEach((l) => {
          const h = l.split(": "), v = h.shift().toLowerCase(), g = h.join(": ");
          d[v] = g;
        }), u = d[i.toLowerCase()];
      } catch {
      }
      return u;
    }
    set options(i) {
      this.privHeaders = i.headers, this.privIgnoreCache = i.ignoreCache;
    }
    setHeaders(i, c) {
      this.privHeaders[i] = c;
    }
    request(i, c, u = {}, p = null) {
      const d = new r.Deferred(), l = i === s.File ? "POST" : i, h = (g, f = {}) => {
        const m = g;
        return {
          data: JSON.stringify(f),
          headers: JSON.stringify(g.headers),
          json: f,
          ok: g.statusCode >= 200 && g.statusCode < 300,
          status: g.statusCode,
          statusText: f.error ? f.error.message : m.statusText ? m.statusText : m.statusMessage
        };
      }, v = (g) => {
        const f = n.default(c, l, this.privHeaders, 200, 201, 202, 204, 400, 401, 402, 403, 404), m = this.queryParams(u) === "" ? "" : `?${this.queryParams(u)}`;
        f(m, g).then(async (S) => {
          if (i === s.Delete || S.statusCode === 204)
            d.resolve(h(S));
          else
            try {
              const y = await S.json();
              d.resolve(h(S, y));
            } catch {
              d.resolve(h(S));
            }
        }).catch((S) => {
          d.reject(S);
        });
      };
      return this.privIgnoreCache && (this.privHeaders["Cache-Control"] = "no-cache"), i === s.Post && p && (this.privHeaders["content-type"] = "application/json", this.privHeaders["Content-Type"] = "application/json"), v(p), d.promise;
    }
    queryParams(i = {}) {
      return Object.keys(i).map((c) => encodeURIComponent(c) + "=" + encodeURIComponent(i[c])).join("&");
    }
  }
  t.RestMessageAdapter = o;
})(og);
var Ps = {};
Object.defineProperty(Ps, "__esModule", { value: !0 });
Ps.RestConfigBase = void 0;
class jt {
  static get requestOptions() {
    return jt.privDefaultRequestOptions;
  }
  static get configParams() {
    return jt.privDefaultParams;
  }
  static get restErrors() {
    return jt.privRestErrors;
  }
}
Ps.RestConfigBase = jt;
jt.privDefaultRequestOptions = {
  headers: {
    Accept: "application/json"
  },
  ignoreCache: !1,
  timeout: 1e4
};
jt.privRestErrors = {
  authInvalidSubscriptionKey: "You must specify either an authentication token to use, or a Cognitive Speech subscription key.",
  authInvalidSubscriptionRegion: "You must specify the Cognitive Speech region to use.",
  invalidArgs: "Required input not found: {arg}.",
  invalidCreateJoinConversationResponse: "Creating/Joining conversation failed with HTTP {status}.",
  invalidParticipantRequest: "The requested participant was not found.",
  permissionDeniedConnect: "Required credentials not found.",
  permissionDeniedConversation: "Invalid operation: only the host can {command} the conversation.",
  permissionDeniedParticipant: "Invalid operation: only the host can {command} a participant.",
  permissionDeniedSend: "Invalid operation: the conversation is not in a connected state.",
  permissionDeniedStart: "Invalid operation: there is already an active conversation."
};
jt.privDefaultParams = {
  apiVersion: "api-version",
  authorization: "Authorization",
  clientAppId: "X-ClientAppId",
  contentTypeKey: "Content-Type",
  correlationId: "X-CorrelationId",
  languageCode: "language",
  nickname: "nickname",
  profanity: "profanity",
  requestId: "X-RequestId",
  roomId: "roomid",
  sessionToken: "token",
  subscriptionKey: "Ocp-Apim-Subscription-Key",
  subscriptionRegion: "Ocp-Apim-Subscription-Region",
  token: "X-CapitoToken"
};
var Sl;
function ye() {
  return Sl || (Sl = 1, function(t) {
    var e = W && W.__createBinding || (Object.create ? function(r, s, o, a) {
      a === void 0 && (a = o), Object.defineProperty(r, a, { enumerable: !0, get: function() {
        return s[o];
      } });
    } : function(r, s, o, a) {
      a === void 0 && (a = o), r[a] = s[o];
    }), n = W && W.__exportStar || function(r, s) {
      for (var o in r)
        o !== "default" && !s.hasOwnProperty(o) && e(s, r, o);
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), n(Yo, t), n(gf, t), n(K_(), t), n(J_(), t), n(Zo, t), n(Xo, t), n(Ss, t), n(ea, t), n(WR(), t), n(og, t), n(Ps, t);
  }(vc)), vc;
}
var yl;
function YR() {
  if (yl)
    return gr;
  yl = 1, Object.defineProperty(gr, "__esModule", { value: !0 }), gr.IntentConnectionFactory = void 0;
  const t = ye(), e = R(), n = ot(), r = A(), s = Se;
  let o = class extends n.ConnectionFactoryBase {
    create(i, c, u) {
      let p = i.parameters.getProperty(e.PropertyId.SpeechServiceConnection_Endpoint);
      if (!p) {
        const v = i.parameters.getProperty(e.PropertyId.SpeechServiceConnection_IntentRegion), g = n.ConnectionFactoryBase.getHostSuffix(v);
        p = i.parameters.getProperty(e.PropertyId.SpeechServiceConnection_Host, "wss://" + v + ".sr.speech" + g) + "/speech/recognition/interactive/cognitiveservices/v1";
      }
      const d = {
        format: "simple",
        language: i.parameters.getProperty(e.PropertyId.SpeechServiceConnection_RecoLanguage)
      };
      this.setCommonUrlParams(i, d, p);
      const l = {};
      c.token !== void 0 && c.token !== "" && (l[c.headerName] = c.token), l[s.HeaderNames.ConnectionId] = u, i.parameters.setProperty(e.PropertyId.SpeechServiceConnection_Url, p);
      const h = i.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
      return new t.WebsocketConnection(p, d, l, new r.WebsocketMessageFormatter(), t.ProxyInfo.fromRecognizerConfig(i), h, u);
    }
    getSpeechRegionFromIntentRegion(i) {
      switch (i) {
        case "West US":
        case "US West":
        case "westus":
          return "uswest";
        case "West US 2":
        case "US West 2":
        case "westus2":
          return "uswest2";
        case "South Central US":
        case "US South Central":
        case "southcentralus":
          return "ussouthcentral";
        case "West Central US":
        case "US West Central":
        case "westcentralus":
          return "uswestcentral";
        case "East US":
        case "US East":
        case "eastus":
          return "useast";
        case "East US 2":
        case "US East 2":
        case "eastus2":
          return "useast2";
        case "West Europe":
        case "Europe West":
        case "westeurope":
          return "europewest";
        case "North Europe":
        case "Europe North":
        case "northeurope":
          return "europenorth";
        case "Brazil South":
        case "South Brazil":
        case "southbrazil":
          return "brazilsouth";
        case "Australia East":
        case "East Australia":
        case "eastaustralia":
          return "australiaeast";
        case "Southeast Asia":
        case "Asia Southeast":
        case "southeastasia":
          return "asiasoutheast";
        case "East Asia":
        case "Asia East":
        case "eastasia":
          return "asiaeast";
        default:
          return i;
      }
    }
  };
  return gr.IntentConnectionFactory = o, gr;
}
var on = {}, Cl;
function ZR() {
  if (Cl)
    return on;
  Cl = 1, Object.defineProperty(on, "__esModule", { value: !0 }), on.VoiceProfileConnectionFactory = on.SpeakerRecognitionConnectionFactory = void 0;
  const t = ye(), e = R(), n = ot(), r = A(), s = Se;
  class o extends n.ConnectionFactoryBase {
    create(u, p, d, l) {
      let h = u.parameters.getProperty(e.PropertyId.SpeechServiceConnection_Endpoint);
      if (!h) {
        const m = u.parameters.getProperty(e.PropertyId.SpeechServiceConnection_Region), S = n.ConnectionFactoryBase.getHostSuffix(m), y = u.parameters.getProperty(e.PropertyId.SpeechServiceConnection_Host, `wss://${m}.spr-frontend.speech${S}`), P = u.parameters.getProperty(e.PropertyId.SpeechServiceConnection_SpeakerIdMode, "TextIndependentIdentification");
        h = `${y}/speaker/ws/${this.scenarioToPath(P)}/${d}`;
      }
      const v = {
        format: "simple",
        language: u.parameters.getProperty(e.PropertyId.SpeechServiceConnection_RecoLanguage)
      };
      this.setCommonUrlParams(u, v, h);
      const g = {};
      p.token !== void 0 && p.token !== "" && (g[p.headerName] = p.token), g[s.HeaderNames.ConnectionId] = l, g[s.HeaderNames.SpIDAuthKey] = u.parameters.getProperty(e.PropertyId.SpeechServiceConnection_Key), u.parameters.setProperty(e.PropertyId.SpeechServiceConnection_Url, h);
      const f = u.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
      return new t.WebsocketConnection(h, v, g, new r.WebsocketMessageFormatter(), t.ProxyInfo.fromRecognizerConfig(u), f, l);
    }
    scenarioToPath(u) {
      switch (u) {
        case "TextIndependentVerification":
        case "2":
          return "verification/text-independent";
        case "TextDependentVerification":
        case "1":
          return "verification/text-dependent";
        default:
          return "identification/text-independent";
      }
    }
  }
  let a = class extends o {
    create(u, p, d) {
      return super.create(u, p, "recognition", d);
    }
  };
  on.SpeakerRecognitionConnectionFactory = a;
  class i extends o {
    create(u, p, d) {
      return super.create(u, p, "profile", d);
    }
  }
  return on.VoiceProfileConnectionFactory = i, on;
}
var Ea = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.RecognitionEndedEvent = t.RecognitionCompletionStatus = t.RecognitionStartedEvent = t.ConnectingToServiceEvent = t.ListeningStartedEvent = t.RecognitionTriggeredEvent = t.SpeechRecognitionEvent = void 0;
  const e = k();
  class n extends e.PlatformEvent {
    constructor(p, d, l, h = e.EventType.Info) {
      super(p, h), this.privRequestId = d, this.privSessionId = l;
    }
    get requestId() {
      return this.privRequestId;
    }
    get sessionId() {
      return this.privSessionId;
    }
  }
  t.SpeechRecognitionEvent = n;
  class r extends n {
    constructor(p, d, l, h) {
      super("RecognitionTriggeredEvent", p, d), this.privAudioSourceId = l, this.privAudioNodeId = h;
    }
    get audioSourceId() {
      return this.privAudioSourceId;
    }
    get audioNodeId() {
      return this.privAudioNodeId;
    }
  }
  t.RecognitionTriggeredEvent = r;
  class s extends n {
    constructor(p, d, l, h) {
      super("ListeningStartedEvent", p, d), this.privAudioSourceId = l, this.privAudioNodeId = h;
    }
    get audioSourceId() {
      return this.privAudioSourceId;
    }
    get audioNodeId() {
      return this.privAudioNodeId;
    }
  }
  t.ListeningStartedEvent = s;
  class o extends n {
    constructor(p, d, l) {
      super("ConnectingToServiceEvent", p, l), this.privAuthFetchEventid = d;
    }
    get authFetchEventid() {
      return this.privAuthFetchEventid;
    }
  }
  t.ConnectingToServiceEvent = o;
  class a extends n {
    constructor(p, d, l, h, v) {
      super("RecognitionStartedEvent", p, v), this.privAudioSourceId = d, this.privAudioNodeId = l, this.privAuthFetchEventId = h;
    }
    get audioSourceId() {
      return this.privAudioSourceId;
    }
    get audioNodeId() {
      return this.privAudioNodeId;
    }
    get authFetchEventId() {
      return this.privAuthFetchEventId;
    }
  }
  t.RecognitionStartedEvent = a;
  var i;
  (function(u) {
    u[u.Success = 0] = "Success", u[u.AudioSourceError = 1] = "AudioSourceError", u[u.AudioSourceTimeout = 2] = "AudioSourceTimeout", u[u.AuthTokenFetchError = 3] = "AuthTokenFetchError", u[u.AuthTokenFetchTimeout = 4] = "AuthTokenFetchTimeout", u[u.UnAuthorized = 5] = "UnAuthorized", u[u.ConnectTimeout = 6] = "ConnectTimeout", u[u.ConnectError = 7] = "ConnectError", u[u.ClientRecognitionActivityTimeout = 8] = "ClientRecognitionActivityTimeout", u[u.UnknownError = 9] = "UnknownError";
  })(i = t.RecognitionCompletionStatus || (t.RecognitionCompletionStatus = {}));
  class c extends n {
    constructor(p, d, l, h, v, g, f, m) {
      super("RecognitionEndedEvent", p, v, f === i.Success ? e.EventType.Info : e.EventType.Error), this.privAudioSourceId = d, this.privAudioNodeId = l, this.privAuthFetchEventId = h, this.privStatus = f, this.privError = m, this.privServiceTag = g;
    }
    get audioSourceId() {
      return this.privAudioSourceId;
    }
    get audioNodeId() {
      return this.privAudioNodeId;
    }
    get authFetchEventId() {
      return this.privAuthFetchEventId;
    }
    get serviceTag() {
      return this.privServiceTag;
    }
    get status() {
      return this.privStatus;
    }
    get error() {
      return this.privError;
    }
  }
  t.RecognitionEndedEvent = c;
})(Ea);
var _i = {}, It = {};
Object.defineProperty(It, "__esModule", { value: !0 });
It.SpeechConnectionMessage = void 0;
const Rc = k(), mt = Se;
class $u extends Rc.ConnectionMessage {
  constructor(e, n, r, s, o, a, i, c) {
    if (!n)
      throw new Rc.ArgumentNullError("path");
    if (!r)
      throw new Rc.ArgumentNullError("requestId");
    const u = {};
    if (u[mt.HeaderNames.Path] = n, u[mt.HeaderNames.RequestId] = r, u[mt.HeaderNames.RequestTimestamp] = (/* @__PURE__ */ new Date()).toISOString(), s && (u[mt.HeaderNames.ContentType] = s), a && (u[mt.HeaderNames.RequestStreamId] = a), i)
      for (const p in i)
        p && (u[p] = i[p]);
    c ? super(e, o, u, c) : super(e, o, u), this.privPath = n, this.privRequestId = r, this.privContentType = s, this.privStreamId = a, this.privAdditionalHeaders = i;
  }
  get path() {
    return this.privPath;
  }
  get requestId() {
    return this.privRequestId;
  }
  get contentType() {
    return this.privContentType;
  }
  get streamId() {
    return this.privStreamId;
  }
  get additionalHeaders() {
    return this.privAdditionalHeaders;
  }
  static fromConnectionMessage(e) {
    let n = null, r = null, s = null, o = null;
    const a = {};
    if (e.headers)
      for (const i in e.headers)
        i && (i.toLowerCase() === mt.HeaderNames.Path.toLowerCase() ? n = e.headers[i] : i.toLowerCase() === mt.HeaderNames.RequestId.toLowerCase() ? r = e.headers[i] : i.toLowerCase() === mt.HeaderNames.ContentType.toLowerCase() ? s = e.headers[i] : i.toLowerCase() === mt.HeaderNames.RequestStreamId.toLowerCase() ? o = e.headers[i] : a[i] = e.headers[i]);
    return new $u(e.messageType, n, r, s, e.body, o, a, e.id);
  }
}
It.SpeechConnectionMessage = $u;
var _l;
function XR() {
  if (_l)
    return _i;
  _l = 1, Object.defineProperty(_i, "__esModule", { value: !0 }), _i.ServiceRecognizerBase = void 0;
  const t = ye(), e = k(), n = R(), r = A(), s = It;
  let o = class Zi {
    constructor(i, c, u, p, d) {
      if (this.privConnectionConfigurationPromise = void 0, this.privConnectionPromise = void 0, this.privSetTimeout = setTimeout, this.privIsLiveAudio = !1, this.privAverageBytesPerMs = 0, this.privEnableSpeakerId = !1, this.privExpectContentAssessmentResponse = !1, this.recognizeOverride = void 0, this.recognizeSpeaker = void 0, this.disconnectOverride = void 0, this.receiveMessageOverride = void 0, this.sendPrePayloadJSONOverride = void 0, this.postConnectImplOverride = void 0, this.configConnectionOverride = void 0, this.handleSpeechPhraseMessage = void 0, this.handleSpeechHypothesisMessage = void 0, !i)
        throw new e.ArgumentNullError("authentication");
      if (!c)
        throw new e.ArgumentNullError("connectionFactory");
      if (!u)
        throw new e.ArgumentNullError("audioSource");
      if (!p)
        throw new e.ArgumentNullError("recognizerConfig");
      this.privEnableSpeakerId = p.isSpeakerDiarizationEnabled, this.privMustReportEndOfStream = !1, this.privAuthentication = i, this.privConnectionFactory = c, this.privAudioSource = u, this.privRecognizerConfig = p, this.privIsDisposed = !1, this.privRecognizer = d, this.privRequestSession = new r.RequestSession(this.privAudioSource.id()), this.privConnectionEvents = new e.EventSource(), this.privServiceEvents = new e.EventSource(), this.privDynamicGrammar = new r.DynamicGrammarBuilder(), this.privSpeechContext = new r.SpeechContext(this.privDynamicGrammar), this.privAgentConfig = new r.AgentConfig(), this.privRecognizerConfig.parameters.getProperty(n.PropertyId.WebWorkerLoadType, "on").toLowerCase() === "on" && typeof Blob < "u" && typeof Worker < "u" ? this.privSetTimeout = e.Timeout.setTimeout : (typeof window < "u" && (this.privSetTimeout = window.setTimeout.bind(window)), typeof globalThis < "u" && (this.privSetTimeout = globalThis.setTimeout.bind(globalThis))), this.connectionEvents.attach((h) => {
        if (h.name === "ConnectionClosedEvent") {
          const v = h;
          (v.statusCode === 1003 || v.statusCode === 1007 || v.statusCode === 1002 || v.statusCode === 4e3 || this.privRequestSession.numConnectionAttempts > this.privRecognizerConfig.maxRetryCount) && this.cancelRecognitionLocal(n.CancellationReason.Error, v.statusCode === 1007 ? n.CancellationErrorCode.BadRequestParameters : n.CancellationErrorCode.ConnectionFailure, `${v.reason} websocket error code: ${v.statusCode}`);
        }
      }), this.privEnableSpeakerId && (this.privDiarizationSessionId = e.createNoDashGuid()), this.setLanguageIdJson(), this.setOutputDetailLevelJson();
    }
    setTranslationJson() {
      const i = this.privRecognizerConfig.parameters.getProperty(n.PropertyId.SpeechServiceConnection_TranslationToLanguages, void 0);
      if (i !== void 0) {
        const c = i.split(","), u = this.privRecognizerConfig.parameters.getProperty(n.PropertyId.SpeechServiceConnection_TranslationVoice, void 0), p = u !== void 0 ? "Synthesize" : "None";
        if (this.privSpeechContext.setSection("translation", {
          onSuccess: { action: p },
          output: { interimResults: { mode: "Always" } },
          targetLanguages: c
        }), u !== void 0) {
          const d = {};
          for (const l of c)
            d[l] = u;
          this.privSpeechContext.setSection("synthesis", {
            defaultVoices: d
          });
        }
      }
    }
    setSpeechSegmentationTimeoutJson() {
      const i = this.privRecognizerConfig.parameters.getProperty(n.PropertyId.Speech_SegmentationSilenceTimeoutMs, void 0), c = this.privRecognizerConfig.parameters.getProperty(n.PropertyId.Speech_SegmentationMaximumTimeMs, void 0), u = this.privRecognizerConfig.parameters.getProperty(n.PropertyId.Speech_SegmentationStrategy, void 0), p = {
        segmentation: {
          mode: ""
        }
      };
      let d = !1;
      if (u !== void 0) {
        d = !0;
        let l = "";
        switch (u.toLowerCase()) {
          case "default":
            break;
          case "time":
            l = "Custom";
            break;
          case "semantic":
            l = "Semantic";
            break;
        }
        p.segmentation.mode = l;
      }
      if (i !== void 0) {
        d = !0;
        const l = parseInt(i, 10);
        p.segmentation.mode = "Custom", p.segmentation.segmentationSilenceTimeoutMs = l;
      }
      if (c !== void 0) {
        d = !0;
        const l = parseInt(c, 10);
        p.segmentation.mode = "Custom", p.segmentation.segmentationForcedTimeoutMs = l;
      }
      if (d) {
        const l = this.recognitionMode === r.RecognitionMode.Conversation ? "CONVERSATION" : this.recognitionMode === r.RecognitionMode.Dictation ? "DICTATION" : "INTERACTIVE", h = this.privSpeechContext.getSection("phraseDetection");
        h.mode = l, h[l] = p, this.privSpeechContext.setSection("phraseDetection", h);
      }
    }
    setLanguageIdJson() {
      const i = this.privSpeechContext.getSection("phraseDetection");
      if (this.privRecognizerConfig.autoDetectSourceLanguages !== void 0) {
        const u = this.privRecognizerConfig.autoDetectSourceLanguages.split(",");
        let p;
        this.privRecognizerConfig.languageIdMode === "Continuous" ? p = "DetectContinuous" : p = "DetectAtAudioStart", this.privSpeechContext.setSection("languageId", {
          Priority: "PrioritizeLatency",
          languages: u,
          mode: p,
          onSuccess: { action: "Recognize" },
          onUnknown: { action: "None" }
        }), this.privSpeechContext.setSection("phraseOutput", {
          interimResults: {
            resultType: "Auto"
          },
          phraseResults: {
            resultType: "Always"
          }
        });
        const d = this.privRecognizerConfig.sourceLanguageModels;
        d !== void 0 && (i.customModels = d, i.onInterim = { action: "None" }, i.onSuccess = { action: "None" });
      }
      this.privRecognizerConfig.parameters.getProperty(n.PropertyId.SpeechServiceConnection_TranslationToLanguages, void 0) !== void 0 && (i.onInterim = { action: "Translate" }, i.onSuccess = { action: "Translate" }, this.privSpeechContext.setSection("phraseOutput", {
        interimResults: {
          resultType: "None"
        },
        phraseResults: {
          resultType: "None"
        }
      })), this.privSpeechContext.setSection("phraseDetection", i);
    }
    setOutputDetailLevelJson() {
      this.privEnableSpeakerId && (this.privRecognizerConfig.parameters.getProperty(n.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, "false").toLowerCase() === "true" ? this.privSpeechContext.setWordLevelTimings() : this.privRecognizerConfig.parameters.getProperty(r.OutputFormatPropertyName, n.OutputFormat[n.OutputFormat.Simple]).toLowerCase() === n.OutputFormat[n.OutputFormat.Detailed].toLocaleLowerCase() && this.privSpeechContext.setDetailedOutputFormat());
    }
    get isSpeakerDiarizationEnabled() {
      return this.privEnableSpeakerId;
    }
    get audioSource() {
      return this.privAudioSource;
    }
    get speechContext() {
      return this.privSpeechContext;
    }
    get dynamicGrammar() {
      return this.privDynamicGrammar;
    }
    get agentConfig() {
      return this.privAgentConfig;
    }
    set conversationTranslatorToken(i) {
      this.privRecognizerConfig.parameters.setProperty(n.PropertyId.ConversationTranslator_Token, i);
    }
    set voiceProfileType(i) {
      this.privRecognizerConfig.parameters.setProperty(n.PropertyId.SpeechServiceConnection_SpeakerIdMode, i);
    }
    set authentication(i) {
      this.privAuthentication = i;
    }
    isDisposed() {
      return this.privIsDisposed;
    }
    async dispose(i) {
      if (this.privIsDisposed = !0, this.privConnectionConfigurationPromise !== void 0)
        try {
          await (await this.privConnectionConfigurationPromise).dispose(i);
        } catch {
          return;
        }
    }
    get connectionEvents() {
      return this.privConnectionEvents;
    }
    get serviceEvents() {
      return this.privServiceEvents;
    }
    get recognitionMode() {
      return this.privRecognizerConfig.recognitionMode;
    }
    async recognize(i, c, u) {
      if (this.recognizeOverride !== void 0) {
        await this.recognizeOverride(i, c, u);
        return;
      }
      this.privConnectionConfigurationPromise = void 0, this.privRecognizerConfig.recognitionMode = i, this.setSpeechSegmentationTimeoutJson(), this.setTranslationJson(), this.privSuccessCallback = c, this.privErrorCallback = u, this.privRequestSession.startNewRecognition(), this.privRequestSession.listenForServiceTelemetry(this.privAudioSource.events);
      const p = this.connectImpl();
      let d;
      try {
        const v = await this.audioSource.attach(this.privRequestSession.audioNodeId), g = await this.audioSource.format, f = await this.audioSource.deviceInfo;
        this.privIsLiveAudio = f.type && f.type === r.type.Microphones, d = new t.ReplayableAudioNode(v, g.avgBytesPerSec), await this.privRequestSession.onAudioSourceAttachCompleted(d, !1), this.privRecognizerConfig.SpeechServiceConfig.Context.audio = { source: f };
      } catch (v) {
        throw await this.privRequestSession.onStopRecognizing(), v;
      }
      try {
        await p;
      } catch (v) {
        await this.cancelRecognitionLocal(n.CancellationReason.Error, n.CancellationErrorCode.ConnectionFailure, v);
        return;
      }
      const l = new n.SessionEventArgs(this.privRequestSession.sessionId);
      this.privRecognizer.sessionStarted && this.privRecognizer.sessionStarted(this.privRecognizer, l), this.receiveMessage(), this.sendAudio(d).catch(async (v) => {
        await this.cancelRecognitionLocal(n.CancellationReason.Error, n.CancellationErrorCode.RuntimeError, v);
      });
    }
    async stopRecognizing() {
      if (this.privRequestSession.isRecognizing)
        try {
          await this.audioSource.turnOff(), await this.sendFinalAudio(), await this.privRequestSession.onStopRecognizing(), await this.privRequestSession.turnCompletionPromise;
        } finally {
          await this.privRequestSession.dispose();
        }
    }
    async connect() {
      return await this.connectImpl(), Promise.resolve();
    }
    connectAsync(i, c) {
      this.connectImpl().then(() => {
        try {
          i && i();
        } catch (u) {
          c && c(u);
        }
      }, (u) => {
        try {
          c && c(u);
        } catch {
        }
      });
    }
    async disconnect() {
      if (await this.cancelRecognitionLocal(n.CancellationReason.Error, n.CancellationErrorCode.NoError, "Disconnecting"), this.disconnectOverride !== void 0 && await this.disconnectOverride(), this.privConnectionPromise !== void 0)
        try {
          await (await this.privConnectionPromise).dispose();
        } catch {
        }
      this.privConnectionPromise = void 0;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    sendMessage(i) {
    }
    async sendNetworkMessage(i, c) {
      const u = typeof c == "string" ? e.MessageType.Text : e.MessageType.Binary, p = typeof c == "string" ? "application/json" : "";
      return (await this.fetchConnection()).send(new s.SpeechConnectionMessage(u, i, this.privRequestSession.requestId, p, c));
    }
    set activityTemplate(i) {
      this.privActivityTemplate = i;
    }
    get activityTemplate() {
      return this.privActivityTemplate;
    }
    set expectContentAssessmentResponse(i) {
      this.privExpectContentAssessmentResponse = i;
    }
    async sendTelemetryData() {
      const i = this.privRequestSession.getTelemetry();
      if (Zi.telemetryDataEnabled !== !0 || this.privIsDisposed || i === null)
        return;
      if (Zi.telemetryData)
        try {
          Zi.telemetryData(i);
        } catch {
        }
      await (await this.fetchConnection()).send(new s.SpeechConnectionMessage(e.MessageType.Text, "telemetry", this.privRequestSession.requestId, "application/json", i));
    }
    // Cancels recognition.
    async cancelRecognitionLocal(i, c, u) {
      this.privRequestSession.isRecognizing && (await this.privRequestSession.onStopRecognizing(), this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, i, c, u));
    }
    async receiveMessage() {
      try {
        if (this.privIsDisposed)
          return;
        let i = await this.fetchConnection();
        const c = await i.read();
        if (this.receiveMessageOverride !== void 0)
          return this.receiveMessageOverride();
        if (!c)
          return this.receiveMessage();
        this.privServiceHasSentMessage = !0;
        const u = s.SpeechConnectionMessage.fromConnectionMessage(c);
        if (u.requestId.toLowerCase() === this.privRequestSession.requestId.toLowerCase())
          switch (u.path.toLowerCase()) {
            case "turn.start":
              this.privMustReportEndOfStream = !0, this.privRequestSession.onServiceTurnStartResponse();
              break;
            case "speech.startdetected":
              const p = r.SpeechDetected.fromJSON(u.textBody, this.privRequestSession.currentTurnAudioOffset), d = new n.RecognitionEventArgs(p.Offset, this.privRequestSession.sessionId);
              this.privRecognizer.speechStartDetected && this.privRecognizer.speechStartDetected(this.privRecognizer, d);
              break;
            case "speech.enddetected":
              let l;
              u.textBody.length > 0 ? l = u.textBody : l = "{ Offset: 0 }";
              const h = r.SpeechDetected.fromJSON(l, this.privRequestSession.currentTurnAudioOffset), v = new n.RecognitionEventArgs(h.Offset + this.privRequestSession.currentTurnAudioOffset, this.privRequestSession.sessionId);
              this.privRecognizer.speechEndDetected && this.privRecognizer.speechEndDetected(this.privRecognizer, v);
              break;
            case "turn.end":
              await this.sendTelemetryData(), this.privRequestSession.isSpeechEnded && this.privMustReportEndOfStream && (this.privMustReportEndOfStream = !1, await this.cancelRecognitionLocal(n.CancellationReason.EndOfStream, n.CancellationErrorCode.NoError, void 0));
              const g = new n.SessionEventArgs(this.privRequestSession.sessionId);
              if (await this.privRequestSession.onServiceTurnEndResponse(this.privRecognizerConfig.isContinuousRecognition), !this.privRecognizerConfig.isContinuousRecognition || this.privRequestSession.isSpeechEnded || !this.privRequestSession.isRecognizing) {
                this.privRecognizer.sessionStopped && this.privRecognizer.sessionStopped(this.privRecognizer, g);
                return;
              } else
                i = await this.fetchConnection(), await this.sendPrePayloadJSON(i);
              break;
            default:
              await this.processTypeSpecificMessages(u) || this.privServiceEvents && this.serviceEvents.onEvent(new e.ServiceEvent(u.path.toLowerCase(), u.textBody));
          }
        return this.receiveMessage();
      } catch {
        return null;
      }
    }
    updateSpeakerDiarizationAudioOffset() {
      const i = this.privRequestSession.recognitionBytesSent, c = this.privAverageBytesPerMs !== 0 ? i / this.privAverageBytesPerMs : 0;
      this.privSpeechContext.setSpeakerDiarizationAudioOffsetMs(c);
    }
    sendSpeechContext(i, c) {
      this.privEnableSpeakerId && this.updateSpeakerDiarizationAudioOffset();
      const u = this.speechContext.toJSON();
      if (c && this.privRequestSession.onSpeechContext(), u)
        return i.send(new s.SpeechConnectionMessage(e.MessageType.Text, "speech.context", this.privRequestSession.requestId, "application/json", u));
    }
    noOp() {
    }
    // Encapsulated for derived service recognizers that need to send additional JSON
    async sendPrePayloadJSON(i, c = !0) {
      if (this.sendPrePayloadJSONOverride !== void 0)
        return this.sendPrePayloadJSONOverride(i);
      await this.sendSpeechContext(i, c), await this.sendWaveHeader(i);
    }
    async sendWaveHeader(i) {
      const c = await this.audioSource.format;
      return i.send(new s.SpeechConnectionMessage(e.MessageType.Binary, "audio", this.privRequestSession.requestId, "audio/x-wav", c.header));
    }
    // Establishes a websocket connection to the end point.
    connectImpl() {
      return this.privConnectionPromise !== void 0 ? this.privConnectionPromise.then((i) => i.state() === e.ConnectionState.Disconnected ? (this.privConnectionId = null, this.privConnectionPromise = void 0, this.privServiceHasSentMessage = !1, this.connectImpl()) : this.privConnectionPromise, () => (this.privConnectionId = null, this.privConnectionPromise = void 0, this.privServiceHasSentMessage = !1, this.connectImpl())) : (this.privConnectionPromise = this.retryableConnect(), this.privConnectionPromise.catch(() => {
      }), this.postConnectImplOverride !== void 0 ? this.postConnectImplOverride(this.privConnectionPromise) : this.privConnectionPromise);
    }
    sendSpeechServiceConfig(i, c, u) {
      if (c.onSpeechContext(), Zi.telemetryDataEnabled !== !0) {
        const d = {
          context: {
            system: JSON.parse(u).context.system
          }
        };
        u = JSON.stringify(d);
      }
      if (this.privRecognizerConfig.parameters.getProperty("f0f5debc-f8c9-4892-ac4b-90a7ab359fd2", "false").toLowerCase() === "true") {
        const p = JSON.parse(u);
        p.context.DisableReferenceChannel = "True", p.context.MicSpec = "1_0_0", u = JSON.stringify(p);
      }
      if (u)
        return i.send(new s.SpeechConnectionMessage(e.MessageType.Text, "speech.config", c.requestId, "application/json", u));
    }
    async fetchConnection() {
      return this.privConnectionConfigurationPromise !== void 0 ? this.privConnectionConfigurationPromise.then((i) => i.state() === e.ConnectionState.Disconnected ? (this.privConnectionId = null, this.privConnectionConfigurationPromise = void 0, this.privServiceHasSentMessage = !1, this.fetchConnection()) : this.privConnectionConfigurationPromise, () => (this.privConnectionId = null, this.privConnectionConfigurationPromise = void 0, this.privServiceHasSentMessage = !1, this.fetchConnection())) : (this.privConnectionConfigurationPromise = this.configureConnection(), await this.privConnectionConfigurationPromise);
    }
    async sendAudio(i) {
      const c = await this.audioSource.format;
      this.privAverageBytesPerMs = c.avgBytesPerSec / 1e3;
      let u = Date.now();
      const p = this.privRecognizerConfig.parameters.getProperty("SPEECH-TransmitLengthBeforThrottleMs", "5000"), d = c.avgBytesPerSec / 1e3 * parseInt(p, 10), l = this.privRequestSession.recogNumber, h = async () => {
        if (!this.privIsDisposed && !this.privRequestSession.isSpeechEnded && this.privRequestSession.isRecognizing && this.privRequestSession.recogNumber === l) {
          const v = await this.fetchConnection(), g = await i.read();
          if (this.privRequestSession.isSpeechEnded)
            return;
          let f, m;
          if (!g || g.isEnd ? (f = null, m = 0) : (f = g.buffer, this.privRequestSession.onAudioSent(f.byteLength), d >= this.privRequestSession.bytesSent ? m = 0 : m = Math.max(0, u - Date.now())), m !== 0 && await this.delay(m), f !== null && (u = Date.now() + f.byteLength * 1e3 / (c.avgBytesPerSec * 2)), !this.privIsDisposed && !this.privRequestSession.isSpeechEnded && this.privRequestSession.isRecognizing && this.privRequestSession.recogNumber === l)
            if (v.send(new s.SpeechConnectionMessage(e.MessageType.Binary, "audio", this.privRequestSession.requestId, null, f)).catch(() => {
              this.privRequestSession.onServiceTurnEndResponse(this.privRecognizerConfig.isContinuousRecognition).catch(() => {
              });
            }), g != null && g.isEnd)
              this.privIsLiveAudio || this.privRequestSession.onSpeechEnded();
            else
              return h();
        }
      };
      return h();
    }
    async retryableConnect() {
      let i = !1;
      this.privAuthFetchEventId = e.createNoDashGuid();
      const c = this.privRequestSession.sessionId;
      this.privConnectionId = c !== void 0 ? c : e.createNoDashGuid(), this.privRequestSession.onPreConnectionStart(this.privAuthFetchEventId, this.privConnectionId);
      let u = 0, p = "";
      for (; this.privRequestSession.numConnectionAttempts <= this.privRecognizerConfig.maxRetryCount; ) {
        const l = await (i ? this.privAuthentication.fetchOnExpiry(this.privAuthFetchEventId) : this.privAuthentication.fetch(this.privAuthFetchEventId));
        await this.privRequestSession.onAuthCompleted(!1);
        const h = this.privConnectionFactory.create(this.privRecognizerConfig, l, this.privConnectionId);
        this.privRequestSession.listenForServiceTelemetry(h.events), h.events.attach((g) => {
          this.connectionEvents.onEvent(g);
        });
        const v = await h.open();
        if (v.statusCode === 200)
          return await this.privRequestSession.onConnectionEstablishCompleted(v.statusCode), Promise.resolve(h);
        v.statusCode === 1006 && (i = !0), u = v.statusCode, p = v.reason, this.privRequestSession.onRetryConnection();
      }
      return await this.privRequestSession.onConnectionEstablishCompleted(u, p), Promise.reject(`Unable to contact server. StatusCode: ${u}, ${this.privRecognizerConfig.parameters.getProperty(n.PropertyId.SpeechServiceConnection_Endpoint)} Reason: ${p}`);
    }
    delay(i) {
      return new Promise((c) => this.privSetTimeout(c, i));
    }
    writeBufferToConsole(i) {
      let c = "Buffer Size: ";
      if (i === null)
        c += "null";
      else {
        const u = new Uint8Array(i);
        c += `${i.byteLength}\r
`;
        for (let p = 0; p < i.byteLength; p++)
          c += u[p].toString(16).padStart(2, "0") + " ", (p + 1) % 16 === 0 && (console.info(c), c = "");
      }
      console.info(c);
    }
    async sendFinalAudio() {
      await (await this.fetchConnection()).send(new s.SpeechConnectionMessage(e.MessageType.Binary, "audio", this.privRequestSession.requestId, null, null));
    }
    // Takes an established websocket connection to the endpoint and sends speech configuration information.
    async configureConnection() {
      const i = await this.connectImpl();
      return this.configConnectionOverride !== void 0 ? this.configConnectionOverride(i) : (await this.sendSpeechServiceConfig(i, this.privRequestSession, this.privRecognizerConfig.SpeechServiceConfig.serialize()), await this.sendPrePayloadJSON(i, !1), i);
    }
  };
  return _i.ServiceRecognizerBase = o, o.telemetryDataEnabled = !0, _i;
}
var Ri = {}, Rl;
function eP() {
  if (Rl)
    return Ri;
  Rl = 1, Object.defineProperty(Ri, "__esModule", { value: !0 }), Ri.ConversationServiceRecognizer = void 0;
  const t = R(), e = A();
  let n = class extends e.ServiceRecognizerBase {
    constructor(s, o, a, i, c) {
      super(s, o, a, i, c), this.handleSpeechPhraseMessage = async (u) => this.handleSpeechPhrase(u), this.handleSpeechHypothesisMessage = (u) => this.handleSpeechHypothesis(u);
    }
    processTypeSpecificMessages(s) {
    }
    handleRecognizedCallback(s, o, a) {
    }
    handleRecognizingCallback(s, o, a) {
    }
    async processSpeechMessages(s) {
      let o = !1;
      switch (s.path.toLowerCase()) {
        case "speech.hypothesis":
        case "speech.fragment":
          this.handleSpeechHypothesisMessage && this.handleSpeechHypothesisMessage(s.textBody), o = !0;
          break;
        case "speech.phrase":
          this.handleSpeechPhraseMessage && await this.handleSpeechPhraseMessage(s.textBody), o = !0;
          break;
      }
      return o;
    }
    cancelRecognition(s, o, a, i, c) {
    }
    async handleSpeechPhrase(s) {
      const o = e.SimpleSpeechPhrase.fromJSON(s, this.privRequestSession.currentTurnAudioOffset), a = e.EnumTranslation.implTranslateRecognitionResult(o.RecognitionStatus);
      let i;
      const c = new t.PropertyCollection();
      if (c.setProperty(t.PropertyId.SpeechServiceResponse_JsonResult, s), this.privRequestSession.onPhraseRecognized(o.Offset + o.Duration), t.ResultReason.Canceled === a) {
        const u = e.EnumTranslation.implTranslateCancelResult(o.RecognitionStatus), p = e.EnumTranslation.implTranslateCancelErrorCode(o.RecognitionStatus);
        await this.cancelRecognitionLocal(u, p, e.EnumTranslation.implTranslateErrorDetails(p));
      } else if (o.RecognitionStatus !== e.RecognitionStatus.EndOfDictation) {
        if (this.privRecognizerConfig.parameters.getProperty(e.OutputFormatPropertyName) === t.OutputFormat[t.OutputFormat.Simple])
          i = new t.SpeechRecognitionResult(this.privRequestSession.requestId, a, o.DisplayText, o.Duration, o.Offset, o.Language, o.LanguageDetectionConfidence, o.SpeakerId, void 0, o.asJson(), c);
        else {
          const u = e.DetailedSpeechPhrase.fromJSON(s, this.privRequestSession.currentTurnAudioOffset);
          i = new t.SpeechRecognitionResult(this.privRequestSession.requestId, a, u.Text, u.Duration, u.Offset, u.Language, u.LanguageDetectionConfidence, u.SpeakerId, void 0, u.asJson(), c);
        }
        this.handleRecognizedCallback(i, i.offset, this.privRequestSession.sessionId);
      }
    }
    handleSpeechHypothesis(s) {
      const o = e.SpeechHypothesis.fromJSON(s, this.privRequestSession.currentTurnAudioOffset), a = new t.PropertyCollection();
      a.setProperty(t.PropertyId.SpeechServiceResponse_JsonResult, s);
      const i = new t.SpeechRecognitionResult(this.privRequestSession.requestId, t.ResultReason.RecognizingSpeech, o.Text, o.Duration, o.Offset, o.Language, o.LanguageDetectionConfidence, o.SpeakerId, void 0, o.asJson(), a);
      this.privRequestSession.onHypothesis(o.Offset), this.handleRecognizingCallback(i, o.Duration, this.privRequestSession.sessionId);
    }
  };
  return Ri.ConversationServiceRecognizer = n, Ri;
}
var Pc = {}, Pl;
function tP() {
  return Pl || (Pl = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.RecognizerConfig = t.SpeechResultFormat = t.RecognitionMode = void 0;
    const e = R(), n = A();
    var r;
    (function(o) {
      o[o.Interactive = 0] = "Interactive", o[o.Conversation = 1] = "Conversation", o[o.Dictation = 2] = "Dictation";
    })(r = t.RecognitionMode || (t.RecognitionMode = {})), function(o) {
      o[o.Simple = 0] = "Simple", o[o.Detailed = 1] = "Detailed";
    }(t.SpeechResultFormat || (t.SpeechResultFormat = {}));
    class s {
      constructor(a, i) {
        this.privSpeechServiceConfig = a || new n.SpeechServiceConfig(new n.Context(null)), this.privParameters = i, this.privMaxRetryCount = parseInt(i.getProperty("SPEECH-Error-MaxRetryCount", "4"), 10), this.privLanguageIdMode = i.getProperty(e.PropertyId.SpeechServiceConnection_LanguageIdMode, void 0), this.privEnableSpeakerId = !1;
      }
      get parameters() {
        return this.privParameters;
      }
      get recognitionMode() {
        return this.privRecognitionMode;
      }
      set recognitionMode(a) {
        this.privRecognitionMode = a, this.privRecognitionActivityTimeout = a === r.Interactive ? 8e3 : 25e3, this.privSpeechServiceConfig.Recognition = r[a];
      }
      get SpeechServiceConfig() {
        return this.privSpeechServiceConfig;
      }
      get recognitionActivityTimeout() {
        return this.privRecognitionActivityTimeout;
      }
      get isContinuousRecognition() {
        return this.privRecognitionMode !== r.Interactive;
      }
      get languageIdMode() {
        return this.privLanguageIdMode;
      }
      get autoDetectSourceLanguages() {
        return this.parameters.getProperty(e.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, void 0);
      }
      get recognitionEndpointVersion() {
        return this.parameters.getProperty(e.PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, void 0);
      }
      get sourceLanguageModels() {
        const a = [];
        let i = !1;
        if (this.autoDetectSourceLanguages !== void 0)
          for (const c of this.autoDetectSourceLanguages.split(",")) {
            const u = c + e.PropertyId.SpeechServiceConnection_EndpointId.toString(), p = this.parameters.getProperty(u, void 0);
            p !== void 0 ? (a.push({ language: c, endpoint: p }), i = !0) : a.push({ language: c, endpoint: "" });
          }
        return i ? a : void 0;
      }
      get maxRetryCount() {
        return this.privMaxRetryCount;
      }
      get isSpeakerDiarizationEnabled() {
        return this.privEnableSpeakerId;
      }
      set isSpeakerDiarizationEnabled(a) {
        this.privEnableSpeakerId = a;
      }
    }
    t.RecognizerConfig = s;
  }(Pc)), Pc;
}
var ag = {};
Object.defineProperty(ag, "__esModule", { value: !0 });
var Ta = {};
Object.defineProperty(Ta, "__esModule", { value: !0 });
Ta.WebsocketMessageFormatter = void 0;
const Je = k(), El = `\r
`;
class nP {
  toConnectionMessage(e) {
    const n = new Je.Deferred();
    try {
      if (e.messageType === Je.MessageType.Text) {
        const r = e.textContent;
        let s = {}, o = null;
        if (r) {
          const a = r.split(`\r
\r
`);
          a && a.length > 0 && (s = this.parseHeaders(a[0]), a.length > 1 && (o = a[1]));
        }
        n.resolve(new Je.ConnectionMessage(e.messageType, o, s, e.id));
      } else if (e.messageType === Je.MessageType.Binary) {
        const r = e.binaryContent;
        let s = {}, o = null;
        if (!r || r.byteLength < 2)
          throw new Error("Invalid binary message format. Header length missing.");
        const a = new DataView(r), i = a.getInt16(0);
        if (r.byteLength < i + 2)
          throw new Error("Invalid binary message format. Header content missing.");
        let c = "";
        for (let u = 0; u < i; u++)
          c += String.fromCharCode(a.getInt8(u + 2));
        s = this.parseHeaders(c), r.byteLength > i + 2 && (o = r.slice(2 + i)), n.resolve(new Je.ConnectionMessage(e.messageType, o, s, e.id));
      }
    } catch (r) {
      n.reject(`Error formatting the message. Error: ${r}`);
    }
    return n.promise;
  }
  fromConnectionMessage(e) {
    const n = new Je.Deferred();
    try {
      if (e.messageType === Je.MessageType.Text) {
        const r = `${this.makeHeaders(e)}${El}${e.textBody ? e.textBody : ""}`;
        n.resolve(new Je.RawWebsocketMessage(Je.MessageType.Text, r, e.id));
      } else if (e.messageType === Je.MessageType.Binary) {
        const r = this.makeHeaders(e), s = e.binaryBody, o = this.stringToArrayBuffer(r), a = new Int8Array(o), i = a.byteLength, c = new Int8Array(2 + i + (s ? s.byteLength : 0));
        if (c[0] = i >> 8 & 255, c[1] = i & 255, c.set(a, 2), s) {
          const p = new Int8Array(s);
          c.set(p, 2 + i);
        }
        const u = c.buffer;
        n.resolve(new Je.RawWebsocketMessage(Je.MessageType.Binary, u, e.id));
      }
    } catch (r) {
      n.reject(`Error formatting the message. ${r}`);
    }
    return n.promise;
  }
  makeHeaders(e) {
    let n = "";
    if (e.headers)
      for (const r in e.headers)
        r && (n += `${r}: ${e.headers[r]}${El}`);
    return n;
  }
  parseHeaders(e) {
    const n = {};
    if (e) {
      const r = e.match(/[^\r\n]+/g);
      if (n) {
        for (const s of r)
          if (s) {
            const o = s.indexOf(":"), a = o > 0 ? s.substr(0, o).trim().toLowerCase() : s, i = o > 0 && s.length > o + 1 ? s.substr(o + 1).trim() : "";
            n[a] = i;
          }
      }
    }
    return n;
  }
  stringToArrayBuffer(e) {
    const n = new ArrayBuffer(e.length), r = new DataView(n);
    for (let s = 0; s < e.length; s++)
      r.setUint8(s, e.charCodeAt(s));
    return n;
  }
}
Ta.WebsocketMessageFormatter = nP;
var Pi = {}, Tl;
function rP() {
  if (Tl)
    return Pi;
  Tl = 1, Object.defineProperty(Pi, "__esModule", { value: !0 }), Pi.SpeechConnectionFactory = void 0;
  const t = ye(), e = A(), n = R(), r = ot(), s = A(), o = Se, a = st;
  let i = class extends r.ConnectionFactoryBase {
    constructor() {
      super(...arguments), this.interactiveRelativeUri = "/speech/recognition/interactive/cognitiveservices/v1", this.conversationRelativeUri = "/speech/recognition/conversation/cognitiveservices/v1", this.dictationRelativeUri = "/speech/recognition/dictation/cognitiveservices/v1", this.universalUri = "/speech/universal/v";
    }
    create(u, p, d) {
      let l = u.parameters.getProperty(n.PropertyId.SpeechServiceConnection_Endpoint, void 0);
      const h = u.parameters.getProperty(n.PropertyId.SpeechServiceConnection_Region, void 0), v = r.ConnectionFactoryBase.getHostSuffix(h), g = u.parameters.getProperty(n.PropertyId.SpeechServiceConnection_Host, "wss://" + h + ".stt.speech" + v), f = {}, m = u.parameters.getProperty(n.PropertyId.SpeechServiceConnection_EndpointId, void 0), S = u.parameters.getProperty(n.PropertyId.SpeechServiceConnection_RecoLanguage, void 0);
      if (m ? (!l || l.search(a.QueryParameterNames.CustomSpeechDeploymentId) === -1) && (f[a.QueryParameterNames.CustomSpeechDeploymentId] = m) : S && (!l || l.search(a.QueryParameterNames.Language) === -1) && (f[a.QueryParameterNames.Language] = S), (!l || l.search(a.QueryParameterNames.Format) === -1) && (f[a.QueryParameterNames.Format] = u.parameters.getProperty(e.OutputFormatPropertyName, n.OutputFormat[n.OutputFormat.Simple]).toLowerCase()), u.autoDetectSourceLanguages !== void 0 && (f[a.QueryParameterNames.EnableLanguageId] = "true"), this.setCommonUrlParams(u, f, l), !l)
        switch (u.recognitionMode) {
          case s.RecognitionMode.Conversation:
            u.parameters.getProperty(e.ForceDictationPropertyName, "false") === "true" ? l = g + this.dictationRelativeUri : u.recognitionEndpointVersion !== void 0 && parseInt(u.recognitionEndpointVersion, 10) > 1 ? l = `${g}${this.universalUri}${u.recognitionEndpointVersion}` : l = g + this.conversationRelativeUri;
            break;
          case s.RecognitionMode.Dictation:
            l = g + this.dictationRelativeUri;
            break;
          default:
            u.recognitionEndpointVersion !== void 0 && parseInt(u.recognitionEndpointVersion, 10) > 1 ? l = `${g}${this.universalUri}${u.recognitionEndpointVersion}` : l = g + this.interactiveRelativeUri;
            break;
        }
      const y = {};
      p.token !== void 0 && p.token !== "" && (y[p.headerName] = p.token), y[o.HeaderNames.ConnectionId] = d;
      const P = u.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true", C = new t.WebsocketConnection(l, f, y, new s.WebsocketMessageFormatter(), t.ProxyInfo.fromRecognizerConfig(u), P, d), _ = C.uri;
      return u.parameters.setProperty(n.PropertyId.SpeechServiceConnection_Url, _), C;
    }
  };
  return Pi.SpeechConnectionFactory = i, Pi;
}
var Ei = {}, Il;
function iP() {
  if (Il)
    return Ei;
  Il = 1, Object.defineProperty(Ei, "__esModule", { value: !0 }), Ei.ConversationTranscriberConnectionFactory = void 0;
  const t = ye(), e = R(), n = A(), r = ot(), s = A(), o = Se, a = st;
  let i = class extends r.ConnectionFactoryBase {
    constructor() {
      super(...arguments), this.universalUri = "/speech/universal/v2";
    }
    create(u, p, d) {
      let l = u.parameters.getProperty(e.PropertyId.SpeechServiceConnection_Endpoint, void 0);
      const h = u.parameters.getProperty(e.PropertyId.SpeechServiceConnection_Region, void 0), v = r.ConnectionFactoryBase.getHostSuffix(h), g = u.parameters.getProperty(e.PropertyId.SpeechServiceConnection_Host, "wss://" + h + ".stt.speech" + v), f = {}, m = u.parameters.getProperty(e.PropertyId.SpeechServiceConnection_EndpointId, void 0), S = u.parameters.getProperty(e.PropertyId.SpeechServiceConnection_RecoLanguage, void 0);
      m ? (!l || l.search(a.QueryParameterNames.CustomSpeechDeploymentId) === -1) && (f[a.QueryParameterNames.CustomSpeechDeploymentId] = m) : S && (!l || l.search(a.QueryParameterNames.Language) === -1) && (f[a.QueryParameterNames.Language] = S), u.autoDetectSourceLanguages !== void 0 && (f[a.QueryParameterNames.EnableLanguageId] = "true"), this.setV2UrlParams(u, f, l), l || (l = `${g}${this.universalUri}`);
      const y = {};
      p.token !== void 0 && p.token !== "" && (y[p.headerName] = p.token), y[o.HeaderNames.ConnectionId] = d;
      const P = u.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true", C = new t.WebsocketConnection(l, f, y, new s.WebsocketMessageFormatter(), t.ProxyInfo.fromRecognizerConfig(u), P, d), _ = C.uri;
      return u.parameters.setProperty(e.PropertyId.SpeechServiceConnection_Url, _), C;
    }
    setV2UrlParams(u, p, d) {
      (/* @__PURE__ */ new Map([
        [e.PropertyId.Speech_SegmentationSilenceTimeoutMs, a.QueryParameterNames.SegmentationSilenceTimeoutMs],
        [e.PropertyId.SpeechServiceConnection_EnableAudioLogging, a.QueryParameterNames.EnableAudioLogging],
        [e.PropertyId.SpeechServiceConnection_EndSilenceTimeoutMs, a.QueryParameterNames.EndSilenceTimeoutMs],
        [e.PropertyId.SpeechServiceConnection_InitialSilenceTimeoutMs, a.QueryParameterNames.InitialSilenceTimeoutMs],
        [e.PropertyId.SpeechServiceResponse_PostProcessingOption, a.QueryParameterNames.Postprocessing],
        [e.PropertyId.SpeechServiceResponse_ProfanityOption, a.QueryParameterNames.Profanity],
        [e.PropertyId.SpeechServiceResponse_StablePartialResultThreshold, a.QueryParameterNames.StableIntermediateThreshold]
      ])).forEach((v, g) => {
        this.setUrlParameter(g, v, u, p, d);
      });
      const h = JSON.parse(u.parameters.getProperty(n.ServicePropertiesPropertyName, "{}"));
      Object.keys(h).forEach((v) => {
        p[v] = h[v];
      });
    }
  };
  return Ei.ConversationTranscriberConnectionFactory = i, Ei;
}
var Ti = {}, wl;
function sP() {
  if (wl)
    return Ti;
  wl = 1, Object.defineProperty(Ti, "__esModule", { value: !0 }), Ti.TranscriberConnectionFactory = void 0;
  const t = ye(), e = R(), n = ot(), r = A(), s = Se, o = st;
  let a = class extends n.ConnectionFactoryBase {
    constructor() {
      super(...arguments), this.multiaudioRelativeUri = "/speech/recognition/multiaudio";
    }
    create(c, u, p) {
      let d = c.parameters.getProperty(e.PropertyId.SpeechServiceConnection_Endpoint, void 0);
      const l = c.parameters.getProperty(e.PropertyId.SpeechServiceConnection_Region, "centralus"), h = n.ConnectionFactoryBase.getHostSuffix(l), v = "wss://transcribe." + l + ".cts.speech" + h + this.multiaudioRelativeUri, g = c.parameters.getProperty(e.PropertyId.SpeechServiceConnection_Host, v), f = {};
      this.setQueryParams(f, c, d), d || (d = g);
      const m = {};
      u.token !== void 0 && u.token !== "" && (m[u.headerName] = u.token), m[s.HeaderNames.ConnectionId] = p, c.parameters.setProperty(e.PropertyId.SpeechServiceConnection_Url, d);
      const S = c.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
      return new t.WebsocketConnection(d, f, m, new r.WebsocketMessageFormatter(), t.ProxyInfo.fromRecognizerConfig(c), S, p);
    }
    setQueryParams(c, u, p) {
      const d = u.parameters.getProperty(e.PropertyId.SpeechServiceConnection_EndpointId, void 0), l = u.parameters.getProperty(e.PropertyId.SpeechServiceConnection_RecoLanguage, void 0);
      d && !(o.QueryParameterNames.CustomSpeechDeploymentId in c) && (c[o.QueryParameterNames.CustomSpeechDeploymentId] = d), l && !(o.QueryParameterNames.Language in c) && (c[o.QueryParameterNames.Language] = l);
      const h = u.parameters.getProperty(e.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, "false").toLowerCase() === "true", v = u.parameters.getProperty(r.OutputFormatPropertyName, e.OutputFormat[e.OutputFormat.Simple]) !== e.OutputFormat[e.OutputFormat.Simple];
      (h || v) && (c[o.QueryParameterNames.Format] = e.OutputFormat[e.OutputFormat.Detailed].toLowerCase()), this.setCommonUrlParams(u, c, p);
    }
  };
  return Ti.TranscriberConnectionFactory = a, Ti;
}
var Ii = {}, bl;
function oP() {
  if (bl)
    return Ii;
  bl = 1, Object.defineProperty(Ii, "__esModule", { value: !0 }), Ii.TranslationConnectionFactory = void 0;
  const t = ye(), e = Rs, n = R(), r = ot(), s = A(), o = Se, a = st;
  let i = class extends r.ConnectionFactoryBase {
    create(u, p, d) {
      const l = this.getEndpointUrl(u), h = {};
      u.autoDetectSourceLanguages !== void 0 && (h[a.QueryParameterNames.EnableLanguageId] = "true"), this.setQueryParams(h, u, l);
      const v = {};
      p.token !== void 0 && p.token !== "" && (v[p.headerName] = p.token), v[o.HeaderNames.ConnectionId] = d, u.parameters.setProperty(n.PropertyId.SpeechServiceConnection_Url, l);
      const g = u.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
      return new t.WebsocketConnection(l, h, v, new s.WebsocketMessageFormatter(), t.ProxyInfo.fromRecognizerConfig(u), g, d);
    }
    getEndpointUrl(u, p) {
      const d = u.parameters.getProperty(n.PropertyId.SpeechServiceConnection_Region), l = r.ConnectionFactoryBase.getHostSuffix(d);
      let h = u.parameters.getProperty(n.PropertyId.SpeechServiceConnection_Endpoint, void 0);
      return h || (u.autoDetectSourceLanguages !== void 0 ? h = u.parameters.getProperty(n.PropertyId.SpeechServiceConnection_Host, "wss://{region}.stt.speech" + l) + "/speech/universal/v2" : h = u.parameters.getProperty(n.PropertyId.SpeechServiceConnection_Host, "wss://{region}.s2s.speech" + l) + "/speech/translation/cognitiveservices/v1"), p === !0 ? h : e.StringUtils.formatString(h, { region: d });
    }
    setQueryParams(u, p, d) {
      u.from = p.parameters.getProperty(n.PropertyId.SpeechServiceConnection_RecoLanguage), u.to = p.parameters.getProperty(n.PropertyId.SpeechServiceConnection_TranslationToLanguages), u.scenario = p.recognitionMode === s.RecognitionMode.Interactive ? "interactive" : p.recognitionMode === s.RecognitionMode.Conversation ? "conversation" : "", this.setCommonUrlParams(p, u, d), this.setUrlParameter(n.PropertyId.SpeechServiceResponse_TranslationRequestStablePartialResult, a.QueryParameterNames.StableTranslation, p, u, d);
      const l = p.parameters.getProperty(n.PropertyId.SpeechServiceConnection_TranslationVoice, void 0);
      l !== void 0 && (u.voice = l, u.features = "texttospeech");
    }
  };
  return Ii.TranslationConnectionFactory = i, Ii;
}
var wi = {}, Al;
function aP() {
  if (Al)
    return wi;
  Al = 1, Object.defineProperty(wi, "__esModule", { value: !0 }), wi.EnumTranslation = void 0;
  const t = R(), e = A();
  let n = class {
    static implTranslateRecognitionResult(s, o = !1) {
      let a = t.ResultReason.Canceled;
      switch (s) {
        case e.RecognitionStatus.Success:
          a = t.ResultReason.RecognizedSpeech;
          break;
        case e.RecognitionStatus.EndOfDictation:
          a = o ? t.ResultReason.RecognizedSpeech : t.ResultReason.NoMatch;
          break;
        case e.RecognitionStatus.NoMatch:
        case e.RecognitionStatus.InitialSilenceTimeout:
        case e.RecognitionStatus.BabbleTimeout:
          a = t.ResultReason.NoMatch;
          break;
        case e.RecognitionStatus.Error:
        case e.RecognitionStatus.BadRequest:
        case e.RecognitionStatus.Forbidden:
        default:
          a = t.ResultReason.Canceled;
          break;
      }
      return a;
    }
    static implTranslateCancelResult(s) {
      let o = t.CancellationReason.EndOfStream;
      switch (s) {
        case e.RecognitionStatus.Success:
        case e.RecognitionStatus.EndOfDictation:
        case e.RecognitionStatus.NoMatch:
          o = t.CancellationReason.EndOfStream;
          break;
        case e.RecognitionStatus.InitialSilenceTimeout:
        case e.RecognitionStatus.BabbleTimeout:
        case e.RecognitionStatus.Error:
        case e.RecognitionStatus.BadRequest:
        case e.RecognitionStatus.Forbidden:
        default:
          o = t.CancellationReason.Error;
          break;
      }
      return o;
    }
    static implTranslateCancelErrorCode(s) {
      let o = t.CancellationErrorCode.NoError;
      switch (s) {
        case e.RecognitionStatus.Error:
          o = t.CancellationErrorCode.ServiceError;
          break;
        case e.RecognitionStatus.TooManyRequests:
          o = t.CancellationErrorCode.TooManyRequests;
          break;
        case e.RecognitionStatus.BadRequest:
          o = t.CancellationErrorCode.BadRequestParameters;
          break;
        case e.RecognitionStatus.Forbidden:
          o = t.CancellationErrorCode.Forbidden;
          break;
        default:
          o = t.CancellationErrorCode.NoError;
          break;
      }
      return o;
    }
    static implTranslateErrorDetails(s) {
      let o = "The speech service encountered an internal error and could not continue.";
      switch (s) {
        case t.CancellationErrorCode.Forbidden:
          o = "The recognizer is using a free subscription that ran out of quota.";
          break;
        case t.CancellationErrorCode.BadRequestParameters:
          o = "Invalid parameter or unsupported audio format in the request.";
          break;
        case t.CancellationErrorCode.TooManyRequests:
          o = "The number of parallel requests exceeded the number of allowed concurrent transcriptions.";
          break;
      }
      return o;
    }
  };
  return wi.EnumTranslation = n, wi;
}
var cg = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.RecognitionStatus = t.SynthesisStatus = void 0, function(e) {
    e[e.Success = 0] = "Success", e[e.SynthesisEnd = 1] = "SynthesisEnd", e[e.Error = 2] = "Error";
  }(t.SynthesisStatus || (t.SynthesisStatus = {})), function(e) {
    e[e.Success = 0] = "Success", e[e.NoMatch = 1] = "NoMatch", e[e.InitialSilenceTimeout = 2] = "InitialSilenceTimeout", e[e.BabbleTimeout = 3] = "BabbleTimeout", e[e.Error = 4] = "Error", e[e.EndOfDictation = 5] = "EndOfDictation", e[e.TooManyRequests = 6] = "TooManyRequests", e[e.BadRequest = 7] = "BadRequest", e[e.Forbidden = 8] = "Forbidden";
  }(t.RecognitionStatus || (t.RecognitionStatus = {}));
})(cg);
var bi = {}, Ml;
function cP() {
  if (Ml)
    return bi;
  Ml = 1, Object.defineProperty(bi, "__esModule", { value: !0 }), bi.TranslationSynthesisEnd = void 0;
  const t = A();
  let e = class ug {
    constructor(r) {
      this.privSynthesisEnd = JSON.parse(r), this.privSynthesisEnd.SynthesisStatus && (this.privSynthesisEnd.SynthesisStatus = t.SynthesisStatus[this.privSynthesisEnd.SynthesisStatus]), this.privSynthesisEnd.Status && (this.privSynthesisEnd.SynthesisStatus = t.SynthesisStatus[this.privSynthesisEnd.Status]);
    }
    static fromJSON(r) {
      return new ug(r);
    }
    get SynthesisStatus() {
      return this.privSynthesisEnd.SynthesisStatus;
    }
    get FailureReason() {
      return this.privSynthesisEnd.FailureReason;
    }
  };
  return bi.TranslationSynthesisEnd = e, bi;
}
var Ia = {};
Object.defineProperty(Ia, "__esModule", { value: !0 });
Ia.TranslationHypothesis = void 0;
const uP = N, kl = Jo;
class mo {
  constructor(e, n) {
    this.privTranslationHypothesis = e, this.privTranslationHypothesis.Offset += n, this.privTranslationHypothesis.Translation.TranslationStatus = this.mapTranslationStatus(this.privTranslationHypothesis.Translation.TranslationStatus);
  }
  static fromJSON(e, n) {
    return new mo(JSON.parse(e), n);
  }
  static fromTranslationResponse(e, n) {
    uP.Contracts.throwIfNullOrUndefined(e, "translationHypothesis");
    const r = e.SpeechHypothesis;
    return e.SpeechHypothesis = void 0, r.Translation = e, new mo(r, n);
  }
  get Duration() {
    return this.privTranslationHypothesis.Duration;
  }
  get Offset() {
    return this.privTranslationHypothesis.Offset;
  }
  get Text() {
    return this.privTranslationHypothesis.Text;
  }
  get Translation() {
    return this.privTranslationHypothesis.Translation;
  }
  get Language() {
    var e;
    return (e = this.privTranslationHypothesis.PrimaryLanguage) == null ? void 0 : e.Language;
  }
  asJson() {
    const e = { ...this.privTranslationHypothesis };
    return e.Translation !== void 0 ? JSON.stringify({
      ...e,
      TranslationStatus: kl.TranslationStatus[e.Translation.TranslationStatus]
    }) : JSON.stringify(e);
  }
  mapTranslationStatus(e) {
    if (typeof e == "string")
      return kl.TranslationStatus[e];
    if (typeof e == "number")
      return e;
  }
}
Ia.TranslationHypothesis = mo;
var Ai = {}, Ol;
function pP() {
  if (Ol)
    return Ai;
  Ol = 1, Object.defineProperty(Ai, "__esModule", { value: !0 }), Ai.TranslationPhrase = void 0;
  const t = N, e = A(), n = Jo;
  let r = class Qc {
    constructor(o, a) {
      this.privTranslationPhrase = o, this.privTranslationPhrase.Offset += a, this.privTranslationPhrase.RecognitionStatus = this.mapRecognitionStatus(this.privTranslationPhrase.RecognitionStatus), this.privTranslationPhrase.Translation !== void 0 && (this.privTranslationPhrase.Translation.TranslationStatus = this.mapTranslationStatus(this.privTranslationPhrase.Translation.TranslationStatus));
    }
    static fromJSON(o, a) {
      return new Qc(JSON.parse(o), a);
    }
    static fromTranslationResponse(o, a) {
      t.Contracts.throwIfNullOrUndefined(o, "translationResponse");
      const i = o.SpeechPhrase;
      return o.SpeechPhrase = void 0, i.Translation = o, i.Text = i.DisplayText, new Qc(i, a);
    }
    get RecognitionStatus() {
      return this.privTranslationPhrase.RecognitionStatus;
    }
    get Offset() {
      return this.privTranslationPhrase.Offset;
    }
    get Duration() {
      return this.privTranslationPhrase.Duration;
    }
    get Text() {
      return this.privTranslationPhrase.Text;
    }
    get Language() {
      var o;
      return (o = this.privTranslationPhrase.PrimaryLanguage) == null ? void 0 : o.Language;
    }
    get Confidence() {
      var o;
      return (o = this.privTranslationPhrase.PrimaryLanguage) == null ? void 0 : o.Confidence;
    }
    get Translation() {
      return this.privTranslationPhrase.Translation;
    }
    asJson() {
      const o = { ...this.privTranslationPhrase }, a = {
        ...o,
        RecognitionStatus: e.RecognitionStatus[o.RecognitionStatus]
      };
      return o.Translation && (a.Translation = {
        ...o.Translation,
        TranslationStatus: n.TranslationStatus[o.Translation.TranslationStatus]
      }), JSON.stringify(a);
    }
    mapRecognitionStatus(o) {
      if (typeof o == "string")
        return e.RecognitionStatus[o];
      if (typeof o == "number")
        return o;
    }
    mapTranslationStatus(o) {
      if (typeof o == "string")
        return n.TranslationStatus[o];
      if (typeof o == "number")
        return o;
    }
  };
  return Ai.TranslationPhrase = r, Ai;
}
var Mi = {}, Dl;
function dP() {
  if (Dl)
    return Mi;
  Dl = 1, Object.defineProperty(Mi, "__esModule", { value: !0 }), Mi.TranslationServiceRecognizer = void 0;
  const t = k(), e = R(), n = A();
  let r = class extends n.ConversationServiceRecognizer {
    constructor(o, a, i, c, u) {
      super(o, a, i, c, u), this.privTranslationRecognizer = u, this.connectionEvents.attach((p) => {
        p.name === "ConnectionEstablishedEvent" && this.privTranslationRecognizer.onConnection();
      });
    }
    async processTypeSpecificMessages(o) {
      const a = new e.PropertyCollection();
      let i = await this.processSpeechMessages(o);
      if (i)
        return !0;
      const c = async (p) => {
        if (a.setProperty(e.PropertyId.SpeechServiceResponse_JsonResult, p.asJson()), this.privRequestSession.onPhraseRecognized(p.Offset + p.Duration), p.RecognitionStatus === n.RecognitionStatus.Success) {
          const d = this.fireEventForResult(p, a);
          if (this.privTranslationRecognizer.recognized)
            try {
              this.privTranslationRecognizer.recognized(this.privTranslationRecognizer, d);
            } catch {
            }
          if (this.privSuccessCallback) {
            try {
              this.privSuccessCallback(d.result);
            } catch (l) {
              this.privErrorCallback && this.privErrorCallback(l);
            }
            this.privSuccessCallback = void 0, this.privErrorCallback = void 0;
          }
        } else {
          const d = n.EnumTranslation.implTranslateRecognitionResult(p.RecognitionStatus), l = new e.TranslationRecognitionResult(void 0, this.privRequestSession.requestId, d, p.Text, p.Duration, p.Offset, p.Language, p.Confidence, void 0, p.asJson(), a);
          if (d === e.ResultReason.Canceled) {
            const h = n.EnumTranslation.implTranslateCancelResult(p.RecognitionStatus), v = n.EnumTranslation.implTranslateCancelErrorCode(p.RecognitionStatus);
            await this.cancelRecognitionLocal(h, v, n.EnumTranslation.implTranslateErrorDetails(v));
          } else if (p.RecognitionStatus !== n.RecognitionStatus.EndOfDictation) {
            const h = new e.TranslationRecognitionEventArgs(l, l.offset, this.privRequestSession.sessionId);
            if (this.privTranslationRecognizer.recognized)
              try {
                this.privTranslationRecognizer.recognized(this.privTranslationRecognizer, h);
              } catch {
              }
            if (this.privSuccessCallback) {
              try {
                this.privSuccessCallback(l);
              } catch (v) {
                this.privErrorCallback && this.privErrorCallback(v);
              }
              this.privSuccessCallback = void 0, this.privErrorCallback = void 0;
            }
          }
          i = !0;
        }
      }, u = (p) => {
        a.setProperty(e.PropertyId.SpeechServiceResponse_JsonResult, p.asJson());
        const d = this.fireEventForResult(p, a);
        if (this.privRequestSession.onHypothesis(d.offset), this.privTranslationRecognizer.recognizing)
          try {
            this.privTranslationRecognizer.recognizing(this.privTranslationRecognizer, d);
          } catch {
          }
        i = !0;
      };
      switch (o.messageType === t.MessageType.Text && a.setProperty(e.PropertyId.SpeechServiceResponse_JsonResult, o.textBody), o.path.toLowerCase()) {
        case "translation.hypothesis":
          u(n.TranslationHypothesis.fromJSON(o.textBody, this.privRequestSession.currentTurnAudioOffset));
          break;
        case "translation.response":
          const p = JSON.parse(o.textBody);
          if (p.SpeechPhrase)
            await c(n.TranslationPhrase.fromTranslationResponse(p, this.privRequestSession.currentTurnAudioOffset));
          else {
            const l = JSON.parse(o.textBody);
            l.SpeechHypothesis && u(n.TranslationHypothesis.fromTranslationResponse(l, this.privRequestSession.currentTurnAudioOffset));
          }
          break;
        case "translation.phrase":
          await c(n.TranslationPhrase.fromJSON(o.textBody, this.privRequestSession.currentTurnAudioOffset));
          break;
        case "translation.synthesis":
          this.sendSynthesisAudio(o.binaryBody, this.privRequestSession.sessionId), i = !0;
          break;
        case "audio.end":
        case "translation.synthesis.end":
          const d = n.TranslationSynthesisEnd.fromJSON(o.textBody);
          switch (d.SynthesisStatus) {
            case n.SynthesisStatus.Error:
              if (this.privTranslationRecognizer.synthesizing) {
                const l = new e.TranslationSynthesisResult(e.ResultReason.Canceled, void 0), h = new e.TranslationSynthesisEventArgs(l, this.privRequestSession.sessionId);
                try {
                  this.privTranslationRecognizer.synthesizing(this.privTranslationRecognizer, h);
                } catch {
                }
              }
              if (this.privTranslationRecognizer.canceled) {
                const l = new e.TranslationRecognitionCanceledEventArgs(this.privRequestSession.sessionId, e.CancellationReason.Error, d.FailureReason, e.CancellationErrorCode.ServiceError, null);
                try {
                  this.privTranslationRecognizer.canceled(this.privTranslationRecognizer, l);
                } catch {
                }
              }
              break;
            case n.SynthesisStatus.Success:
              this.sendSynthesisAudio(void 0, this.privRequestSession.sessionId);
              break;
          }
          i = !0;
          break;
      }
      return i;
    }
    // Cancels recognition.
    cancelRecognition(o, a, i, c, u) {
      const p = new e.PropertyCollection();
      if (p.setProperty(n.CancellationErrorCodePropertyName, e.CancellationErrorCode[c]), this.privTranslationRecognizer.canceled) {
        const d = new e.TranslationRecognitionCanceledEventArgs(o, i, u, c, void 0);
        try {
          this.privTranslationRecognizer.canceled(this.privTranslationRecognizer, d);
        } catch {
        }
      }
      if (this.privSuccessCallback) {
        const d = new e.TranslationRecognitionResult(
          void 0,
          // Translations
          a,
          e.ResultReason.Canceled,
          void 0,
          // Text
          void 0,
          // Druation
          void 0,
          // Offset
          void 0,
          // Language
          void 0,
          // LanguageDetectionConfidence
          u,
          void 0,
          // Json
          p
        );
        try {
          this.privSuccessCallback(d), this.privSuccessCallback = void 0;
        } catch {
        }
      }
    }
    handleRecognizingCallback(o, a, i) {
      try {
        const c = new e.TranslationRecognitionEventArgs(e.TranslationRecognitionResult.fromSpeechRecognitionResult(o), a, i);
        this.privTranslationRecognizer.recognizing(this.privTranslationRecognizer, c);
      } catch {
      }
    }
    handleRecognizedCallback(o, a, i) {
      try {
        const c = new e.TranslationRecognitionEventArgs(e.TranslationRecognitionResult.fromSpeechRecognitionResult(o), a, i);
        this.privTranslationRecognizer.recognized(this.privTranslationRecognizer, c);
      } catch {
      }
    }
    fireEventForResult(o, a) {
      let i;
      if (o.Translation.Translations !== void 0) {
        i = new e.Translations();
        for (const h of o.Translation.Translations)
          i.set(h.Language, h.Text || h.DisplayText);
      }
      let c, u;
      o instanceof n.TranslationPhrase ? (o.Translation && o.Translation.TranslationStatus === t.TranslationStatus.Success ? c = e.ResultReason.TranslatedSpeech : c = e.ResultReason.RecognizedSpeech, u = o.Confidence) : c = e.ResultReason.TranslatingSpeech;
      const p = o.Language, d = new e.TranslationRecognitionResult(i, this.privRequestSession.requestId, c, o.Text, o.Duration, o.Offset, p, u, o.Translation.FailureReason, o.asJson(), a);
      return new e.TranslationRecognitionEventArgs(d, o.Offset, this.privRequestSession.sessionId);
    }
    sendSynthesisAudio(o, a) {
      const i = o === void 0 ? e.ResultReason.SynthesizingAudioCompleted : e.ResultReason.SynthesizingAudio, c = new e.TranslationSynthesisResult(i, o), u = new e.TranslationSynthesisEventArgs(c, a);
      if (this.privTranslationRecognizer.synthesizing)
        try {
          this.privTranslationRecognizer.synthesizing(this.privTranslationRecognizer, u);
        } catch {
        }
    }
  };
  return Mi.TranslationServiceRecognizer = r, Mi;
}
var wa = {};
Object.defineProperty(wa, "__esModule", { value: !0 });
wa.SpeechDetected = void 0;
class Uu {
  constructor(e, n) {
    this.privSpeechStartDetected = JSON.parse(e), this.privSpeechStartDetected.Offset += n;
  }
  static fromJSON(e, n) {
    return new Uu(e, n);
  }
  get Offset() {
    return this.privSpeechStartDetected.Offset;
  }
}
wa.SpeechDetected = Uu;
var ba = {};
Object.defineProperty(ba, "__esModule", { value: !0 });
ba.SpeechHypothesis = void 0;
class Hu {
  constructor(e, n) {
    this.privSpeechHypothesis = JSON.parse(e), this.updateOffset(n);
  }
  static fromJSON(e, n) {
    return new Hu(e, n);
  }
  updateOffset(e) {
    this.privSpeechHypothesis.Offset += e;
  }
  asJson() {
    return JSON.stringify(this.privSpeechHypothesis);
  }
  get Text() {
    return this.privSpeechHypothesis.Text;
  }
  get Offset() {
    return this.privSpeechHypothesis.Offset;
  }
  get Duration() {
    return this.privSpeechHypothesis.Duration;
  }
  get Language() {
    return this.privSpeechHypothesis.PrimaryLanguage === void 0 ? void 0 : this.privSpeechHypothesis.PrimaryLanguage.Language;
  }
  get LanguageDetectionConfidence() {
    return this.privSpeechHypothesis.PrimaryLanguage === void 0 ? void 0 : this.privSpeechHypothesis.PrimaryLanguage.Confidence;
  }
  get SpeakerId() {
    return this.privSpeechHypothesis.SpeakerId;
  }
}
ba.SpeechHypothesis = Hu;
var Aa = {};
Object.defineProperty(Aa, "__esModule", { value: !0 });
Aa.SpeechKeyword = void 0;
class Wu {
  constructor(e, n) {
    this.privSpeechKeyword = JSON.parse(e), this.privSpeechKeyword.Offset += n;
  }
  static fromJSON(e, n) {
    return new Wu(e, n);
  }
  get Status() {
    return this.privSpeechKeyword.Status;
  }
  get Text() {
    return this.privSpeechKeyword.Text;
  }
  get Offset() {
    return this.privSpeechKeyword.Offset;
  }
  get Duration() {
    return this.privSpeechKeyword.Duration;
  }
  asJson() {
    return JSON.stringify(this.privSpeechKeyword);
  }
}
Aa.SpeechKeyword = Wu;
var ki = {}, Nl;
function lP() {
  if (Nl)
    return ki;
  Nl = 1, Object.defineProperty(ki, "__esModule", { value: !0 }), ki.SpeechServiceRecognizer = void 0;
  const t = R(), e = A();
  let n = class extends e.ServiceRecognizerBase {
    constructor(s, o, a, i, c) {
      super(s, o, a, i, c), this.privSpeechRecognizer = c;
    }
    async processTypeSpecificMessages(s) {
      let o;
      const a = new t.PropertyCollection();
      let i = !1;
      switch (s.path.toLowerCase()) {
        case "speech.hypothesis":
        case "speech.fragment":
          const c = e.SpeechHypothesis.fromJSON(s.textBody, this.privRequestSession.currentTurnAudioOffset);
          a.setProperty(t.PropertyId.SpeechServiceResponse_JsonResult, c.asJson()), o = new t.SpeechRecognitionResult(
            this.privRequestSession.requestId,
            t.ResultReason.RecognizingSpeech,
            c.Text,
            c.Duration,
            c.Offset,
            c.Language,
            c.LanguageDetectionConfidence,
            void 0,
            // Speaker Id
            void 0,
            c.asJson(),
            a
          ), this.privRequestSession.onHypothesis(c.Offset);
          const u = new t.SpeechRecognitionEventArgs(o, c.Offset, this.privRequestSession.sessionId);
          if (this.privSpeechRecognizer.recognizing)
            try {
              this.privSpeechRecognizer.recognizing(this.privSpeechRecognizer, u);
            } catch {
            }
          i = !0;
          break;
        case "speech.phrase":
          const p = e.SimpleSpeechPhrase.fromJSON(s.textBody, this.privRequestSession.currentTurnAudioOffset);
          a.setProperty(t.PropertyId.SpeechServiceResponse_JsonResult, p.asJson());
          const d = e.EnumTranslation.implTranslateRecognitionResult(p.RecognitionStatus, this.privExpectContentAssessmentResponse);
          if (this.privRequestSession.onPhraseRecognized(p.Offset + p.Duration), t.ResultReason.Canceled === d) {
            const l = e.EnumTranslation.implTranslateCancelResult(p.RecognitionStatus), h = e.EnumTranslation.implTranslateCancelErrorCode(p.RecognitionStatus);
            await this.cancelRecognitionLocal(l, h, e.EnumTranslation.implTranslateErrorDetails(h));
          } else {
            if (p.RecognitionStatus === e.RecognitionStatus.EndOfDictation)
              break;
            if (this.privRecognizerConfig.parameters.getProperty(e.OutputFormatPropertyName) === t.OutputFormat[t.OutputFormat.Simple])
              o = new t.SpeechRecognitionResult(
                this.privRequestSession.requestId,
                d,
                p.DisplayText,
                p.Duration,
                p.Offset,
                p.Language,
                p.LanguageDetectionConfidence,
                void 0,
                // Speaker Id
                void 0,
                p.asJson(),
                a
              );
            else {
              const h = e.DetailedSpeechPhrase.fromJSON(s.textBody, this.privRequestSession.currentTurnAudioOffset);
              a.setProperty(t.PropertyId.SpeechServiceResponse_JsonResult, h.asJson()), o = new t.SpeechRecognitionResult(
                this.privRequestSession.requestId,
                d,
                h.RecognitionStatus === e.RecognitionStatus.Success ? h.NBest[0].Display : "",
                h.Duration,
                h.Offset,
                h.Language,
                h.LanguageDetectionConfidence,
                void 0,
                // Speaker Id
                void 0,
                h.asJson(),
                a
              );
            }
            const l = new t.SpeechRecognitionEventArgs(o, o.offset, this.privRequestSession.sessionId);
            if (this.privSpeechRecognizer.recognized)
              try {
                this.privSpeechRecognizer.recognized(this.privSpeechRecognizer, l);
              } catch {
              }
            if (this.privSuccessCallback) {
              try {
                this.privSuccessCallback(o);
              } catch (h) {
                this.privErrorCallback && this.privErrorCallback(h);
              }
              this.privSuccessCallback = void 0, this.privErrorCallback = void 0;
            }
          }
          i = !0;
          break;
      }
      return i;
    }
    // Cancels recognition.
    cancelRecognition(s, o, a, i, c) {
      const u = new t.PropertyCollection();
      if (u.setProperty(e.CancellationErrorCodePropertyName, t.CancellationErrorCode[i]), this.privSpeechRecognizer.canceled) {
        const p = new t.SpeechRecognitionCanceledEventArgs(a, c, i, void 0, s);
        try {
          this.privSpeechRecognizer.canceled(this.privSpeechRecognizer, p);
        } catch {
        }
      }
      if (this.privSuccessCallback) {
        const p = new t.SpeechRecognitionResult(
          o,
          t.ResultReason.Canceled,
          void 0,
          // Text
          void 0,
          // Duration
          void 0,
          // Offset
          void 0,
          // Language
          void 0,
          // Language Detection Confidence
          void 0,
          // Speaker Id
          c,
          void 0,
          // Json
          u
        );
        try {
          this.privSuccessCallback(p), this.privSuccessCallback = void 0;
        } catch {
        }
      }
    }
  };
  return ki.SpeechServiceRecognizer = n, ki;
}
var Oi = {}, Ll;
function hP() {
  if (Ll)
    return Oi;
  Ll = 1, Object.defineProperty(Oi, "__esModule", { value: !0 }), Oi.ConversationTranscriptionServiceRecognizer = void 0;
  const t = R(), e = A();
  let n = class extends e.ServiceRecognizerBase {
    constructor(s, o, a, i, c) {
      super(s, o, a, i, c), this.privConversationTranscriber = c, this.setSpeakerDiarizationJson();
    }
    setSpeakerDiarizationJson() {
      if (this.privEnableSpeakerId) {
        const s = this.privSpeechContext.getSection("phraseDetection");
        s.mode = "Conversation";
        const o = {};
        o.mode = "Anonymous", o.audioSessionId = this.privDiarizationSessionId, o.audioOffsetMs = 0, o.diarizeIntermediates = this.privRecognizerConfig.parameters.getProperty(t.PropertyId.SpeechServiceResponse_DiarizeIntermediateResults, "false") === "true", s.speakerDiarization = o, this.privSpeechContext.setSection("phraseDetection", s);
      }
    }
    async processTypeSpecificMessages(s) {
      let o;
      const a = new t.PropertyCollection();
      a.setProperty(t.PropertyId.SpeechServiceResponse_JsonResult, s.textBody);
      let i = !1;
      switch (s.path.toLowerCase()) {
        case "speech.hypothesis":
        case "speech.fragment":
          const c = e.SpeechHypothesis.fromJSON(s.textBody, this.privRequestSession.currentTurnAudioOffset);
          o = new t.ConversationTranscriptionResult(this.privRequestSession.requestId, t.ResultReason.RecognizingSpeech, c.Text, c.Duration, c.Offset, c.Language, c.LanguageDetectionConfidence, c.SpeakerId, void 0, c.asJson(), a), this.privRequestSession.onHypothesis(c.Offset);
          const u = new t.ConversationTranscriptionEventArgs(o, c.Duration, this.privRequestSession.sessionId);
          if (this.privConversationTranscriber.transcribing)
            try {
              this.privConversationTranscriber.transcribing(this.privConversationTranscriber, u);
            } catch {
            }
          i = !0;
          break;
        case "speech.phrase":
          const p = e.SimpleSpeechPhrase.fromJSON(s.textBody, this.privRequestSession.currentTurnAudioOffset), d = e.EnumTranslation.implTranslateRecognitionResult(p.RecognitionStatus);
          if (this.privRequestSession.onPhraseRecognized(p.Offset + p.Duration), t.ResultReason.Canceled === d) {
            const l = e.EnumTranslation.implTranslateCancelResult(p.RecognitionStatus), h = e.EnumTranslation.implTranslateCancelErrorCode(p.RecognitionStatus);
            await this.cancelRecognitionLocal(l, h, e.EnumTranslation.implTranslateErrorDetails(h));
          } else if (!(this.privRequestSession.isSpeechEnded && d === t.ResultReason.NoMatch && p.RecognitionStatus !== e.RecognitionStatus.InitialSilenceTimeout)) {
            if (this.privRecognizerConfig.parameters.getProperty(e.OutputFormatPropertyName) === t.OutputFormat[t.OutputFormat.Simple])
              o = new t.ConversationTranscriptionResult(this.privRequestSession.requestId, d, p.DisplayText, p.Duration, p.Offset, p.Language, p.LanguageDetectionConfidence, p.SpeakerId, void 0, p.asJson(), a);
            else {
              const h = e.DetailedSpeechPhrase.fromJSON(s.textBody, this.privRequestSession.currentTurnAudioOffset);
              o = new t.ConversationTranscriptionResult(this.privRequestSession.requestId, d, h.RecognitionStatus === e.RecognitionStatus.Success ? h.NBest[0].Display : void 0, h.Duration, h.Offset, h.Language, h.LanguageDetectionConfidence, p.SpeakerId, void 0, h.asJson(), a);
            }
            const l = new t.ConversationTranscriptionEventArgs(o, o.offset, this.privRequestSession.sessionId);
            if (this.privConversationTranscriber.transcribed)
              try {
                this.privConversationTranscriber.transcribed(this.privConversationTranscriber, l);
              } catch {
              }
          }
          i = !0;
          break;
      }
      return i;
    }
    // Cancels recognition.
    cancelRecognition(s, o, a, i, c) {
      if (new t.PropertyCollection().setProperty(e.CancellationErrorCodePropertyName, t.CancellationErrorCode[i]), this.privConversationTranscriber.canceled) {
        const p = new t.ConversationTranscriptionCanceledEventArgs(a, c, i, void 0, s);
        try {
          this.privConversationTranscriber.canceled(this.privConversationTranscriber, p);
        } catch {
        }
      }
    }
  };
  return Oi.ConversationTranscriptionServiceRecognizer = n, Oi;
}
var Di = {}, zl;
function vP() {
  if (zl)
    return Di;
  zl = 1, Object.defineProperty(Di, "__esModule", { value: !0 }), Di.TranscriptionServiceRecognizer = void 0;
  const t = k(), e = R(), n = A(), r = It;
  let s = class extends n.ConversationServiceRecognizer {
    constructor(a, i, c, u, p) {
      super(a, i, c, u, p), this.privTranscriberRecognizer = p, this.sendPrePayloadJSONOverride = (d) => this.sendTranscriptionStartJSON(d), this.privRecognizerConfig.parameters.getProperty(e.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps) === "true" && this.privSpeechContext.setWordLevelTimings();
    }
    async sendSpeechEventAsync(a, i) {
      if (this.privRequestSession.isRecognizing) {
        const c = await this.fetchConnection();
        await this.sendSpeechEvent(c, this.createSpeechEventPayload(a, i));
      }
    }
    async sendMeetingSpeechEventAsync(a, i) {
      if (this.privRequestSession.isRecognizing) {
        const c = await this.fetchConnection();
        await this.sendSpeechEvent(c, this.createMeetingSpeechEventPayload(a, i));
      }
    }
    processTypeSpecificMessages(a) {
      return this.processSpeechMessages(a);
    }
    handleRecognizedCallback(a, i, c) {
      try {
        const u = new e.SpeechRecognitionEventArgs(a, i, c);
        if (this.privTranscriberRecognizer.recognized(this.privTranscriberRecognizer, u), this.privSuccessCallback) {
          try {
            this.privSuccessCallback(a);
          } catch (p) {
            this.privErrorCallback && this.privErrorCallback(p);
          }
          this.privSuccessCallback = void 0, this.privErrorCallback = void 0;
        }
      } catch {
      }
    }
    handleRecognizingCallback(a, i, c) {
      try {
        const u = new e.SpeechRecognitionEventArgs(a, i, c);
        this.privTranscriberRecognizer.recognizing(this.privTranscriberRecognizer, u);
      } catch {
      }
    }
    // Cancels recognition.
    cancelRecognition(a, i, c, u, p) {
      const d = new e.PropertyCollection();
      if (d.setProperty(n.CancellationErrorCodePropertyName, e.CancellationErrorCode[u]), this.privTranscriberRecognizer.IsMeetingRecognizer()) {
        if (this.privTranscriberRecognizer.canceled) {
          const l = new e.MeetingTranscriptionCanceledEventArgs(c, p, u, void 0, a);
          try {
            this.privTranscriberRecognizer.canceled(this.privTranscriberRecognizer, l);
          } catch {
          }
        }
      } else if (this.privTranscriberRecognizer.canceled) {
        const l = new e.ConversationTranscriptionCanceledEventArgs(c, p, u, void 0, a);
        try {
          this.privTranscriberRecognizer.canceled(this.privTranscriberRecognizer, l);
        } catch {
        }
      }
      if (this.privSuccessCallback) {
        const l = new e.SpeechRecognitionResult(
          i,
          e.ResultReason.Canceled,
          void 0,
          // Text
          void 0,
          // Duration
          void 0,
          // Offset
          void 0,
          // Language
          void 0,
          // Language Detection Confidence
          void 0,
          // Speaker Id
          p,
          void 0,
          // Json
          d
        );
        try {
          this.privSuccessCallback(l), this.privSuccessCallback = void 0;
        } catch {
        }
      }
    }
    // Encapsulated for derived service recognizers that need to send additional JSON
    async sendTranscriptionStartJSON(a) {
      if (await this.sendSpeechContext(a, !0), this.privTranscriberRecognizer.IsMeetingRecognizer()) {
        const i = this.privTranscriberRecognizer.getMeetingInfo(), c = this.createMeetingSpeechEventPayload(i, "start");
        await this.sendSpeechEvent(a, c);
      } else {
        const i = this.privTranscriberRecognizer.getConversationInfo(), c = this.createSpeechEventPayload(i, "start");
        await this.sendSpeechEvent(a, c);
      }
      await this.sendWaveHeader(a);
    }
    sendSpeechEvent(a, i) {
      const c = JSON.stringify(i);
      if (c)
        return a.send(new r.SpeechConnectionMessage(t.MessageType.Text, "speech.event", this.privRequestSession.requestId, "application/json", c));
    }
    createSpeechEventPayload(a, i) {
      const c = { id: "meeting", name: i, meeting: a.conversationProperties };
      return c.meeting.id = a.id, c.meeting.attendees = a.participants, c;
    }
    createMeetingSpeechEventPayload(a, i) {
      const c = { id: "meeting", name: i, meeting: a.meetingProperties };
      return c.meeting.id = a.id, c.meeting.attendees = a.participants, c;
    }
  };
  return Di.TranscriptionServiceRecognizer = s, Di;
}
var Ni = {}, jl;
function fP() {
  if (jl)
    return Ni;
  jl = 1, Object.defineProperty(Ni, "__esModule", { value: !0 }), Ni.DetailedSpeechPhrase = void 0;
  const t = A();
  let e = class pg {
    constructor(r, s) {
      this.privDetailedSpeechPhrase = JSON.parse(r), this.privDetailedSpeechPhrase.RecognitionStatus = this.mapRecognitionStatus(this.privDetailedSpeechPhrase.RecognitionStatus), this.updateOffsets(s);
    }
    static fromJSON(r, s) {
      return new pg(r, s);
    }
    updateOffsets(r) {
      if (this.privDetailedSpeechPhrase.Offset += r, this.privDetailedSpeechPhrase.NBest)
        for (const s of this.privDetailedSpeechPhrase.NBest) {
          if (s.Words)
            for (const o of s.Words)
              o.Offset += r;
          if (s.DisplayWords)
            for (const o of s.DisplayWords)
              o.Offset += r;
        }
    }
    asJson() {
      const r = { ...this.privDetailedSpeechPhrase };
      return JSON.stringify({
        ...r,
        RecognitionStatus: t.RecognitionStatus[r.RecognitionStatus]
      });
    }
    get RecognitionStatus() {
      return this.privDetailedSpeechPhrase.RecognitionStatus;
    }
    get NBest() {
      return this.privDetailedSpeechPhrase.NBest;
    }
    get Duration() {
      return this.privDetailedSpeechPhrase.Duration;
    }
    get Offset() {
      return this.privDetailedSpeechPhrase.Offset;
    }
    get Language() {
      return this.privDetailedSpeechPhrase.PrimaryLanguage === void 0 ? void 0 : this.privDetailedSpeechPhrase.PrimaryLanguage.Language;
    }
    get LanguageDetectionConfidence() {
      return this.privDetailedSpeechPhrase.PrimaryLanguage === void 0 ? void 0 : this.privDetailedSpeechPhrase.PrimaryLanguage.Confidence;
    }
    get Text() {
      return this.privDetailedSpeechPhrase.NBest && this.privDetailedSpeechPhrase.NBest[0] ? this.privDetailedSpeechPhrase.NBest[0].Display || this.privDetailedSpeechPhrase.NBest[0].DisplayText : this.privDetailedSpeechPhrase.DisplayText;
    }
    get SpeakerId() {
      return this.privDetailedSpeechPhrase.SpeakerId;
    }
    mapRecognitionStatus(r) {
      if (typeof r == "string")
        return t.RecognitionStatus[r];
      if (typeof r == "number")
        return r;
    }
  };
  return Ni.DetailedSpeechPhrase = e, Ni;
}
var Li = {}, xl;
function gP() {
  if (xl)
    return Li;
  xl = 1, Object.defineProperty(Li, "__esModule", { value: !0 }), Li.SimpleSpeechPhrase = void 0;
  const t = A();
  let e = class dg {
    constructor(r, s = 0) {
      this.privSimpleSpeechPhrase = JSON.parse(r), this.privSimpleSpeechPhrase.RecognitionStatus = this.mapRecognitionStatus(this.privSimpleSpeechPhrase.RecognitionStatus), this.updateOffset(s);
    }
    static fromJSON(r, s) {
      return new dg(r, s);
    }
    updateOffset(r) {
      this.privSimpleSpeechPhrase.Offset += r;
    }
    asJson() {
      const r = { ...this.privSimpleSpeechPhrase };
      return JSON.stringify({
        ...r,
        RecognitionStatus: t.RecognitionStatus[r.RecognitionStatus]
      });
    }
    get RecognitionStatus() {
      return this.privSimpleSpeechPhrase.RecognitionStatus;
    }
    get DisplayText() {
      return this.privSimpleSpeechPhrase.DisplayText;
    }
    get Offset() {
      return this.privSimpleSpeechPhrase.Offset;
    }
    get Duration() {
      return this.privSimpleSpeechPhrase.Duration;
    }
    get Language() {
      return this.privSimpleSpeechPhrase.PrimaryLanguage === void 0 ? void 0 : this.privSimpleSpeechPhrase.PrimaryLanguage.Language;
    }
    get LanguageDetectionConfidence() {
      return this.privSimpleSpeechPhrase.PrimaryLanguage === void 0 ? void 0 : this.privSimpleSpeechPhrase.PrimaryLanguage.Confidence;
    }
    get SpeakerId() {
      return this.privSimpleSpeechPhrase.SpeakerId;
    }
    mapRecognitionStatus(r) {
      if (typeof r == "string")
        return t.RecognitionStatus[r];
      if (typeof r == "number")
        return r;
    }
  };
  return Li.SimpleSpeechPhrase = e, Li;
}
var Ma = {};
Object.defineProperty(Ma, "__esModule", { value: !0 });
Ma.AddedLmIntent = void 0;
class mP {
  /**
   * Creates and initializes an instance of this class.
   * @constructor
   * @param modelImpl - The model.
   * @param intentName - The intent name.
   */
  constructor(e, n) {
    this.modelImpl = e, this.intentName = n;
  }
}
Ma.AddedLmIntent = mP;
var zi = {}, Bl;
function SP() {
  if (Bl)
    return zi;
  Bl = 1, Object.defineProperty(zi, "__esModule", { value: !0 }), zi.IntentServiceRecognizer = void 0;
  const t = k(), e = R(), n = A();
  let r = class extends n.ServiceRecognizerBase {
    constructor(o, a, i, c, u) {
      super(o, a, i, c, u), this.privIntentRecognizer = u, this.privIntentDataSent = !1;
    }
    setIntents(o, a) {
      this.privAddedLmIntents = o, this.privUmbrellaIntent = a, this.privIntentDataSent = !0;
    }
    processTypeSpecificMessages(o) {
      let a, i, c = !1;
      const u = new e.PropertyCollection();
      switch (o.messageType === t.MessageType.Text && u.setProperty(e.PropertyId.SpeechServiceResponse_JsonResult, o.textBody), o.path.toLowerCase()) {
        case "speech.hypothesis":
          const d = n.SpeechHypothesis.fromJSON(o.textBody, this.privRequestSession.currentTurnAudioOffset);
          if (a = new e.IntentRecognitionResult(void 0, this.privRequestSession.requestId, e.ResultReason.RecognizingIntent, d.Text, d.Duration, d.Offset, d.Language, d.LanguageDetectionConfidence, void 0, d.asJson(), u), this.privRequestSession.onHypothesis(a.offset), i = new e.IntentRecognitionEventArgs(a, d.Offset, this.privRequestSession.sessionId), this.privIntentRecognizer.recognizing)
            try {
              this.privIntentRecognizer.recognizing(this.privIntentRecognizer, i);
            } catch {
            }
          c = !0;
          break;
        case "speech.phrase":
          const l = n.SimpleSpeechPhrase.fromJSON(o.textBody, this.privRequestSession.currentTurnAudioOffset);
          a = new e.IntentRecognitionResult(void 0, this.privRequestSession.requestId, n.EnumTranslation.implTranslateRecognitionResult(l.RecognitionStatus), l.DisplayText, l.Duration, l.Offset, l.Language, l.LanguageDetectionConfidence, void 0, l.asJson(), u), i = new e.IntentRecognitionEventArgs(a, a.offset, this.privRequestSession.sessionId);
          const h = () => {
            if (this.privIntentRecognizer.recognized)
              try {
                this.privIntentRecognizer.recognized(this.privIntentRecognizer, i);
              } catch {
              }
            if (this.privSuccessCallback) {
              try {
                this.privSuccessCallback(a);
              } catch (g) {
                this.privErrorCallback && this.privErrorCallback(g);
              }
              this.privSuccessCallback = void 0, this.privErrorCallback = void 0;
            }
          };
          this.privIntentDataSent === !1 || e.ResultReason.NoMatch === i.result.reason ? (this.privRequestSession.onPhraseRecognized(i.offset + i.result.duration), h()) : this.privPendingIntentArgs = i, c = !0;
          break;
        case "response":
          if (i = this.privPendingIntentArgs, this.privPendingIntentArgs = void 0, i === void 0) {
            if (o.textBody === "")
              return;
            i = new e.IntentRecognitionEventArgs(new e.IntentRecognitionResult(), 0, this.privRequestSession.sessionId);
          }
          const v = n.IntentResponse.fromJSON(o.textBody);
          if (v !== null && v.topScoringIntent && v.topScoringIntent.intent) {
            let g = this.privAddedLmIntents[v.topScoringIntent.intent];
            if (this.privUmbrellaIntent !== void 0 && (g = this.privUmbrellaIntent), g) {
              const f = g === void 0 || g.intentName === void 0 ? v.topScoringIntent.intent : g.intentName;
              let m = i.result.reason;
              f !== void 0 && (m = e.ResultReason.RecognizedIntent);
              const S = i.result.properties !== void 0 ? i.result.properties : new e.PropertyCollection();
              S.setProperty(e.PropertyId.LanguageUnderstandingServiceResponse_JsonResult, o.textBody), i = new e.IntentRecognitionEventArgs(new e.IntentRecognitionResult(f, i.result.resultId, m, i.result.text, i.result.duration, i.result.offset, void 0, void 0, i.result.errorDetails, i.result.json, S), i.offset, i.sessionId);
            }
          }
          if (this.privRequestSession.onPhraseRecognized(i.offset + i.result.duration), this.privIntentRecognizer.recognized)
            try {
              this.privIntentRecognizer.recognized(this.privIntentRecognizer, i);
            } catch {
            }
          if (this.privSuccessCallback) {
            try {
              this.privSuccessCallback(i.result);
            } catch (g) {
              this.privErrorCallback && this.privErrorCallback(g);
            }
            this.privSuccessCallback = void 0, this.privErrorCallback = void 0;
          }
          c = !0;
          break;
      }
      const p = new t.Deferred();
      return p.resolve(c), p.promise;
    }
    // Cancels recognition.
    cancelRecognition(o, a, i, c, u) {
      const p = new e.PropertyCollection();
      if (p.setProperty(n.CancellationErrorCodePropertyName, e.CancellationErrorCode[c]), this.privIntentRecognizer.canceled) {
        const d = new e.IntentRecognitionCanceledEventArgs(i, u, c, void 0, void 0, o);
        try {
          this.privIntentRecognizer.canceled(this.privIntentRecognizer, d);
        } catch {
        }
      }
      if (this.privSuccessCallback) {
        const d = new e.IntentRecognitionResult(
          void 0,
          // Intent Id
          a,
          e.ResultReason.Canceled,
          void 0,
          // Text
          void 0,
          // Duration
          void 0,
          // Offset
          void 0,
          // Language
          void 0,
          // LanguageDetectionConfidence
          u,
          void 0,
          // Json
          p
        );
        try {
          this.privSuccessCallback(d), this.privSuccessCallback = void 0;
        } catch {
        }
      }
    }
  };
  return zi.IntentServiceRecognizer = r, zi;
}
var ka = {};
Object.defineProperty(ka, "__esModule", { value: !0 });
ka.IntentResponse = void 0;
class Vu {
  constructor(e) {
    e === "" ? this.privIntentResponse = {} : this.privIntentResponse = JSON.parse(e);
  }
  static fromJSON(e) {
    return new Vu(e);
  }
  get query() {
    return this.privIntentResponse.query;
  }
  get topScoringIntent() {
    return this.privIntentResponse.topScoringIntent;
  }
  get entities() {
    return this.privIntentResponse.entities;
  }
}
ka.IntentResponse = Vu;
var lg = {};
Object.defineProperty(lg, "__esModule", { value: !0 });
var Oa = {}, Da = {};
Object.defineProperty(Da, "__esModule", { value: !0 });
Da.ServiceTelemetryListener = void 0;
const St = k(), ql = Ea;
class yP {
  constructor(e, n, r) {
    this.privIsDisposed = !1, this.privListeningTriggerMetric = null, this.privMicMetric = null, this.privConnectionEstablishMetric = null, this.privRequestId = e, this.privAudioSourceId = n, this.privAudioNodeId = r, this.privReceivedMessages = {}, this.privPhraseLatencies = [], this.privHypothesisLatencies = [];
  }
  phraseReceived(e) {
    e > 0 && this.privPhraseLatencies.push(Date.now() - e);
  }
  hypothesisReceived(e) {
    e > 0 && this.privHypothesisLatencies.push(Date.now() - e);
  }
  onEvent(e) {
    this.privIsDisposed || (e instanceof ql.RecognitionTriggeredEvent && e.requestId === this.privRequestId && (this.privListeningTriggerMetric = {
      End: e.eventTime,
      Name: "ListeningTrigger",
      Start: e.eventTime
    }), e instanceof St.AudioStreamNodeAttachingEvent && e.audioSourceId === this.privAudioSourceId && e.audioNodeId === this.privAudioNodeId && (this.privMicStartTime = e.eventTime), e instanceof St.AudioStreamNodeAttachedEvent && e.audioSourceId === this.privAudioSourceId && e.audioNodeId === this.privAudioNodeId && (this.privMicStartTime = e.eventTime), e instanceof St.AudioSourceErrorEvent && e.audioSourceId === this.privAudioSourceId && (this.privMicMetric || (this.privMicMetric = {
      End: e.eventTime,
      Error: e.error,
      Name: "Microphone",
      Start: this.privMicStartTime
    })), e instanceof St.AudioStreamNodeErrorEvent && e.audioSourceId === this.privAudioSourceId && e.audioNodeId === this.privAudioNodeId && (this.privMicMetric || (this.privMicMetric = {
      End: e.eventTime,
      Error: e.error,
      Name: "Microphone",
      Start: this.privMicStartTime
    })), e instanceof St.AudioStreamNodeDetachedEvent && e.audioSourceId === this.privAudioSourceId && e.audioNodeId === this.privAudioNodeId && (this.privMicMetric || (this.privMicMetric = {
      End: e.eventTime,
      Name: "Microphone",
      Start: this.privMicStartTime
    })), e instanceof ql.ConnectingToServiceEvent && e.requestId === this.privRequestId && (this.privConnectionId = e.sessionId), e instanceof St.ConnectionStartEvent && e.connectionId === this.privConnectionId && (this.privConnectionStartTime = e.eventTime), e instanceof St.ConnectionEstablishedEvent && e.connectionId === this.privConnectionId && (this.privConnectionEstablishMetric || (this.privConnectionEstablishMetric = {
      End: e.eventTime,
      Id: this.privConnectionId,
      Name: "Connection",
      Start: this.privConnectionStartTime
    })), e instanceof St.ConnectionEstablishErrorEvent && e.connectionId === this.privConnectionId && (this.privConnectionEstablishMetric || (this.privConnectionEstablishMetric = {
      End: e.eventTime,
      Error: this.getConnectionError(e.statusCode),
      Id: this.privConnectionId,
      Name: "Connection",
      Start: this.privConnectionStartTime
    })), e instanceof St.ConnectionMessageReceivedEvent && e.connectionId === this.privConnectionId && e.message && e.message.headers && e.message.headers.path && (this.privReceivedMessages[e.message.headers.path] || (this.privReceivedMessages[e.message.headers.path] = new Array()), this.privReceivedMessages[e.message.headers.path].length < 50 && this.privReceivedMessages[e.message.headers.path].push(e.networkReceivedTime)));
  }
  getTelemetry() {
    const e = new Array();
    this.privListeningTriggerMetric && e.push(this.privListeningTriggerMetric), this.privMicMetric && e.push(this.privMicMetric), this.privConnectionEstablishMetric && e.push(this.privConnectionEstablishMetric), this.privPhraseLatencies.length > 0 && e.push({
      PhraseLatencyMs: this.privPhraseLatencies
    }), this.privHypothesisLatencies.length > 0 && e.push({
      FirstHypothesisLatencyMs: this.privHypothesisLatencies
    });
    const n = {
      Metrics: e,
      ReceivedMessages: this.privReceivedMessages
    }, r = JSON.stringify(n);
    return this.privReceivedMessages = {}, this.privListeningTriggerMetric = null, this.privMicMetric = null, this.privConnectionEstablishMetric = null, this.privPhraseLatencies = [], this.privHypothesisLatencies = [], r;
  }
  // Determines if there are any telemetry events to send to the service.
  get hasTelemetry() {
    return Object.keys(this.privReceivedMessages).length !== 0 || this.privListeningTriggerMetric !== null || this.privMicMetric !== null || this.privConnectionEstablishMetric !== null || this.privPhraseLatencies.length !== 0 || this.privHypothesisLatencies.length !== 0;
  }
  dispose() {
    this.privIsDisposed = !0;
  }
  getConnectionError(e) {
    switch (e) {
      case 400:
      case 1002:
      case 1003:
      case 1005:
      case 1007:
      case 1008:
      case 1009:
        return "BadRequest";
      case 401:
        return "Unauthorized";
      case 403:
        return "Forbidden";
      case 503:
      case 1001:
        return "ServerUnavailable";
      case 500:
      case 1011:
        return "ServerError";
      case 408:
      case 504:
        return "Timeout";
      default:
        return "statuscode:" + e.toString();
    }
  }
}
Da.ServiceTelemetryListener = yP;
Object.defineProperty(Oa, "__esModule", { value: !0 });
Oa.RequestSession = void 0;
const zn = k(), Hs = Ea, CP = Da;
class _P {
  constructor(e) {
    this.privIsDisposed = !1, this.privDetachables = new Array(), this.privIsAudioNodeDetached = !1, this.privIsRecognizing = !1, this.privIsSpeechEnded = !1, this.privTurnStartAudioOffset = 0, this.privLastRecoOffset = 0, this.privHypothesisReceived = !1, this.privBytesSent = 0, this.privRecognitionBytesSent = 0, this.privRecogNumber = 0, this.privInTurn = !1, this.privConnectionAttempts = 0, this.privAudioSourceId = e, this.privRequestId = zn.createNoDashGuid(), this.privAudioNodeId = zn.createNoDashGuid(), this.privTurnDeferral = new zn.Deferred(), this.privTurnDeferral.resolve();
  }
  get sessionId() {
    return this.privSessionId;
  }
  get requestId() {
    return this.privRequestId;
  }
  get audioNodeId() {
    return this.privAudioNodeId;
  }
  get turnCompletionPromise() {
    return this.privTurnDeferral.promise;
  }
  get isSpeechEnded() {
    return this.privIsSpeechEnded;
  }
  get isRecognizing() {
    return this.privIsRecognizing;
  }
  get currentTurnAudioOffset() {
    return this.privTurnStartAudioOffset;
  }
  get recogNumber() {
    return this.privRecogNumber;
  }
  get numConnectionAttempts() {
    return this.privConnectionAttempts;
  }
  // The number of bytes sent for the current connection.
  // Counter is reset to 0 each time a connection is established.
  get bytesSent() {
    return this.privBytesSent;
  }
  // The number of bytes sent for the current recognition.
  // Counter is reset to 0 each time recognition is started.
  get recognitionBytesSent() {
    return this.privRecognitionBytesSent;
  }
  listenForServiceTelemetry(e) {
    this.privServiceTelemetryListener && this.privDetachables.push(e.attachListener(this.privServiceTelemetryListener));
  }
  startNewRecognition() {
    this.privRecognitionBytesSent = 0, this.privIsSpeechEnded = !1, this.privIsRecognizing = !0, this.privTurnStartAudioOffset = 0, this.privLastRecoOffset = 0, this.privRecogNumber++, this.privServiceTelemetryListener = new CP.ServiceTelemetryListener(this.privRequestId, this.privAudioSourceId, this.privAudioNodeId), this.onEvent(new Hs.RecognitionTriggeredEvent(this.requestId, this.privSessionId, this.privAudioSourceId, this.privAudioNodeId));
  }
  async onAudioSourceAttachCompleted(e, n) {
    this.privAudioNode = e, this.privIsAudioNodeDetached = !1, n ? await this.onComplete() : this.onEvent(new Hs.ListeningStartedEvent(this.privRequestId, this.privSessionId, this.privAudioSourceId, this.privAudioNodeId));
  }
  onPreConnectionStart(e, n) {
    this.privAuthFetchEventId = e, this.privSessionId = n, this.onEvent(new Hs.ConnectingToServiceEvent(this.privRequestId, this.privAuthFetchEventId, this.privSessionId));
  }
  async onAuthCompleted(e) {
    e && await this.onComplete();
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async onConnectionEstablishCompleted(e, n) {
    if (e === 200) {
      this.onEvent(new Hs.RecognitionStartedEvent(this.requestId, this.privAudioSourceId, this.privAudioNodeId, this.privAuthFetchEventId, this.privSessionId)), this.privAudioNode && this.privAudioNode.replay(), this.privTurnStartAudioOffset = this.privLastRecoOffset, this.privBytesSent = 0;
      return;
    } else
      e === 403 && await this.onComplete();
  }
  async onServiceTurnEndResponse(e) {
    this.privTurnDeferral.resolve(), !e || this.isSpeechEnded ? (await this.onComplete(), this.privInTurn = !1) : (this.privTurnStartAudioOffset = this.privLastRecoOffset, this.privAudioNode.replay());
  }
  onSpeechContext() {
    this.privRequestId = zn.createNoDashGuid();
  }
  onServiceTurnStartResponse() {
    this.privTurnDeferral && this.privInTurn && (this.privTurnDeferral.reject("Another turn started before current completed."), this.privTurnDeferral.promise.then().catch(() => {
    })), this.privInTurn = !0, this.privTurnDeferral = new zn.Deferred();
  }
  onHypothesis(e) {
    this.privHypothesisReceived || (this.privHypothesisReceived = !0, this.privServiceTelemetryListener.hypothesisReceived(this.privAudioNode.findTimeAtOffset(e)));
  }
  onPhraseRecognized(e) {
    this.privServiceTelemetryListener.phraseReceived(this.privAudioNode.findTimeAtOffset(e)), this.onServiceRecognized(e);
  }
  onServiceRecognized(e) {
    this.privLastRecoOffset = e, this.privHypothesisReceived = !1, this.privAudioNode.shrinkBuffers(e), this.privConnectionAttempts = 0;
  }
  onAudioSent(e) {
    this.privBytesSent += e, this.privRecognitionBytesSent += e;
  }
  onRetryConnection() {
    this.privConnectionAttempts++;
  }
  async dispose() {
    if (!this.privIsDisposed) {
      this.privIsDisposed = !0;
      for (const e of this.privDetachables)
        await e.detach();
      this.privServiceTelemetryListener && this.privServiceTelemetryListener.dispose(), this.privIsRecognizing = !1;
    }
  }
  getTelemetry() {
    return this.privServiceTelemetryListener.hasTelemetry ? this.privServiceTelemetryListener.getTelemetry() : null;
  }
  async onStopRecognizing() {
    await this.onComplete();
  }
  // Should be called with the audioNode for this session has indicated that it is out of speech.
  onSpeechEnded() {
    this.privIsSpeechEnded = !0;
  }
  onEvent(e) {
    this.privServiceTelemetryListener && this.privServiceTelemetryListener.onEvent(e), zn.Events.instance.onEvent(e);
  }
  async onComplete() {
    this.privIsRecognizing && (this.privIsRecognizing = !1, await this.detachAudioNode());
  }
  async detachAudioNode() {
    this.privIsAudioNodeDetached || (this.privIsAudioNodeDetached = !0, this.privAudioNode && await this.privAudioNode.detach());
  }
}
Oa.RequestSession = _P;
var Na = {};
Object.defineProperty(Na, "__esModule", { value: !0 });
Na.SpeechContext = void 0;
class RP {
  constructor(e) {
    this.privContext = {}, this.privDynamicGrammar = e;
  }
  /**
   * Gets a section of the speech.context object.
   * @param sectionName Name of the section to get.
   * @return string or Context JSON serializable object that represents the value.
   */
  getSection(e) {
    return this.privContext[e] || {};
  }
  /**
   * Adds a section to the speech.context object.
   * @param sectionName Name of the section to add.
   * @param value JSON serializable object that represents the value.
   */
  setSection(e, n) {
    this.privContext[e] = n;
  }
  /**
   * @Internal
   * This is only used by pronunciation assessment config.
   * Do not use externally, object returned will change without warning or notice.
   */
  setPronunciationAssessmentParams(e, n, r = !1) {
    this.privContext.phraseDetection === void 0 && (this.privContext.phraseDetection = {
      enrichment: {
        pronunciationAssessment: {}
      }
    }), this.privContext.phraseDetection.enrichment === void 0 && (this.privContext.phraseDetection.enrichment = {
      pronunciationAssessment: {}
    }), this.privContext.phraseDetection.enrichment.pronunciationAssessment = JSON.parse(e), r && (this.privContext.phraseDetection.mode = "Conversation"), this.setWordLevelTimings(), this.privContext.phraseOutput.detailed.options.push("PronunciationAssessment"), this.privContext.phraseOutput.detailed.options.indexOf("SNR") === -1 && this.privContext.phraseOutput.detailed.options.push("SNR"), n && (this.privContext.phraseDetection.enrichment.contentAssessment = {
      topic: n
    }, this.privContext.phraseOutput.detailed.options.push("ContentAssessment"));
  }
  setDetailedOutputFormat() {
    this.privContext.phraseOutput === void 0 && (this.privContext.phraseOutput = {
      detailed: {
        options: []
      },
      format: {}
    }), this.privContext.phraseOutput.detailed === void 0 && (this.privContext.phraseOutput.detailed = {
      options: []
    }), this.privContext.phraseOutput.format = "Detailed";
  }
  setWordLevelTimings() {
    this.privContext.phraseOutput === void 0 && (this.privContext.phraseOutput = {
      detailed: {
        options: []
      },
      format: {}
    }), this.privContext.phraseOutput.detailed === void 0 && (this.privContext.phraseOutput.detailed = {
      options: []
    }), this.privContext.phraseOutput.format = "Detailed", this.privContext.phraseOutput.detailed.options.indexOf("WordTimings") === -1 && this.privContext.phraseOutput.detailed.options.push("WordTimings");
  }
  setSpeakerDiarizationAudioOffsetMs(e) {
    this.privContext.phraseDetection.speakerDiarization.audioOffsetMs = e;
  }
  toJSON() {
    const e = this.privDynamicGrammar.generateGrammarObject();
    return this.setSection("dgi", e), JSON.stringify(this.privContext);
  }
}
Na.SpeechContext = RP;
var La = {};
Object.defineProperty(La, "__esModule", { value: !0 });
La.DynamicGrammarBuilder = void 0;
class PP {
  // Adds one more reference phrases to the dynamic grammar to send.
  // All added phrases are generic phrases.
  addPhrase(e) {
    this.privPhrases || (this.privPhrases = []), e instanceof Array ? this.privPhrases = this.privPhrases.concat(e) : this.privPhrases.push(e);
  }
  // Clears all phrases stored in the current object.
  clearPhrases() {
    this.privPhrases = void 0;
  }
  // Adds one or more reference grammars to the current grammar.
  addReferenceGrammar(e) {
    this.privGrammars || (this.privGrammars = []), e instanceof Array ? this.privGrammars = this.privGrammars.concat(e) : this.privGrammars.push(e);
  }
  // clears all grammars stored on the recognizer.
  clearGrammars() {
    this.privGrammars = void 0;
  }
  // Generates an object that represents the dynamic grammar used by the Speech Service.
  // This is done by building an object with the correct layout based on the phrases and reference grammars added to this instance
  // of a DynamicGrammarBuilder
  generateGrammarObject() {
    if (this.privGrammars === void 0 && this.privPhrases === void 0)
      return;
    const e = {};
    if (e.ReferenceGrammars = this.privGrammars, this.privPhrases !== void 0 && this.privPhrases.length !== 0) {
      const n = [];
      this.privPhrases.forEach((r) => {
        n.push({
          Text: r
        });
      }), e.Groups = [{ Type: "Generic", Items: n }];
    }
    return e;
  }
}
La.DynamicGrammarBuilder = PP;
var hg = {};
Object.defineProperty(hg, "__esModule", { value: !0 });
var ji = {}, za = {}, ja = {}, Ku = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.MessageDataStreamType = t.ActivityPayloadResponse = void 0;
  class e {
    constructor(r) {
      this.privActivityResponse = JSON.parse(r);
    }
    static fromJSON(r) {
      return new e(r);
    }
    get conversationId() {
      return this.privActivityResponse.conversationId;
    }
    get messageDataStreamType() {
      return this.privActivityResponse.messageDataStreamType;
    }
    get messagePayload() {
      return this.privActivityResponse.messagePayload;
    }
    get version() {
      return this.privActivityResponse.version;
    }
  }
  t.ActivityPayloadResponse = e, function(n) {
    n[n.None = 0] = "None", n[n.TextToSpeechAudio = 1] = "TextToSpeechAudio";
  }(t.MessageDataStreamType || (t.MessageDataStreamType = {}));
})(Ku);
Object.defineProperty(ja, "__esModule", { value: !0 });
ja.DialogServiceTurnState = void 0;
const EP = Vt, TP = Re, IP = Ku;
class wP {
  constructor(e, n) {
    this.privRequestId = n, this.privIsCompleted = !1, this.privAudioStream = null, this.privTurnManager = e, this.resetTurnEndTimeout();
  }
  get audioStream() {
    return this.resetTurnEndTimeout(), this.privAudioStream;
  }
  processActivityPayload(e, n) {
    return e.messageDataStreamType === IP.MessageDataStreamType.TextToSpeechAudio && (this.privAudioStream = TP.AudioOutputStream.createPullStream(), this.privAudioStream.format = n !== void 0 ? n : EP.AudioOutputFormatImpl.getDefaultOutputFormat()), this.privAudioStream;
  }
  endAudioStream() {
    this.privAudioStream !== null && !this.privAudioStream.isClosed && this.privAudioStream.close();
  }
  complete() {
    this.privTimeoutToken !== void 0 && clearTimeout(this.privTimeoutToken), this.endAudioStream();
  }
  resetTurnEndTimeout() {
    this.privTimeoutToken !== void 0 && clearTimeout(this.privTimeoutToken), this.privTimeoutToken = setTimeout(() => {
      this.privTurnManager.CompleteTurn(this.privRequestId);
    }, 2e3);
  }
}
ja.DialogServiceTurnState = wP;
Object.defineProperty(za, "__esModule", { value: !0 });
za.DialogServiceTurnStateManager = void 0;
const Fl = Ee, bP = ja;
class AP {
  constructor() {
    this.privTurnMap = /* @__PURE__ */ new Map();
  }
  StartTurn(e) {
    if (this.privTurnMap.has(e))
      throw new Fl.InvalidOperationError("Service error: There is already a turn with id:" + e);
    const n = new bP.DialogServiceTurnState(this, e);
    return this.privTurnMap.set(e, n), this.privTurnMap.get(e);
  }
  GetTurn(e) {
    return this.privTurnMap.get(e);
  }
  CompleteTurn(e) {
    if (!this.privTurnMap.has(e))
      throw new Fl.InvalidOperationError("Service error: Received turn end for an unknown turn id:" + e);
    const n = this.privTurnMap.get(e);
    return n.complete(), this.privTurnMap.delete(e), n;
  }
}
za.DialogServiceTurnStateManager = AP;
var $l;
function MP() {
  if ($l)
    return ji;
  $l = 1, Object.defineProperty(ji, "__esModule", { value: !0 }), ji.DialogServiceAdapter = void 0;
  const t = ye(), e = yn, n = k(), r = Vt, s = R(), o = za, a = A(), i = Ku, c = It;
  let u = class extends a.ServiceRecognizerBase {
    constructor(d, l, h, v, g) {
      super(d, l, h, v, g), this.privEvents = new n.EventSource(), this.privDialogServiceConnector = g, this.receiveMessageOverride = () => this.receiveDialogMessageOverride(), this.privTurnStateManager = new o.DialogServiceTurnStateManager(), this.recognizeOverride = (f, m, S) => this.listenOnce(f, m, S), this.postConnectImplOverride = (f) => this.dialogConnectImpl(f), this.configConnectionOverride = (f) => this.configConnection(f), this.disconnectOverride = () => this.privDisconnect(), this.privDialogAudioSource = h, this.agentConfigSent = !1, this.privLastResult = null, this.connectionEvents.attach((f) => {
        f.name === "ConnectionClosedEvent" && (this.terminateMessageLoop = !0);
      });
    }
    async sendMessage(d) {
      const l = n.createGuid(), h = n.createNoDashGuid(), v = {
        context: {
          interactionId: l
        },
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        messagePayload: JSON.parse(d),
        version: 0.5
      }, g = JSON.stringify(v);
      await (await this.fetchConnection()).send(new c.SpeechConnectionMessage(n.MessageType.Text, "agent", h, "application/json", g));
    }
    async privDisconnect() {
      await this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, s.CancellationReason.Error, s.CancellationErrorCode.NoError, "Disconnecting"), this.terminateMessageLoop = !0, this.agentConfigSent = !1;
    }
    processTypeSpecificMessages(d) {
      const l = new s.PropertyCollection();
      d.messageType === n.MessageType.Text && l.setProperty(s.PropertyId.SpeechServiceResponse_JsonResult, d.textBody);
      let h, v;
      switch (d.path.toLowerCase()) {
        case "speech.phrase":
          const f = a.SimpleSpeechPhrase.fromJSON(d.textBody, this.privRequestSession.currentTurnAudioOffset);
          if (this.privRequestSession.onPhraseRecognized(f.Offset + f.Duration), f.RecognitionStatus !== a.RecognitionStatus.TooManyRequests && f.RecognitionStatus !== a.RecognitionStatus.Error) {
            const C = this.fireEventForResult(f, l);
            if (this.privLastResult = C.result, this.privDialogServiceConnector.recognized)
              try {
                this.privDialogServiceConnector.recognized(this.privDialogServiceConnector, C);
              } catch {
              }
          }
          v = !0;
          break;
        case "speech.hypothesis":
          const m = a.SpeechHypothesis.fromJSON(d.textBody, this.privRequestSession.currentTurnAudioOffset);
          h = new s.SpeechRecognitionResult(this.privRequestSession.requestId, s.ResultReason.RecognizingSpeech, m.Text, m.Duration, m.Offset, m.Language, m.LanguageDetectionConfidence, void 0, void 0, m.asJson(), l), this.privRequestSession.onHypothesis(m.Offset);
          const S = new s.SpeechRecognitionEventArgs(h, m.Offset, this.privRequestSession.sessionId);
          if (this.privDialogServiceConnector.recognizing)
            try {
              this.privDialogServiceConnector.recognizing(this.privDialogServiceConnector, S);
            } catch {
            }
          v = !0;
          break;
        case "speech.keyword":
          const y = a.SpeechKeyword.fromJSON(d.textBody, this.privRequestSession.currentTurnAudioOffset);
          h = new s.SpeechRecognitionResult(this.privRequestSession.requestId, y.Status === "Accepted" ? s.ResultReason.RecognizedKeyword : s.ResultReason.NoMatch, y.Text, y.Duration, y.Offset, void 0, void 0, void 0, void 0, y.asJson(), l), y.Status !== "Accepted" && (this.privLastResult = h);
          const P = new s.SpeechRecognitionEventArgs(h, h.duration, h.resultId);
          if (this.privDialogServiceConnector.recognized)
            try {
              this.privDialogServiceConnector.recognized(this.privDialogServiceConnector, P);
            } catch {
            }
          v = !0;
          break;
        case "audio":
          {
            const C = d.requestId.toUpperCase(), _ = this.privTurnStateManager.GetTurn(C);
            try {
              d.binaryBody ? _.audioStream.write(d.binaryBody) : _.endAudioStream();
            } catch {
            }
          }
          v = !0;
          break;
        case "response":
          this.handleResponseMessage(d), v = !0;
          break;
      }
      const g = new n.Deferred();
      return g.resolve(v), g.promise;
    }
    // Cancels recognition.
    async cancelRecognition(d, l, h, v, g) {
      if (this.terminateMessageLoop = !0, this.privRequestSession.isRecognizing && await this.privRequestSession.onStopRecognizing(), this.privDialogServiceConnector.canceled) {
        const f = new s.PropertyCollection();
        f.setProperty(a.CancellationErrorCodePropertyName, s.CancellationErrorCode[v]);
        const m = new s.SpeechRecognitionCanceledEventArgs(h, g, v, void 0, d);
        try {
          this.privDialogServiceConnector.canceled(this.privDialogServiceConnector, m);
        } catch {
        }
        if (this.privSuccessCallback) {
          const S = new s.SpeechRecognitionResult(
            void 0,
            // ResultId
            s.ResultReason.Canceled,
            void 0,
            // Text
            void 0,
            // Duration
            void 0,
            // Offset
            void 0,
            // Language
            void 0,
            // Language Detection Confidence
            void 0,
            // Speaker Id
            g,
            void 0,
            // Json
            f
          );
          try {
            this.privSuccessCallback(S), this.privSuccessCallback = void 0;
          } catch {
          }
        }
      }
    }
    async listenOnce(d, l, h) {
      this.privRecognizerConfig.recognitionMode = d, this.privSuccessCallback = l, this.privErrorCallback = h, this.privRequestSession.startNewRecognition(), this.privRequestSession.listenForServiceTelemetry(this.privDialogAudioSource.events), this.privRecognizerConfig.parameters.setProperty(s.PropertyId.Speech_SessionId, this.privRequestSession.sessionId);
      const v = this.connectImpl(), g = this.sendPreAudioMessages(), f = await this.privDialogAudioSource.attach(this.privRequestSession.audioNodeId), m = await this.privDialogAudioSource.format, S = await this.privDialogAudioSource.deviceInfo, y = new t.ReplayableAudioNode(f, m.avgBytesPerSec);
      await this.privRequestSession.onAudioSourceAttachCompleted(y, !1), this.privRecognizerConfig.SpeechServiceConfig.Context.audio = { source: S };
      try {
        await v, await g;
      } catch (_) {
        return await this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, s.CancellationReason.Error, s.CancellationErrorCode.ConnectionFailure, _), Promise.resolve();
      }
      const P = new s.SessionEventArgs(this.privRequestSession.sessionId);
      this.privRecognizer.sessionStarted && this.privRecognizer.sessionStarted(this.privRecognizer, P), this.sendAudio(y).then(() => {
      }, async (_) => {
        await this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, s.CancellationReason.Error, s.CancellationErrorCode.RuntimeError, _);
      });
    }
    // Establishes a websocket connection to the end point.
    dialogConnectImpl(d) {
      return this.privConnectionLoop = this.startMessageLoop(), d;
    }
    receiveDialogMessageOverride() {
      const d = new n.Deferred(), l = async () => {
        try {
          const h = this.isDisposed(), v = !this.isDisposed() && this.terminateMessageLoop;
          if (h || v) {
            d.resolve(void 0);
            return;
          }
          const f = await (await this.fetchConnection()).read();
          if (!f)
            return l();
          const m = c.SpeechConnectionMessage.fromConnectionMessage(f);
          switch (m.path.toLowerCase()) {
            case "turn.start":
              {
                const T = m.requestId.toUpperCase(), O = this.privRequestSession.requestId.toUpperCase();
                T !== O ? this.privTurnStateManager.StartTurn(T) : this.privRequestSession.onServiceTurnStartResponse();
              }
              break;
            case "speech.startdetected":
              const y = a.SpeechDetected.fromJSON(m.textBody, this.privRequestSession.currentTurnAudioOffset), P = new s.RecognitionEventArgs(y.Offset, this.privRequestSession.sessionId);
              this.privRecognizer.speechStartDetected && this.privRecognizer.speechStartDetected(this.privRecognizer, P);
              break;
            case "speech.enddetected":
              let C;
              m.textBody.length > 0 ? C = m.textBody : C = "{ Offset: 0 }";
              const _ = a.SpeechDetected.fromJSON(C, this.privRequestSession.currentTurnAudioOffset);
              this.privRequestSession.onServiceRecognized(_.Offset);
              const w = new s.RecognitionEventArgs(_.Offset, this.privRequestSession.sessionId);
              this.privRecognizer.speechEndDetected && this.privRecognizer.speechEndDetected(this.privRecognizer, w);
              break;
            case "turn.end":
              {
                const T = m.requestId.toUpperCase(), O = this.privRequestSession.requestId.toUpperCase();
                if (T !== O)
                  this.privTurnStateManager.CompleteTurn(T);
                else {
                  const G = new s.SessionEventArgs(this.privRequestSession.sessionId);
                  if (await this.privRequestSession.onServiceTurnEndResponse(!1), (!this.privRecognizerConfig.isContinuousRecognition || this.privRequestSession.isSpeechEnded || !this.privRequestSession.isRecognizing) && this.privRecognizer.sessionStopped && this.privRecognizer.sessionStopped(this.privRecognizer, G), this.privSuccessCallback && this.privLastResult) {
                    try {
                      this.privSuccessCallback(this.privLastResult), this.privLastResult = null;
                    } catch (X) {
                      this.privErrorCallback && this.privErrorCallback(X);
                    }
                    this.privSuccessCallback = void 0, this.privErrorCallback = void 0;
                  }
                }
              }
              break;
            default:
              try {
                await this.processTypeSpecificMessages(m) || this.serviceEvents && this.serviceEvents.onEvent(new n.ServiceEvent(m.path.toLowerCase(), m.textBody));
              } catch {
              }
          }
          return l();
        } catch {
          this.terminateMessageLoop = !0, d.resolve();
        }
      };
      return l().catch((h) => {
        n.Events.instance.onEvent(new n.BackgroundEvent(h));
      }), d.promise;
    }
    async startMessageLoop() {
      this.terminateMessageLoop = !1;
      try {
        await this.receiveDialogMessageOverride();
      } catch (d) {
        await this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, s.CancellationReason.Error, s.CancellationErrorCode.RuntimeError, d);
      }
      return Promise.resolve();
    }
    // Takes an established websocket connection to the endpoint and sends speech configuration information.
    async configConnection(d) {
      return this.terminateMessageLoop ? (this.terminateMessageLoop = !1, Promise.reject("Connection to service terminated.")) : (await this.sendSpeechServiceConfig(d, this.privRequestSession, this.privRecognizerConfig.SpeechServiceConfig.serialize()), await this.sendAgentConfig(d), d);
    }
    async sendPreAudioMessages() {
      const d = await this.fetchConnection();
      this.addKeywordContextData(), await this.sendSpeechContext(d, !0), await this.sendAgentContext(d), await this.sendWaveHeader(d);
    }
    sendAgentConfig(d) {
      if (this.agentConfig && !this.agentConfigSent) {
        if (this.privRecognizerConfig.parameters.getProperty(s.PropertyId.Conversation_DialogType) === s.DialogServiceConfig.DialogTypes.CustomCommands) {
          const h = this.agentConfig.get();
          h.botInfo.commandsCulture = this.privRecognizerConfig.parameters.getProperty(s.PropertyId.SpeechServiceConnection_RecoLanguage, "en-us"), this.agentConfig.set(h);
        }
        this.onEvent(new e.SendingAgentContextMessageEvent(this.agentConfig));
        const l = this.agentConfig.toJsonString();
        return this.agentConfigSent = !0, d.send(new c.SpeechConnectionMessage(n.MessageType.Text, "agent.config", this.privRequestSession.requestId, "application/json", l));
      }
    }
    sendAgentContext(d) {
      const l = n.createGuid(), h = this.privDialogServiceConnector.properties.getProperty(s.PropertyId.Conversation_Speech_Activity_Template), g = JSON.stringify({
        channelData: "",
        context: {
          interactionId: l
        },
        messagePayload: typeof h === void 0 ? void 0 : h,
        version: 0.5
      });
      return d.send(new c.SpeechConnectionMessage(n.MessageType.Text, "speech.agent.context", this.privRequestSession.requestId, "application/json", g));
    }
    fireEventForResult(d, l) {
      const h = a.EnumTranslation.implTranslateRecognitionResult(d.RecognitionStatus), v = new s.SpeechRecognitionResult(this.privRequestSession.requestId, h, d.DisplayText, d.Duration, d.Offset, d.Language, d.LanguageDetectionConfidence, void 0, void 0, d.asJson(), l);
      return new s.SpeechRecognitionEventArgs(v, d.Offset, this.privRequestSession.sessionId);
    }
    handleResponseMessage(d) {
      const l = JSON.parse(d.textBody);
      switch (l.messageType.toLowerCase()) {
        case "message":
          const h = d.requestId.toUpperCase(), v = i.ActivityPayloadResponse.fromJSON(d.textBody), g = this.privTurnStateManager.GetTurn(h);
          if (v.conversationId) {
            const S = this.agentConfig.get();
            S.botInfo.conversationId = v.conversationId, this.agentConfig.set(S);
          }
          const f = g.processActivityPayload(v, r.AudioOutputFormatImpl.fromSpeechSynthesisOutputFormatString(this.privDialogServiceConnector.properties.getProperty(s.PropertyId.SpeechServiceConnection_SynthOutputFormat, void 0))), m = new s.ActivityReceivedEventArgs(v.messagePayload, f);
          if (this.privDialogServiceConnector.activityReceived)
            try {
              this.privDialogServiceConnector.activityReceived(this.privDialogServiceConnector, m);
            } catch {
            }
          break;
        case "messagestatus":
          if (this.privDialogServiceConnector.turnStatusReceived)
            try {
              this.privDialogServiceConnector.turnStatusReceived(this.privDialogServiceConnector, new s.TurnStatusReceivedEventArgs(d.textBody));
            } catch {
            }
          break;
        default:
          n.Events.instance.onEvent(new n.BackgroundEvent(`Unexpected response of type ${l.messageType}. Ignoring.`));
          break;
      }
    }
    onEvent(d) {
      this.privEvents.onEvent(d), n.Events.instance.onEvent(d);
    }
    addKeywordContextData() {
      const d = this.privRecognizerConfig.parameters.getProperty("SPEECH-KeywordsToDetect");
      if (d === void 0)
        return;
      const l = this.privRecognizerConfig.parameters.getProperty("SPEECH-KeywordsToDetect-Offsets"), h = this.privRecognizerConfig.parameters.getProperty("SPEECH-KeywordsToDetect-Durations"), v = d.split(";"), g = l === void 0 ? [] : l.split(";"), f = h === void 0 ? [] : h.split(";"), m = [];
      for (let S = 0; S < v.length; S++) {
        const y = {};
        y.text = v[S], S < g.length && (y.offset = Number(g[S])), S < f.length && (y.duration = Number(f[S])), m.push(y);
      }
      this.speechContext.setSection("invocationSource", "VoiceActivationWithKeyword"), this.speechContext.setSection("keywordDetection", [{
        clientDetectedKeywords: m,
        onReject: { action: "EndOfTurn" },
        type: "startTrigger"
      }]);
    }
  };
  return ji.DialogServiceAdapter = u, ji;
}
var xa = {};
Object.defineProperty(xa, "__esModule", { value: !0 });
xa.AgentConfig = void 0;
class kP {
  toJsonString() {
    return JSON.stringify(this.iPrivConfig);
  }
  get() {
    return this.iPrivConfig;
  }
  /**
   * Setter for the agent.config object.
   * @param value a JSON serializable object.
   */
  set(e) {
    this.iPrivConfig = e;
  }
}
xa.AgentConfig = kP;
var Ec = {}, xi = {}, rr = {};
Object.defineProperty(rr, "__esModule", { value: !0 });
rr.ConversationConnectionConfig = void 0;
const OP = Ps;
class Oe extends OP.RestConfigBase {
  static get host() {
    return Oe.privHost;
  }
  static get apiVersion() {
    return Oe.privApiVersion;
  }
  static get clientAppId() {
    return Oe.privClientAppId;
  }
  static get defaultLanguageCode() {
    return Oe.privDefaultLanguageCode;
  }
  static get restPath() {
    return Oe.privRestPath;
  }
  static get webSocketPath() {
    return Oe.privWebSocketPath;
  }
  static get transcriptionEventKeys() {
    return Oe.privTranscriptionEventKeys;
  }
}
rr.ConversationConnectionConfig = Oe;
Oe.privHost = "dev.microsofttranslator.com";
Oe.privRestPath = "/capito/room";
Oe.privApiVersion = "2.0";
Oe.privDefaultLanguageCode = "en-US";
Oe.privClientAppId = "FC539C22-1767-4F1F-84BC-B4D811114F15";
Oe.privWebSocketPath = "/capito/translate";
Oe.privTranscriptionEventKeys = ["iCalUid", "callId", "organizer", "FLAC", "MTUri", "DifferentiateGuestSpeakers", "audiorecording", "Threadid", "OrganizerMri", "OrganizerTenantId", "UserToken"];
var Ul;
function DP() {
  if (Ul)
    return xi;
  Ul = 1, Object.defineProperty(xi, "__esModule", { value: !0 }), xi.ConversationManager = void 0;
  const t = ye(), e = N, n = R(), r = rr;
  let s = class {
    constructor() {
      this.privRequestParams = r.ConversationConnectionConfig.configParams, this.privErrors = r.ConversationConnectionConfig.restErrors, this.privHost = r.ConversationConnectionConfig.host, this.privApiVersion = r.ConversationConnectionConfig.apiVersion, this.privRestPath = r.ConversationConnectionConfig.restPath, this.privRestAdapter = new t.RestMessageAdapter({});
    }
    /**
     * Make a POST request to the Conversation Manager service endpoint to create or join a conversation.
     * @param args
     * @param conversationCode
     * @param callback
     * @param errorCallback
     */
    createOrJoin(a, i, c, u) {
      try {
        e.Contracts.throwIfNullOrUndefined(a, "args");
        const p = a.getProperty(n.PropertyId.SpeechServiceConnection_RecoLanguage, r.ConversationConnectionConfig.defaultLanguageCode), d = a.getProperty(n.PropertyId.ConversationTranslator_Name, "conversation_host"), l = a.getProperty(n.PropertyId.ConversationTranslator_Host, this.privHost), h = a.getProperty(n.PropertyId.ConversationTranslator_CorrelationId), v = a.getProperty(n.PropertyId.SpeechServiceConnection_Key), g = a.getProperty(n.PropertyId.SpeechServiceConnection_Region), f = a.getProperty(n.PropertyId.SpeechServiceAuthorization_Token);
        e.Contracts.throwIfNullOrWhitespace(p, "languageCode"), e.Contracts.throwIfNullOrWhitespace(d, "nickname"), e.Contracts.throwIfNullOrWhitespace(l, "endpointHost");
        const m = {};
        m[this.privRequestParams.apiVersion] = this.privApiVersion, m[this.privRequestParams.languageCode] = p, m[this.privRequestParams.nickname] = d;
        const S = {};
        h && (S[this.privRequestParams.correlationId] = h), S[this.privRequestParams.clientAppId] = r.ConversationConnectionConfig.clientAppId, i !== void 0 ? m[this.privRequestParams.roomId] = i : (e.Contracts.throwIfNullOrUndefined(g, this.privErrors.authInvalidSubscriptionRegion), S[this.privRequestParams.subscriptionRegion] = g, v ? S[this.privRequestParams.subscriptionKey] = v : f ? S[this.privRequestParams.authorization] = `Bearer ${f}` : e.Contracts.throwIfNullOrUndefined(v, this.privErrors.authInvalidSubscriptionKey));
        const y = {};
        y.headers = S, this.privRestAdapter.options = y;
        const P = `https://${l}${this.privRestPath}`;
        this.privRestAdapter.request(t.RestRequestType.Post, P, m, null).then((C) => {
          const _ = t.RestMessageAdapter.extractHeaderValue(this.privRequestParams.requestId, C.headers);
          if (!C.ok) {
            if (u) {
              let T = this.privErrors.invalidCreateJoinConversationResponse.replace("{status}", C.status.toString()), O;
              try {
                O = JSON.parse(C.data), T += ` [${O.error.code}: ${O.error.message}]`;
              } catch {
                T += ` [${C.data}]`;
              }
              _ && (T += ` ${_}`), u(T);
            }
            return;
          }
          const w = JSON.parse(C.data);
          if (w && (w.requestId = _), c) {
            try {
              c(w);
            } catch (T) {
              u && u(T);
            }
            c = void 0;
          }
        }).catch(() => {
        });
      } catch (p) {
        if (u)
          if (p instanceof Error) {
            const d = p;
            u(d.name + ": " + d.message);
          } else
            u(p);
      }
    }
    /**
     * Make a DELETE request to the Conversation Manager service endpoint to leave the conversation.
     * @param args
     * @param sessionToken
     * @param callback
     */
    leave(a, i) {
      return new Promise((c, u) => {
        try {
          e.Contracts.throwIfNullOrUndefined(a, this.privErrors.invalidArgs.replace("{arg}", "config")), e.Contracts.throwIfNullOrWhitespace(i, this.privErrors.invalidArgs.replace("{arg}", "token"));
          const p = a.getProperty(n.PropertyId.ConversationTranslator_Host, this.privHost), d = a.getProperty(n.PropertyId.ConversationTranslator_CorrelationId), l = {};
          l[this.privRequestParams.apiVersion] = this.privApiVersion, l[this.privRequestParams.sessionToken] = i;
          const h = {};
          d && (h[this.privRequestParams.correlationId] = d);
          const v = {};
          v.headers = h, this.privRestAdapter.options = v;
          const g = `https://${p}${this.privRestPath}`;
          this.privRestAdapter.request(t.RestRequestType.Delete, g, l, null).then((f) => {
            f.ok, c();
          }).catch(() => {
          });
        } catch (p) {
          if (p instanceof Error) {
            const d = p;
            u(d.name + ": " + d.message);
          } else
            u(p);
        }
      });
    }
  };
  return xi.ConversationManager = s, xi;
}
var an = {}, Bi = {}, Ba = {}, Es = {};
Object.defineProperty(Es, "__esModule", { value: !0 });
Es.ConversationConnectionMessage = void 0;
const NP = k();
class LP extends NP.ConnectionMessage {
  constructor(e, n, r, s) {
    super(e, n, r, s);
    const o = JSON.parse(this.textBody);
    o.type !== void 0 && (this.privConversationMessageType = o.type);
  }
  get conversationMessageType() {
    return this.privConversationMessageType;
  }
}
Es.ConversationConnectionMessage = LP;
Object.defineProperty(Ba, "__esModule", { value: !0 });
Ba.ConversationWebsocketMessageFormatter = void 0;
const cn = k(), Hl = Es;
class zP {
  /**
   * Format incoming messages: text (speech partial/final, IM) or binary (tts)
   */
  toConnectionMessage(e) {
    const n = new cn.Deferred();
    try {
      if (e.messageType === cn.MessageType.Text) {
        const r = new Hl.ConversationConnectionMessage(e.messageType, e.textContent, {}, e.id);
        n.resolve(r);
      } else
        e.messageType === cn.MessageType.Binary && n.resolve(new Hl.ConversationConnectionMessage(e.messageType, e.binaryContent, void 0, e.id));
    } catch (r) {
      n.reject(`Error formatting the message. Error: ${r}`);
    }
    return n.promise;
  }
  /**
   * Format outgoing messages: text (commands or IM)
   */
  fromConnectionMessage(e) {
    const n = new cn.Deferred();
    try {
      if (e.messageType === cn.MessageType.Text) {
        const r = `${e.textBody ? e.textBody : ""}`;
        n.resolve(new cn.RawWebsocketMessage(cn.MessageType.Text, r, e.id));
      }
    } catch (r) {
      n.reject(`Error formatting the message. ${r}`);
    }
    return n.promise;
  }
}
Ba.ConversationWebsocketMessageFormatter = zP;
var Wl;
function jP() {
  if (Wl)
    return Bi;
  Wl = 1, Object.defineProperty(Bi, "__esModule", { value: !0 }), Bi.ConversationConnectionFactory = void 0;
  const t = ye(), e = k(), n = N, r = R(), s = ot(), o = rr, a = Ba;
  let i = class extends s.ConnectionFactoryBase {
    create(u, p, d) {
      const l = u.parameters.getProperty(r.PropertyId.ConversationTranslator_Host, o.ConversationConnectionConfig.host), h = u.parameters.getProperty(r.PropertyId.ConversationTranslator_CorrelationId, e.createGuid()), v = `wss://${l}${o.ConversationConnectionConfig.webSocketPath}`, g = u.parameters.getProperty(r.PropertyId.ConversationTranslator_Token, void 0);
      n.Contracts.throwIfNullOrUndefined(g, "token");
      const f = {};
      f[o.ConversationConnectionConfig.configParams.apiVersion] = o.ConversationConnectionConfig.apiVersion, f[o.ConversationConnectionConfig.configParams.token] = g, f[o.ConversationConnectionConfig.configParams.correlationId] = h;
      const m = u.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
      return new t.WebsocketConnection(v, f, {}, new a.ConversationWebsocketMessageFormatter(), t.ProxyInfo.fromRecognizerConfig(u), m, d);
    }
  };
  return Bi.ConversationConnectionFactory = i, Bi;
}
var qi = {}, qa = {};
Object.defineProperty(qa, "__esModule", { value: !0 });
qa.ConversationRequestSession = void 0;
const Tc = k();
class xP {
  constructor(e) {
    this.privIsDisposed = !1, this.privDetachables = new Array(), this.privSessionId = e, this.privRequestId = Tc.createNoDashGuid(), this.privRequestCompletionDeferral = new Tc.Deferred();
  }
  get sessionId() {
    return this.privSessionId;
  }
  get requestId() {
    return this.privRequestId;
  }
  get completionPromise() {
    return this.privRequestCompletionDeferral.promise;
  }
  onPreConnectionStart(e, n) {
    this.privSessionId = n;
  }
  onAuthCompleted(e) {
    e && this.onComplete();
  }
  onConnectionEstablishCompleted(e) {
    e !== 200 && e === 403 && this.onComplete();
  }
  onServiceTurnEndResponse(e) {
    e ? this.privRequestId = Tc.createNoDashGuid() : this.onComplete();
  }
  async dispose() {
    if (!this.privIsDisposed) {
      this.privIsDisposed = !0;
      for (const e of this.privDetachables)
        await e.detach();
    }
  }
  onComplete() {
  }
}
qa.ConversationRequestSession = xP;
var Le = {}, Vl;
function vg() {
  if (Vl)
    return Le;
  Vl = 1, Object.defineProperty(Le, "__esModule", { value: !0 }), Le.ConversationReceivedTranslationEventArgs = Le.ParticipantsListEventArgs = Le.ParticipantAttributeEventArgs = Le.ParticipantEventArgs = Le.LockRoomEventArgs = Le.MuteAllEventArgs = void 0;
  const t = R();
  class e extends t.SessionEventArgs {
    constructor(c, u) {
      super(u), this.privIsMuted = c;
    }
    get isMuted() {
      return this.privIsMuted;
    }
  }
  Le.MuteAllEventArgs = e;
  class n extends t.SessionEventArgs {
    constructor(c, u) {
      super(u), this.privIsLocked = c;
    }
    get isMuted() {
      return this.privIsLocked;
    }
  }
  Le.LockRoomEventArgs = n;
  class r extends t.SessionEventArgs {
    constructor(c, u) {
      super(u), this.privParticipant = c;
    }
    get participant() {
      return this.privParticipant;
    }
  }
  Le.ParticipantEventArgs = r;
  class s extends t.SessionEventArgs {
    constructor(c, u, p, d) {
      super(d), this.privKey = u, this.privValue = p, this.privParticipantId = c;
    }
    get value() {
      return this.privValue;
    }
    get key() {
      return this.privKey;
    }
    get id() {
      return this.privParticipantId;
    }
  }
  Le.ParticipantAttributeEventArgs = s;
  class o extends t.SessionEventArgs {
    constructor(c, u, p, d, l, h, v, g, f) {
      super(f), this.privRoomId = c, this.privSessionToken = u, this.privTranslateTo = p, this.privProfanityFilter = d, this.privRoomProfanityFilter = l, this.privIsRoomLocked = h, this.privIsRoomLocked = v, this.privParticipants = g;
    }
    get sessionToken() {
      return this.privSessionToken;
    }
    get conversationId() {
      return this.privRoomId;
    }
    get translateTo() {
      return this.privTranslateTo;
    }
    get profanityFilter() {
      return this.privProfanityFilter;
    }
    get roomProfanityFilter() {
      return this.privRoomProfanityFilter;
    }
    get isRoomLocked() {
      return this.privIsRoomLocked;
    }
    get isMuteAll() {
      return this.privIsMuteAll;
    }
    get participants() {
      return this.privParticipants;
    }
  }
  Le.ParticipantsListEventArgs = o;
  class a {
    constructor(c, u, p) {
      this.privPayload = u, this.privCommand = c, this.privSessionId = p;
    }
    get payload() {
      return this.privPayload;
    }
    get command() {
      return this.privCommand;
    }
    get sessionId() {
      return this.privSessionId;
    }
  }
  return Le.ConversationReceivedTranslationEventArgs = a, Le;
}
var Rt = {};
Object.defineProperty(Rt, "__esModule", { value: !0 });
Rt.ConversationTranslatorCommandTypes = Rt.ConversationTranslatorMessageTypes = Rt.InternalParticipants = void 0;
class BP {
  constructor(e = [], n) {
    this.participants = e, this.meId = n;
  }
  /**
   * Add or update a participant
   * @param value
   */
  addOrUpdateParticipant(e) {
    if (e === void 0)
      return;
    const n = this.getParticipantIndex(e.id);
    return n > -1 ? this.participants.splice(n, 1, e) : this.participants.push(e), this.getParticipant(e.id);
  }
  /**
   * Find the participant's position in the participants list.
   * @param id
   */
  getParticipantIndex(e) {
    return this.participants.findIndex((n) => n.id === e);
  }
  /**
   * Find the participant by id.
   * @param id
   */
  getParticipant(e) {
    return this.participants.find((n) => n.id === e);
  }
  /**
   * Remove a participant from the participants list.
   */
  deleteParticipant(e) {
    this.participants = this.participants.filter((n) => n.id !== e);
  }
  /**
   * Helper to return the conversation host.
   */
  get host() {
    return this.participants.find((e) => e.isHost === !0);
  }
  /**
   * Helper to return the current user.
   */
  get me() {
    return this.getParticipant(this.meId);
  }
}
Rt.InternalParticipants = BP;
Rt.ConversationTranslatorMessageTypes = {
  command: "command",
  final: "final",
  info: "info",
  instantMessage: "instant_message",
  keepAlive: "keep_alive",
  partial: "partial",
  participantCommand: "participant_command",
  translatedMessage: "translated_message"
};
Rt.ConversationTranslatorCommandTypes = {
  changeNickname: "ChangeNickname",
  disconnectSession: "DisconnectSession",
  ejectParticipant: "EjectParticipant",
  instant_message: "instant_message",
  joinSession: "JoinSession",
  leaveSession: "LeaveSession",
  participantList: "ParticipantList",
  roomExpirationWarning: "RoomExpirationWarning",
  setLockState: "SetLockState",
  setMute: "SetMute",
  setMuteAll: "SetMuteAll",
  setProfanityFiltering: "SetProfanityFiltering",
  setTranslateToLanguages: "SetTranslateToLanguages",
  setUseTTS: "SetUseTTS"
};
var fg = {}, Fa = {};
Object.defineProperty(Fa, "__esModule", { value: !0 });
Fa.CommandResponsePayload = void 0;
const qP = (t) => JSON.parse(t);
class Ju {
  constructor(e) {
    this.privCommandResponse = qP(e);
  }
  get type() {
    return this.privCommandResponse.type;
  }
  get command() {
    return this.privCommandResponse.command;
  }
  get id() {
    return this.privCommandResponse.id;
  }
  get nickname() {
    return this.privCommandResponse.nickname;
  }
  get participantId() {
    return this.privCommandResponse.participantId;
  }
  get roomid() {
    return this.privCommandResponse.roomid;
  }
  get value() {
    return this.privCommandResponse.value;
  }
  get token() {
    return this.privCommandResponse.token;
  }
  static fromJSON(e) {
    return new Ju(e);
  }
}
Fa.CommandResponsePayload = Ju;
var Wn = {};
Object.defineProperty(Wn, "__esModule", { value: !0 });
Wn.ParticipantPayloadResponse = Wn.ParticipantsListPayloadResponse = void 0;
const FP = (t) => JSON.parse(t), $P = (t) => JSON.parse(t);
class Gu {
  constructor(e) {
    this.privParticipantsPayloadResponse = FP(e);
  }
  get roomid() {
    return this.privParticipantsPayloadResponse.roomid;
  }
  get id() {
    return this.privParticipantsPayloadResponse.id;
  }
  get command() {
    return this.privParticipantsPayloadResponse.command;
  }
  get participants() {
    return this.privParticipantsPayloadResponse.participants;
  }
  get token() {
    return this.privParticipantsPayloadResponse.token;
  }
  get translateTo() {
    return this.privParticipantsPayloadResponse.translateTo;
  }
  get profanityFilter() {
    return this.privParticipantsPayloadResponse.profanityFilter;
  }
  get roomProfanityFilter() {
    return this.privParticipantsPayloadResponse.roomProfanityFilter;
  }
  get roomLocked() {
    return this.privParticipantsPayloadResponse.roomLocked;
  }
  get muteAll() {
    return this.privParticipantsPayloadResponse.muteAll;
  }
  get type() {
    return this.privParticipantsPayloadResponse.type;
  }
  static fromJSON(e) {
    return new Gu(e);
  }
}
Wn.ParticipantsListPayloadResponse = Gu;
class Qu {
  constructor(e) {
    this.privParticipantPayloadResponse = $P(e);
  }
  get nickname() {
    return this.privParticipantPayloadResponse.nickname;
  }
  get locale() {
    return this.privParticipantPayloadResponse.locale;
  }
  get usetts() {
    return this.privParticipantPayloadResponse.usetts;
  }
  get ismuted() {
    return this.privParticipantPayloadResponse.ismuted;
  }
  get ishost() {
    return this.privParticipantPayloadResponse.ishost;
  }
  get participantId() {
    return this.privParticipantPayloadResponse.participantId;
  }
  get avatar() {
    return this.privParticipantPayloadResponse.avatar;
  }
  static fromJSON(e) {
    return new Qu(e);
  }
}
Wn.ParticipantPayloadResponse = Qu;
var Vn = {};
Object.defineProperty(Vn, "__esModule", { value: !0 });
Vn.TextResponsePayload = Vn.SpeechResponsePayload = void 0;
const UP = (t) => JSON.parse(t), HP = (t) => JSON.parse(t);
class Yu {
  constructor(e) {
    this.privSpeechResponse = UP(e);
  }
  get recognition() {
    return this.privSpeechResponse.recognition;
  }
  get translations() {
    return this.privSpeechResponse.translations;
  }
  get id() {
    return this.privSpeechResponse.id;
  }
  get language() {
    return this.privSpeechResponse.language;
  }
  get nickname() {
    return this.privSpeechResponse.nickname;
  }
  get participantId() {
    return this.privSpeechResponse.participantId;
  }
  get roomid() {
    return this.privSpeechResponse.roomid;
  }
  get timestamp() {
    return this.privSpeechResponse.timestamp;
  }
  get type() {
    return this.privSpeechResponse.type;
  }
  get isFinal() {
    return this.privSpeechResponse.type === "final";
  }
  static fromJSON(e) {
    return new Yu(e);
  }
}
Vn.SpeechResponsePayload = Yu;
class Zu {
  constructor(e) {
    this.privTextResponse = HP(e);
  }
  get originalText() {
    return this.privTextResponse.originalText;
  }
  get translations() {
    return this.privTextResponse.translations;
  }
  get id() {
    return this.privTextResponse.id;
  }
  get language() {
    return this.privTextResponse.language;
  }
  get nickname() {
    return this.privTextResponse.nickname;
  }
  get participantId() {
    return this.privTextResponse.participantId;
  }
  get roomid() {
    return this.privTextResponse.roomid;
  }
  get timestamp() {
    return this.privTextResponse.timestamp;
  }
  get type() {
    return this.privTextResponse.type;
  }
  static fromJSON(e) {
    return new Zu(e);
  }
}
Vn.TextResponsePayload = Zu;
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 });
  var e = Fa;
  Object.defineProperty(t, "CommandResponsePayload", { enumerable: !0, get: function() {
    return e.CommandResponsePayload;
  } });
  var n = Wn;
  Object.defineProperty(t, "ParticipantsListPayloadResponse", { enumerable: !0, get: function() {
    return n.ParticipantsListPayloadResponse;
  } }), Object.defineProperty(t, "ParticipantPayloadResponse", { enumerable: !0, get: function() {
    return n.ParticipantPayloadResponse;
  } });
  var r = Vn;
  Object.defineProperty(t, "SpeechResponsePayload", { enumerable: !0, get: function() {
    return r.SpeechResponsePayload;
  } }), Object.defineProperty(t, "TextResponsePayload", { enumerable: !0, get: function() {
    return r.TextResponsePayload;
  } });
})(fg);
var Kl;
function WP() {
  if (Kl)
    return qi;
  Kl = 1, Object.defineProperty(qi, "__esModule", { value: !0 }), qi.ConversationServiceAdapter = void 0;
  const t = k(), e = R(), n = A(), r = Es, s = qa, o = vg(), a = Rt, i = fg;
  let c = class extends n.ServiceRecognizerBase {
    constructor(p, d, l, h, v) {
      super(p, d, l, h, v), this.privConnectionConfigPromise = void 0, this.privLastPartialUtteranceId = "", this.privConversationServiceConnector = v, this.privConversationAuthentication = p, this.receiveMessageOverride = () => this.receiveConversationMessageOverride(), this.recognizeOverride = () => this.noOp(), this.postConnectImplOverride = (g) => this.conversationConnectImpl(g), this.configConnectionOverride = () => this.configConnection(), this.disconnectOverride = () => this.privDisconnect(), this.privConversationRequestSession = new s.ConversationRequestSession(t.createNoDashGuid()), this.privConversationConnectionFactory = d, this.privConversationIsDisposed = !1;
    }
    isDisposed() {
      return super.isDisposed() || this.privConversationIsDisposed;
    }
    async dispose(p) {
      this.privConversationIsDisposed = !0, this.privConnectionConfigPromise !== void 0 && await (await this.privConnectionConfigPromise).dispose(p), await super.dispose(p);
    }
    async sendMessage(p) {
      return (await this.fetchConnection()).send(new r.ConversationConnectionMessage(t.MessageType.Text, p));
    }
    async sendMessageAsync(p) {
      await (await this.fetchConnection()).send(new r.ConversationConnectionMessage(t.MessageType.Text, p));
    }
    privDisconnect() {
      if (!this.terminateMessageLoop)
        return this.cancelRecognition(this.privConversationRequestSession.sessionId, this.privConversationRequestSession.requestId, e.CancellationReason.Error, e.CancellationErrorCode.NoError, "Disconnecting"), this.terminateMessageLoop = !0, Promise.resolve();
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    async processTypeSpecificMessages() {
      return !0;
    }
    // Cancels recognition.
    cancelRecognition(p, d, l, h, v) {
      this.terminateMessageLoop = !0;
      const g = new e.ConversationTranslationCanceledEventArgs(l, v, h, void 0, p);
      try {
        this.privConversationServiceConnector.canceled && this.privConversationServiceConnector.canceled(this.privConversationServiceConnector, g);
      } catch {
      }
    }
    /**
     * Establishes a websocket connection to the end point.
     */
    async conversationConnectImpl(p) {
      return this.privConnectionLoop = this.startMessageLoop(), p;
    }
    /**
     * Process incoming websocket messages
     */
    async receiveConversationMessageOverride() {
      if (this.isDisposed() || this.terminateMessageLoop)
        return Promise.resolve();
      const p = new t.Deferred();
      try {
        const l = await (await this.fetchConnection()).read();
        if (this.isDisposed() || this.terminateMessageLoop)
          return p.resolve(), Promise.resolve();
        if (!l)
          return this.receiveConversationMessageOverride();
        const h = this.privConversationRequestSession.sessionId, v = l.conversationMessageType.toLowerCase();
        let g = !1;
        try {
          switch (v) {
            case "info":
            case "participant_command":
            case "command":
              const f = i.CommandResponsePayload.fromJSON(l.textBody);
              switch (f.command.toLowerCase()) {
                case "participantlist":
                  const _ = i.ParticipantsListPayloadResponse.fromJSON(l.textBody), w = _.participants.map((b) => ({
                    avatar: b.avatar,
                    displayName: b.nickname,
                    id: b.participantId,
                    isHost: b.ishost,
                    isMuted: b.ismuted,
                    isUsingTts: b.usetts,
                    preferredLanguage: b.locale
                  }));
                  this.privConversationServiceConnector.participantsListReceived && this.privConversationServiceConnector.participantsListReceived(this.privConversationServiceConnector, new o.ParticipantsListEventArgs(_.roomid, _.token, _.translateTo, _.profanityFilter, _.roomProfanityFilter, _.roomLocked, _.muteAll, w, h));
                  break;
                case "settranslatetolanguages":
                  this.privConversationServiceConnector.participantUpdateCommandReceived && this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new o.ParticipantAttributeEventArgs(f.participantId, a.ConversationTranslatorCommandTypes.setTranslateToLanguages, f.value, h));
                  break;
                case "setprofanityfiltering":
                  this.privConversationServiceConnector.participantUpdateCommandReceived && this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new o.ParticipantAttributeEventArgs(f.participantId, a.ConversationTranslatorCommandTypes.setProfanityFiltering, f.value, h));
                  break;
                case "setmute":
                  this.privConversationServiceConnector.participantUpdateCommandReceived && this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new o.ParticipantAttributeEventArgs(f.participantId, a.ConversationTranslatorCommandTypes.setMute, f.value, h));
                  break;
                case "setmuteall":
                  this.privConversationServiceConnector.muteAllCommandReceived && this.privConversationServiceConnector.muteAllCommandReceived(this.privConversationServiceConnector, new o.MuteAllEventArgs(f.value, h));
                  break;
                case "roomexpirationwarning":
                  this.privConversationServiceConnector.conversationExpiration && this.privConversationServiceConnector.conversationExpiration(this.privConversationServiceConnector, new e.ConversationExpirationEventArgs(f.value, this.privConversationRequestSession.sessionId));
                  break;
                case "setusetts":
                  this.privConversationServiceConnector.participantUpdateCommandReceived && this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new o.ParticipantAttributeEventArgs(f.participantId, a.ConversationTranslatorCommandTypes.setUseTTS, f.value, h));
                  break;
                case "setlockstate":
                  this.privConversationServiceConnector.lockRoomCommandReceived && this.privConversationServiceConnector.lockRoomCommandReceived(this.privConversationServiceConnector, new o.LockRoomEventArgs(f.value, h));
                  break;
                case "changenickname":
                  this.privConversationServiceConnector.participantUpdateCommandReceived && this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new o.ParticipantAttributeEventArgs(f.participantId, a.ConversationTranslatorCommandTypes.changeNickname, f.value, h));
                  break;
                case "joinsession":
                  const T = i.ParticipantPayloadResponse.fromJSON(l.textBody), O = {
                    avatar: T.avatar,
                    displayName: T.nickname,
                    id: T.participantId,
                    isHost: T.ishost,
                    isMuted: T.ismuted,
                    isUsingTts: T.usetts,
                    preferredLanguage: T.locale
                  };
                  this.privConversationServiceConnector.participantJoinCommandReceived && this.privConversationServiceConnector.participantJoinCommandReceived(this.privConversationServiceConnector, new o.ParticipantEventArgs(O, h));
                  break;
                case "leavesession":
                  const G = {
                    id: f.participantId
                  };
                  this.privConversationServiceConnector.participantLeaveCommandReceived && this.privConversationServiceConnector.participantLeaveCommandReceived(this.privConversationServiceConnector, new o.ParticipantEventArgs(G, h));
                  break;
                case "disconnectsession":
                  const X = {
                    id: f.participantId
                  };
                  break;
                case "token":
                  const q = new n.CognitiveTokenAuthentication(() => {
                    const b = f.token;
                    return Promise.resolve(b);
                  }, () => {
                    const b = f.token;
                    return Promise.resolve(b);
                  });
                  this.authentication = q, this.privConversationServiceConnector.onToken(q);
                  break;
                default:
                  break;
              }
              break;
            case "partial":
            case "final":
              const m = i.SpeechResponsePayload.fromJSON(l.textBody), S = v === "final" ? e.ResultReason.TranslatedParticipantSpeech : e.ResultReason.TranslatingParticipantSpeech, y = new e.ConversationTranslationResult(m.participantId, this.getTranslations(m.translations), m.language, m.id, S, m.recognition, void 0, void 0, l.textBody, void 0);
              m.isFinal ? ((y.text !== void 0 && y.text.length > 0 || m.id === this.privLastPartialUtteranceId) && (g = !0), g && this.privConversationServiceConnector.translationReceived && this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new o.ConversationReceivedTranslationEventArgs(a.ConversationTranslatorMessageTypes.final, y, h))) : y.text !== void 0 && (this.privLastPartialUtteranceId = m.id, this.privConversationServiceConnector.translationReceived && this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new o.ConversationReceivedTranslationEventArgs(a.ConversationTranslatorMessageTypes.partial, y, h)));
              break;
            case "translated_message":
              const P = i.TextResponsePayload.fromJSON(l.textBody), C = new e.ConversationTranslationResult(P.participantId, this.getTranslations(P.translations), P.language, void 0, void 0, P.originalText, void 0, void 0, void 0, l.textBody, void 0);
              this.privConversationServiceConnector.translationReceived && this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new o.ConversationReceivedTranslationEventArgs(a.ConversationTranslatorMessageTypes.instantMessage, C, h));
              break;
            default:
              break;
          }
        } catch {
        }
        return this.receiveConversationMessageOverride();
      } catch {
        this.terminateMessageLoop = !0;
      }
      return p.promise;
    }
    async startMessageLoop() {
      if (this.isDisposed())
        return Promise.resolve();
      this.terminateMessageLoop = !1;
      const p = this.receiveConversationMessageOverride();
      try {
        return await p;
      } catch (d) {
        return this.cancelRecognition(this.privRequestSession ? this.privRequestSession.sessionId : "", this.privRequestSession ? this.privRequestSession.requestId : "", e.CancellationReason.Error, e.CancellationErrorCode.RuntimeError, d), null;
      }
    }
    // Takes an established websocket connection to the endpoint
    configConnection() {
      return this.isDisposed() ? Promise.resolve(void 0) : this.privConnectionConfigPromise !== void 0 ? this.privConnectionConfigPromise.then((p) => p.state() === t.ConnectionState.Disconnected ? (this.privConnectionId = null, this.privConnectionConfigPromise = void 0, this.configConnection()) : this.privConnectionConfigPromise, () => (this.privConnectionId = null, this.privConnectionConfigPromise = void 0, this.configConnection())) : this.terminateMessageLoop ? Promise.resolve(void 0) : (this.privConnectionConfigPromise = this.connectImpl().then((p) => p), this.privConnectionConfigPromise);
    }
    getTranslations(p) {
      let d;
      if (p !== void 0) {
        d = new e.Translations();
        for (const l of p)
          d.set(l.lang, l.translation);
      }
      return d;
    }
  };
  return qi.ConversationServiceAdapter = c, qi;
}
var Jl;
function VP() {
  if (Jl)
    return an;
  Jl = 1, Object.defineProperty(an, "__esModule", { value: !0 }), an.ConversationTranslatorRecognizer = an.ConversationRecognizerFactory = void 0;
  const t = A(), e = k(), n = N, r = R(), s = jP(), o = WP();
  class a {
    static fromConfig(u, p, d) {
      return new i(u, p, d);
    }
  }
  an.ConversationRecognizerFactory = a;
  let i = class extends r.Recognizer {
    constructor(u, p, d) {
      const l = p;
      n.Contracts.throwIfNull(l, "speechConfig");
      const h = u;
      n.Contracts.throwIfNull(h, "conversationImpl"), super(d, l.properties, new s.ConversationConnectionFactory()), this.privConversation = h, this.privIsDisposed = !1, this.privProperties = l.properties.clone(), this.privConnection = r.Connection.fromRecognizer(this), this.privProperties.getProperty(r.PropertyId.WebWorkerLoadType, "on").toLowerCase() === "on" && typeof Blob < "u" && typeof Worker < "u" ? (this.privSetTimeout = e.Timeout.setTimeout, this.privClearTimeout = e.Timeout.clearTimeout) : typeof window < "u" ? (this.privSetTimeout = window.setTimeout.bind(window), this.privClearTimeout = window.clearTimeout.bind(window)) : (this.privSetTimeout = setTimeout, this.privClearTimeout = clearTimeout);
    }
    set connected(u) {
      this.privConnection.connected = u;
    }
    set disconnected(u) {
      this.privConnection.disconnected = u;
    }
    /**
     * Return the speech language used by the recognizer
     */
    get speechRecognitionLanguage() {
      return this.privSpeechRecognitionLanguage;
    }
    /**
     * Return the properties for the recognizer
     */
    get properties() {
      return this.privProperties;
    }
    isDisposed() {
      return this.privIsDisposed;
    }
    /**
     * Connect to the recognizer
     * @param token
     */
    connect(u, p, d) {
      try {
        n.Contracts.throwIfDisposed(this.privIsDisposed), n.Contracts.throwIfNullOrWhitespace(u, "token"), this.privReco.conversationTranslatorToken = u, this.resetConversationTimeout(), this.privReco.connectAsync(p, d);
      } catch (l) {
        if (d)
          if (l instanceof Error) {
            const h = l;
            d(h.name + ": " + h.message);
          } else
            d(l);
      }
    }
    /**
     * Disconnect from the recognizer
     */
    disconnect(u, p) {
      try {
        n.Contracts.throwIfDisposed(this.privIsDisposed), this.privTimeoutToken !== void 0 && this.privClearTimeout(this.privTimeoutToken), this.privReco.disconnect().then(() => {
          u && u();
        }, (d) => {
          p && p(d);
        });
      } catch (d) {
        if (p)
          if (d instanceof Error) {
            const l = d;
            p(l.name + ": " + l.message);
          } else
            p(d);
        this.dispose(!0).catch((l) => {
          e.Events.instance.onEvent(new e.BackgroundEvent(l));
        });
      }
    }
    /**
     * Send the mute all participants command to the websocket
     * @param conversationId
     * @param participantId
     * @param isMuted
     */
    sendRequest(u, p, d) {
      try {
        n.Contracts.throwIfDisposed(this.privIsDisposed), this.sendMessage(u, p, d);
      } catch (l) {
        if (d)
          if (l instanceof Error) {
            const h = l;
            d(h.name + ": " + h.message);
          } else
            d(l);
        this.dispose(!0).catch((h) => {
          e.Events.instance.onEvent(new e.BackgroundEvent(h));
        });
      }
    }
    /**
     * Handle update of service auth token (#694)
     */
    onToken(u) {
      this.privConversation.onToken(u);
    }
    /**
     * Close and dispose the recognizer
     */
    async close() {
      this.privIsDisposed || (this.privConnection && (this.privConnection.closeConnection(), this.privConnection.close()), this.privConnection = void 0, await this.dispose(!0));
    }
    /**
     * Dispose the recognizer
     * @param disposing
     */
    async dispose(u) {
      this.privIsDisposed || u && (this.privTimeoutToken !== void 0 && this.privClearTimeout(this.privTimeoutToken), this.privIsDisposed = !0, this.privConnection && (this.privConnection.closeConnection(), this.privConnection.close(), this.privConnection = void 0), await super.dispose(u));
    }
    /**
     * Create the config for the recognizer
     * @param speechConfig
     */
    createRecognizerConfig(u) {
      return new t.RecognizerConfig(u, this.privProperties);
    }
    /**
     * Create the service recognizer.
     * The audio source is redundnant here but is required by the implementation.
     * @param authentication
     * @param connectionFactory
     * @param audioConfig
     * @param recognizerConfig
     */
    createServiceRecognizer(u, p, d, l) {
      const h = d;
      return new o.ConversationServiceAdapter(u, p, h, l, this);
    }
    sendMessage(u, p, d) {
      const l = this.privReco;
      ((v, g, f) => {
        v !== void 0 ? v.then(() => {
          try {
            g && g();
          } catch (m) {
            f && f(`'Unhandled error on promise callback: ${m}'`);
          }
        }, (m) => {
          try {
            f && f(m);
          } catch {
          }
        }) : f && f("Null promise");
      })(l.sendMessageAsync(u), p, d), this.resetConversationTimeout();
    }
    resetConversationTimeout() {
      this.privTimeoutToken !== void 0 && this.privClearTimeout(this.privTimeoutToken), this.privTimeoutToken = this.privSetTimeout(() => {
        this.sendRequest(this.privConversation.getKeepAlive());
      }, 6e4);
    }
  };
  return an.ConversationTranslatorRecognizer = i, an;
}
var Fi = {}, Gl;
function KP() {
  if (Gl)
    return Fi;
  Gl = 1, Object.defineProperty(Fi, "__esModule", { value: !0 }), Fi.TranscriberRecognizer = void 0;
  const t = k(), e = N, n = R(), r = A();
  let s = class extends n.Recognizer {
    /**
     * TranscriberRecognizer constructor.
     * @constructor
     * @param {SpeechTranslationConfig} speechTranslationConfig - Non-audio configuration associated with the recognizer
     * @param {AudioConfig} audioConfig - An audio configuration associated with the recognizer
     */
    constructor(a, i) {
      const c = a;
      e.Contracts.throwIfNull(c, "speechTranslationConfig");
      const u = i;
      e.Contracts.throwIfNull(u, "audioConfigImpl"), e.Contracts.throwIfNullOrWhitespace(c.speechRecognitionLanguage, n.PropertyId[n.PropertyId.SpeechServiceConnection_RecoLanguage]), super(i, c.properties, new r.TranscriberConnectionFactory()), this.privDisposedRecognizer = !1, this.isMeetingRecognizer = !1;
    }
    get speechRecognitionLanguage() {
      return e.Contracts.throwIfDisposed(this.privDisposedRecognizer), this.properties.getProperty(n.PropertyId.SpeechServiceConnection_RecoLanguage);
    }
    get properties() {
      return this.privProperties;
    }
    get authorizationToken() {
      return this.properties.getProperty(n.PropertyId.SpeechServiceAuthorization_Token);
    }
    set authorizationToken(a) {
      e.Contracts.throwIfNullOrWhitespace(a, "token"), this.properties.setProperty(n.PropertyId.SpeechServiceAuthorization_Token, a);
    }
    set conversation(a) {
      e.Contracts.throwIfNullOrUndefined(a, "Conversation"), this.isMeetingRecognizer = !1, this.privConversation = a;
    }
    getConversationInfo() {
      return e.Contracts.throwIfNullOrUndefined(this.privConversation, "Conversation"), this.privConversation.conversationInfo;
    }
    set meeting(a) {
      e.Contracts.throwIfNullOrUndefined(a, "Meeting"), this.isMeetingRecognizer = !0, this.privMeeting = a;
    }
    getMeetingInfo() {
      return e.Contracts.throwIfNullOrUndefined(this.privMeeting, "Meeting"), this.privMeeting.meetingInfo;
    }
    IsMeetingRecognizer() {
      return this.isMeetingRecognizer;
    }
    startContinuousRecognitionAsync(a, i) {
      t.marshalPromiseToCallbacks(this.startContinuousRecognitionAsyncImpl(r.RecognitionMode.Conversation), a, i);
    }
    stopContinuousRecognitionAsync(a, i) {
      t.marshalPromiseToCallbacks(this.stopContinuousRecognitionAsyncImpl(), a, i);
    }
    async close() {
      this.privDisposedRecognizer || await this.dispose(!0);
    }
    // Push async join/leave conversation message via serviceRecognizer
    async pushConversationEvent(a, i) {
      const c = this.privReco;
      e.Contracts.throwIfNullOrUndefined(c, "serviceRecognizer"), await c.sendSpeechEventAsync(a, i);
    }
    // Push async join/leave meeting message via serviceRecognizer
    async pushMeetingEvent(a, i) {
      const c = this.privReco;
      e.Contracts.throwIfNullOrUndefined(c, "serviceRecognizer"), await c.sendMeetingSpeechEventAsync(a, i);
    }
    async enforceAudioGating() {
      const c = (await this.audioConfig.format).channels;
      if (c === 1) {
        if (this.properties.getProperty("f0f5debc-f8c9-4892-ac4b-90a7ab359fd2", "false").toLowerCase() !== "true")
          throw new Error("Single channel audio configuration for MeetingTranscriber is currently under private preview, please contact diarizationrequest@microsoft.com for more details");
      } else if (c !== 8)
        throw new Error(`Unsupported audio configuration: Detected ${c}-channel audio`);
    }
    connectMeetingCallbacks(a) {
      this.isMeetingRecognizer = !0, this.canceled = (i, c) => {
        a.canceled && a.canceled(a, c);
      }, this.recognizing = (i, c) => {
        a.transcribing && a.transcribing(a, c);
      }, this.recognized = (i, c) => {
        a.transcribed && a.transcribed(a, c);
      }, this.sessionStarted = (i, c) => {
        a.sessionStarted && a.sessionStarted(a, c);
      }, this.sessionStopped = (i, c) => {
        a.sessionStopped && a.sessionStopped(a, c);
      };
    }
    disconnectCallbacks() {
      this.canceled = void 0, this.recognizing = void 0, this.recognized = void 0, this.sessionStarted = void 0, this.sessionStopped = void 0;
    }
    /**
     * Disposes any resources held by the object.
     * @member ConversationTranscriber.prototype.dispose
     * @function
     * @public
     * @param {boolean} disposing - true if disposing the object.
     */
    async dispose(a) {
      this.privDisposedRecognizer || (a && (this.privDisposedRecognizer = !0, await this.implRecognizerStop()), await super.dispose(a));
    }
    createRecognizerConfig(a) {
      return new r.RecognizerConfig(a, this.properties);
    }
    createServiceRecognizer(a, i, c, u) {
      const p = c;
      return new r.TranscriptionServiceRecognizer(a, i, p, u, this);
    }
  };
  return Fi.TranscriberRecognizer = s, Fi;
}
var Ql;
function JP() {
  return Ql || (Ql = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 });
    var e = DP();
    Object.defineProperty(t, "ConversationManager", { enumerable: !0, get: function() {
      return e.ConversationManager;
    } });
    var n = rr;
    Object.defineProperty(t, "ConversationConnectionConfig", { enumerable: !0, get: function() {
      return n.ConversationConnectionConfig;
    } });
    var r = VP();
    Object.defineProperty(t, "ConversationRecognizerFactory", { enumerable: !0, get: function() {
      return r.ConversationRecognizerFactory;
    } });
    var s = KP();
    Object.defineProperty(t, "TranscriberRecognizer", { enumerable: !0, get: function() {
      return s.TranscriberRecognizer;
    } });
    var o = vg();
    Object.defineProperty(t, "ConversationReceivedTranslationEventArgs", { enumerable: !0, get: function() {
      return o.ConversationReceivedTranslationEventArgs;
    } }), Object.defineProperty(t, "LockRoomEventArgs", { enumerable: !0, get: function() {
      return o.LockRoomEventArgs;
    } }), Object.defineProperty(t, "MuteAllEventArgs", { enumerable: !0, get: function() {
      return o.MuteAllEventArgs;
    } }), Object.defineProperty(t, "ParticipantAttributeEventArgs", { enumerable: !0, get: function() {
      return o.ParticipantAttributeEventArgs;
    } }), Object.defineProperty(t, "ParticipantEventArgs", { enumerable: !0, get: function() {
      return o.ParticipantEventArgs;
    } }), Object.defineProperty(t, "ParticipantsListEventArgs", { enumerable: !0, get: function() {
      return o.ParticipantsListEventArgs;
    } });
    var a = Rt;
    Object.defineProperty(t, "ConversationTranslatorCommandTypes", { enumerable: !0, get: function() {
      return a.ConversationTranslatorCommandTypes;
    } }), Object.defineProperty(t, "ConversationTranslatorMessageTypes", { enumerable: !0, get: function() {
      return a.ConversationTranslatorMessageTypes;
    } }), Object.defineProperty(t, "InternalParticipants", { enumerable: !0, get: function() {
      return a.InternalParticipants;
    } });
  }(Ec)), Ec;
}
var Xu = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.SynthesisAudioMetadata = t.MetadataType = void 0, function(n) {
    n.WordBoundary = "WordBoundary", n.Bookmark = "Bookmark", n.Viseme = "Viseme", n.SentenceBoundary = "SentenceBoundary", n.SessionEnd = "SessionEnd", n.AvatarSignal = "TalkingAvatarSignal";
  }(t.MetadataType || (t.MetadataType = {}));
  class e {
    constructor(r) {
      this.privSynthesisAudioMetadata = JSON.parse(r);
    }
    static fromJSON(r) {
      return new e(r);
    }
    get Metadata() {
      return this.privSynthesisAudioMetadata.Metadata;
    }
  }
  t.SynthesisAudioMetadata = e;
})(Xu);
var $i = {}, dt = {};
Object.defineProperty(dt, "__esModule", { value: !0 });
dt.SynthesisStartedEvent = dt.ConnectingToSynthesisServiceEvent = dt.SynthesisTriggeredEvent = dt.SpeechSynthesisEvent = void 0;
const Yl = k();
class $a extends Yl.PlatformEvent {
  constructor(e, n, r = Yl.EventType.Info) {
    super(e, r), this.privRequestId = n;
  }
  get requestId() {
    return this.privRequestId;
  }
}
dt.SpeechSynthesisEvent = $a;
class GP extends $a {
  constructor(e, n, r) {
    super("SynthesisTriggeredEvent", e), this.privSessionAudioDestinationId = n, this.privTurnAudioDestinationId = r;
  }
  get audioSessionDestinationId() {
    return this.privSessionAudioDestinationId;
  }
  get audioTurnDestinationId() {
    return this.privTurnAudioDestinationId;
  }
}
dt.SynthesisTriggeredEvent = GP;
class QP extends $a {
  constructor(e, n) {
    super("ConnectingToSynthesisServiceEvent", e), this.privAuthFetchEventId = n;
  }
  get authFetchEventId() {
    return this.privAuthFetchEventId;
  }
}
dt.ConnectingToSynthesisServiceEvent = QP;
class YP extends $a {
  constructor(e, n) {
    super("SynthesisStartedEvent", e), this.privAuthFetchEventId = n;
  }
  get authFetchEventId() {
    return this.privAuthFetchEventId;
  }
}
dt.SynthesisStartedEvent = YP;
var Zl;
function ZP() {
  if (Zl)
    return $i;
  Zl = 1, Object.defineProperty($i, "__esModule", { value: !0 }), $i.SynthesisTurn = void 0;
  const t = k(), e = Re, n = R(), r = Xu, s = dt;
  let o = class Yc {
    constructor() {
      this.privIsDisposed = !1, this.privIsSynthesizing = !1, this.privIsSynthesisEnded = !1, this.privBytesReceived = 0, this.privInTurn = !1, this.privTextOffset = 0, this.privNextSearchTextIndex = 0, this.privSentenceOffset = 0, this.privNextSearchSentenceIndex = 0, this.privRequestId = t.createNoDashGuid(), this.privTurnDeferral = new t.Deferred(), this.privTurnDeferral.resolve();
    }
    get requestId() {
      return this.privRequestId;
    }
    get streamId() {
      return this.privStreamId;
    }
    set streamId(i) {
      this.privStreamId = i;
    }
    get audioOutputFormat() {
      return this.privAudioOutputFormat;
    }
    set audioOutputFormat(i) {
      this.privAudioOutputFormat = i;
    }
    get turnCompletionPromise() {
      return this.privTurnDeferral.promise;
    }
    get isSynthesisEnded() {
      return this.privIsSynthesisEnded;
    }
    get isSynthesizing() {
      return this.privIsSynthesizing;
    }
    get currentTextOffset() {
      return this.privTextOffset;
    }
    get currentSentenceOffset() {
      return this.privSentenceOffset;
    }
    // The number of bytes received for current turn
    get bytesReceived() {
      return this.privBytesReceived;
    }
    get audioDuration() {
      return this.privAudioDuration;
    }
    get extraProperties() {
      if (this.privWebRTCSDP) {
        const i = new n.PropertyCollection();
        return i.setProperty(n.PropertyId.TalkingAvatarService_WebRTC_SDP, this.privWebRTCSDP), i;
      }
    }
    async getAllReceivedAudio() {
      return this.privReceivedAudio ? Promise.resolve(this.privReceivedAudio) : this.privIsSynthesisEnded ? (await this.readAllAudioFromStream(), Promise.resolve(this.privReceivedAudio)) : null;
    }
    async getAllReceivedAudioWithHeader() {
      if (this.privReceivedAudioWithHeader)
        return this.privReceivedAudioWithHeader;
      if (!this.privIsSynthesisEnded)
        return null;
      if (this.audioOutputFormat.hasHeader) {
        const i = await this.getAllReceivedAudio();
        return this.privReceivedAudioWithHeader = this.audioOutputFormat.addHeader(i), this.privReceivedAudioWithHeader;
      } else
        return this.getAllReceivedAudio();
    }
    startNewSynthesis(i, c, u, p) {
      this.privIsSynthesisEnded = !1, this.privIsSynthesizing = !0, this.privRequestId = i, this.privRawText = c, this.privIsSSML = u, this.privAudioOutputStream = new e.PullAudioOutputStreamImpl(), this.privAudioOutputStream.format = this.privAudioOutputFormat, this.privReceivedAudio = null, this.privReceivedAudioWithHeader = null, this.privBytesReceived = 0, this.privTextOffset = 0, this.privNextSearchTextIndex = 0, this.privSentenceOffset = 0, this.privNextSearchSentenceIndex = 0, this.privPartialVisemeAnimation = "", this.privWebRTCSDP = "", p !== void 0 && (this.privTurnAudioDestination = p, this.privTurnAudioDestination.format = this.privAudioOutputFormat), this.onEvent(new s.SynthesisTriggeredEvent(this.requestId, void 0, p === void 0 ? void 0 : p.id()));
    }
    onPreConnectionStart(i) {
      this.privAuthFetchEventId = i, this.onEvent(new s.ConnectingToSynthesisServiceEvent(this.privRequestId, this.privAuthFetchEventId));
    }
    onAuthCompleted(i) {
      i && this.onComplete();
    }
    onConnectionEstablishCompleted(i) {
      if (i === 200) {
        this.onEvent(new s.SynthesisStartedEvent(this.requestId, this.privAuthFetchEventId)), this.privBytesReceived = 0;
        return;
      } else
        i === 403 && this.onComplete();
    }
    onServiceResponseMessage(i) {
      const c = JSON.parse(i);
      this.streamId = c.audio.streamId;
    }
    onServiceTurnEndResponse() {
      this.privInTurn = !1, this.privTurnDeferral.resolve(), this.onComplete();
    }
    onServiceTurnStartResponse(i) {
      this.privTurnDeferral && this.privInTurn && (this.privTurnDeferral.reject("Another turn started before current completed."), this.privTurnDeferral.promise.then().catch(() => {
      })), this.privInTurn = !0, this.privTurnDeferral = new t.Deferred();
      const c = JSON.parse(i);
      c.webrtc && (this.privWebRTCSDP = c.webrtc.connectionString);
    }
    onAudioChunkReceived(i) {
      this.isSynthesizing && (this.privAudioOutputStream.write(i), this.privBytesReceived += i.byteLength, this.privTurnAudioDestination !== void 0 && this.privTurnAudioDestination.write(i));
    }
    onTextBoundaryEvent(i) {
      this.updateTextOffset(i.Data.text.Text, i.Type);
    }
    onVisemeMetadataReceived(i) {
      i.Data.AnimationChunk !== void 0 && (this.privPartialVisemeAnimation += i.Data.AnimationChunk);
    }
    onSessionEnd(i) {
      this.privAudioDuration = i.Data.Offset;
    }
    async constructSynthesisResult() {
      const i = await this.getAllReceivedAudioWithHeader();
      return new n.SpeechSynthesisResult(this.requestId, n.ResultReason.SynthesizingAudioCompleted, i, void 0, this.extraProperties, this.audioDuration);
    }
    dispose() {
      this.privIsDisposed || (this.privIsDisposed = !0);
    }
    onStopSynthesizing() {
      this.onComplete();
    }
    /**
     * Gets the viseme animation string (merged from animation chunk), and clears the internal
     * partial animation.
     */
    getAndClearVisemeAnimation() {
      const i = this.privPartialVisemeAnimation;
      return this.privPartialVisemeAnimation = "", i;
    }
    onEvent(i) {
      t.Events.instance.onEvent(i);
    }
    /**
     * Check if the text is an XML(SSML) tag
     * @param text
     * @private
     */
    static isXmlTag(i) {
      return i.length >= 2 && i[0] === "<" && i[i.length - 1] === ">";
    }
    updateTextOffset(i, c) {
      c === r.MetadataType.WordBoundary ? (this.privTextOffset = this.privRawText.indexOf(i, this.privNextSearchTextIndex), this.privTextOffset >= 0 && (this.privNextSearchTextIndex = this.privTextOffset + i.length, this.privIsSSML && this.withinXmlTag(this.privTextOffset) && !Yc.isXmlTag(i) && this.updateTextOffset(i, c))) : (this.privSentenceOffset = this.privRawText.indexOf(i, this.privNextSearchSentenceIndex), this.privSentenceOffset >= 0 && (this.privNextSearchSentenceIndex = this.privSentenceOffset + i.length, this.privIsSSML && this.withinXmlTag(this.privSentenceOffset) && !Yc.isXmlTag(i) && this.updateTextOffset(i, c)));
    }
    onComplete() {
      this.privIsSynthesizing && (this.privIsSynthesizing = !1, this.privIsSynthesisEnded = !0, this.privAudioOutputStream.close(), this.privInTurn = !1, this.privTurnAudioDestination !== void 0 && (this.privTurnAudioDestination.close(), this.privTurnAudioDestination = void 0));
    }
    async readAllAudioFromStream() {
      if (this.privIsSynthesisEnded) {
        this.privReceivedAudio = new ArrayBuffer(this.bytesReceived);
        try {
          await this.privAudioOutputStream.read(this.privReceivedAudio);
        } catch {
          this.privReceivedAudio = new ArrayBuffer(0);
        }
      }
    }
    /**
     * Check if current idx is in XML(SSML) tag
     * @param idx
     * @private
     */
    withinXmlTag(i) {
      return this.privRawText.indexOf("<", i + 1) > this.privRawText.indexOf(">", i + 1);
    }
  };
  return $i.SynthesisTurn = o, $i;
}
var Ui = {}, Xl;
function XP() {
  if (Xl)
    return Ui;
  Xl = 1, Object.defineProperty(Ui, "__esModule", { value: !0 }), Ui.SynthesisAdapterBase = void 0;
  const t = k(), e = R(), n = A(), r = It;
  let s = class {
    constructor(a, i, c, u) {
      if (this.speakOverride = void 0, this.receiveMessageOverride = void 0, this.connectImplOverride = void 0, this.configConnectionOverride = void 0, this.privConnectionConfigurationPromise = void 0, !a)
        throw new t.ArgumentNullError("authentication");
      if (!i)
        throw new t.ArgumentNullError("connectionFactory");
      if (!c)
        throw new t.ArgumentNullError("synthesizerConfig");
      this.privAuthentication = a, this.privConnectionFactory = i, this.privSynthesizerConfig = c, this.privIsDisposed = !1, this.privSessionAudioDestination = u, this.privSynthesisTurn = new n.SynthesisTurn(), this.privConnectionEvents = new t.EventSource(), this.privServiceEvents = new t.EventSource(), this.privSynthesisContext = new n.SynthesisContext(), this.privAgentConfig = new n.AgentConfig(), this.connectionEvents.attach((p) => {
        if (p.name === "ConnectionClosedEvent") {
          const d = p;
          d.statusCode !== 1e3 && this.cancelSynthesisLocal(e.CancellationReason.Error, d.statusCode === 1007 ? e.CancellationErrorCode.BadRequestParameters : e.CancellationErrorCode.ConnectionFailure, `${d.reason} websocket error code: ${d.statusCode}`);
        }
      });
    }
    get synthesisContext() {
      return this.privSynthesisContext;
    }
    get agentConfig() {
      return this.privAgentConfig;
    }
    get connectionEvents() {
      return this.privConnectionEvents;
    }
    get serviceEvents() {
      return this.privServiceEvents;
    }
    set activityTemplate(a) {
      this.privActivityTemplate = a;
    }
    get activityTemplate() {
      return this.privActivityTemplate;
    }
    set audioOutputFormat(a) {
      this.privAudioOutputFormat = a, this.privSynthesisTurn.audioOutputFormat = a, this.privSessionAudioDestination !== void 0 && (this.privSessionAudioDestination.format = a), this.synthesisContext !== void 0 && (this.synthesisContext.audioOutputFormat = a);
    }
    isDisposed() {
      return this.privIsDisposed;
    }
    async dispose(a) {
      this.privIsDisposed = !0, this.privSessionAudioDestination !== void 0 && this.privSessionAudioDestination.close(), this.privConnectionConfigurationPromise !== void 0 && await (await this.privConnectionConfigurationPromise).dispose(a);
    }
    async connect() {
      await this.connectImpl();
    }
    async sendNetworkMessage(a, i) {
      const c = typeof i == "string" ? t.MessageType.Text : t.MessageType.Binary, u = typeof i == "string" ? "application/json" : "";
      return (await this.fetchConnection()).send(new r.SpeechConnectionMessage(c, a, this.privSynthesisTurn.requestId, u, i));
    }
    async Speak(a, i, c, u, p, d) {
      let l;
      if (i ? l = a : l = this.privSynthesizer.buildSsml(a), this.speakOverride !== void 0)
        return this.speakOverride(l, c, u, p);
      this.privSuccessCallback = u, this.privErrorCallback = p, this.privSynthesisTurn.startNewSynthesis(c, a, i, d);
      try {
        await this.connectImpl();
        const h = await this.fetchConnection();
        await this.sendSynthesisContext(h), await this.sendSsmlMessage(h, l, c), this.onSynthesisStarted(c), this.receiveMessage();
      } catch (h) {
        return this.cancelSynthesisLocal(e.CancellationReason.Error, e.CancellationErrorCode.ConnectionFailure, h), Promise.reject(h);
      }
    }
    async stopSpeaking() {
      return await this.connectImpl(), (await this.fetchConnection()).send(new r.SpeechConnectionMessage(t.MessageType.Text, "synthesis.control", this.privSynthesisTurn.requestId, "application/json", JSON.stringify({
        action: "stop"
      })));
    }
    // Cancels synthesis.
    cancelSynthesis(a, i, c, u) {
      const p = new e.PropertyCollection();
      p.setProperty(n.CancellationErrorCodePropertyName, e.CancellationErrorCode[c]);
      const d = new e.SpeechSynthesisResult(a, e.ResultReason.Canceled, void 0, u, p);
      if (this.onSynthesisCancelled(d), this.privSuccessCallback)
        try {
          this.privSuccessCallback(d);
        } catch {
        }
    }
    // Cancels synthesis.
    cancelSynthesisLocal(a, i, c) {
      this.privSynthesisTurn.isSynthesizing && (this.privSynthesisTurn.onStopSynthesizing(), this.cancelSynthesis(this.privSynthesisTurn.requestId, a, i, c));
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    processTypeSpecificMessages(a) {
      return !0;
    }
    async receiveMessage() {
      try {
        const i = await (await this.fetchConnection()).read();
        if (this.receiveMessageOverride !== void 0)
          return this.receiveMessageOverride();
        if (this.privIsDisposed)
          return;
        if (!i)
          return this.privSynthesisTurn.isSynthesizing ? this.receiveMessage() : void 0;
        const c = r.SpeechConnectionMessage.fromConnectionMessage(i);
        if (c.requestId.toLowerCase() === this.privSynthesisTurn.requestId.toLowerCase())
          switch (c.path.toLowerCase()) {
            case "turn.start":
              this.privSynthesisTurn.onServiceTurnStartResponse(c.textBody);
              break;
            case "response":
              this.privSynthesisTurn.onServiceResponseMessage(c.textBody);
              break;
            case "audio":
              this.privSynthesisTurn.streamId.toLowerCase() === c.streamId.toLowerCase() && c.binaryBody && (this.privSynthesisTurn.onAudioChunkReceived(c.binaryBody), this.onSynthesizing(c.binaryBody), this.privSessionAudioDestination !== void 0 && this.privSessionAudioDestination.write(c.binaryBody));
              break;
            case "audio.metadata":
              const u = n.SynthesisAudioMetadata.fromJSON(c.textBody).Metadata;
              for (const d of u)
                switch (d.Type) {
                  case n.MetadataType.WordBoundary:
                  case n.MetadataType.SentenceBoundary:
                    this.privSynthesisTurn.onTextBoundaryEvent(d);
                    const l = new e.SpeechSynthesisWordBoundaryEventArgs(d.Data.Offset, d.Data.Duration, d.Data.text.Text, d.Data.text.Length, d.Type === n.MetadataType.WordBoundary ? this.privSynthesisTurn.currentTextOffset : this.privSynthesisTurn.currentSentenceOffset, d.Data.text.BoundaryType);
                    this.onWordBoundary(l);
                    break;
                  case n.MetadataType.Bookmark:
                    const h = new e.SpeechSynthesisBookmarkEventArgs(d.Data.Offset, d.Data.Bookmark);
                    this.onBookmarkReached(h);
                    break;
                  case n.MetadataType.Viseme:
                    if (this.privSynthesisTurn.onVisemeMetadataReceived(d), d.Data.IsLastAnimation) {
                      const v = new e.SpeechSynthesisVisemeEventArgs(d.Data.Offset, d.Data.VisemeId, this.privSynthesisTurn.getAndClearVisemeAnimation());
                      this.onVisemeReceived(v);
                    }
                    break;
                  case n.MetadataType.AvatarSignal:
                    this.onAvatarEvent(d);
                    break;
                  case n.MetadataType.SessionEnd:
                    this.privSynthesisTurn.onSessionEnd(d);
                    break;
                }
              break;
            case "turn.end":
              this.privSynthesisTurn.onServiceTurnEndResponse();
              let p;
              try {
                p = await this.privSynthesisTurn.constructSynthesisResult(), this.privSuccessCallback && this.privSuccessCallback(p);
              } catch (d) {
                this.privErrorCallback && this.privErrorCallback(d);
              }
              this.onSynthesisCompleted(p);
              break;
            default:
              this.processTypeSpecificMessages(c) || this.privServiceEvents && this.serviceEvents.onEvent(new t.ServiceEvent(c.path.toLowerCase(), c.textBody));
          }
        return this.receiveMessage();
      } catch {
      }
    }
    sendSynthesisContext(a) {
      this.setSynthesisContextSynthesisSection();
      const i = this.synthesisContext.toJSON();
      if (i)
        return a.send(new r.SpeechConnectionMessage(t.MessageType.Text, "synthesis.context", this.privSynthesisTurn.requestId, "application/json", i));
    }
    setSpeechConfigSynthesisSection() {
    }
    connectImpl(a = !1) {
      if (this.privConnectionPromise != null)
        return this.privConnectionPromise.then((c) => c.state() === t.ConnectionState.Disconnected ? (this.privConnectionId = null, this.privConnectionPromise = null, this.connectImpl()) : this.privConnectionPromise, () => (this.privConnectionId = null, this.privConnectionPromise = null, this.connectImpl()));
      this.privAuthFetchEventId = t.createNoDashGuid(), this.privConnectionId = t.createNoDashGuid(), this.privSynthesisTurn.onPreConnectionStart(this.privAuthFetchEventId);
      const i = a ? this.privAuthentication.fetchOnExpiry(this.privAuthFetchEventId) : this.privAuthentication.fetch(this.privAuthFetchEventId);
      return this.privConnectionPromise = i.then(async (c) => {
        this.privSynthesisTurn.onAuthCompleted(!1);
        const u = this.privConnectionFactory.create(this.privSynthesizerConfig, c, this.privConnectionId);
        u.events.attach((d) => {
          this.connectionEvents.onEvent(d);
        });
        const p = await u.open();
        return p.statusCode === 200 ? (this.privSynthesisTurn.onConnectionEstablishCompleted(p.statusCode), Promise.resolve(u)) : p.statusCode === 403 && !a ? this.connectImpl(!0) : (this.privSynthesisTurn.onConnectionEstablishCompleted(p.statusCode), Promise.reject(`Unable to contact server. StatusCode: ${p.statusCode},
                    ${this.privSynthesizerConfig.parameters.getProperty(e.PropertyId.SpeechServiceConnection_Url)} Reason: ${p.reason}`));
      }, (c) => {
        throw this.privSynthesisTurn.onAuthCompleted(!0), new Error(c);
      }), this.privConnectionPromise.catch(() => {
      }), this.privConnectionPromise;
    }
    sendSpeechServiceConfig(a, i) {
      if (i)
        return a.send(new r.SpeechConnectionMessage(t.MessageType.Text, "speech.config", this.privSynthesisTurn.requestId, "application/json", i));
    }
    sendSsmlMessage(a, i, c) {
      return a.send(new r.SpeechConnectionMessage(t.MessageType.Text, "ssml", c, "application/ssml+xml", i));
    }
    async fetchConnection() {
      return this.privConnectionConfigurationPromise !== void 0 ? this.privConnectionConfigurationPromise.then((a) => a.state() === t.ConnectionState.Disconnected ? (this.privConnectionId = null, this.privConnectionConfigurationPromise = void 0, this.fetchConnection()) : this.privConnectionConfigurationPromise, () => (this.privConnectionId = null, this.privConnectionConfigurationPromise = void 0, this.fetchConnection())) : (this.privConnectionConfigurationPromise = this.configureConnection(), await this.privConnectionConfigurationPromise);
    }
    // Takes an established websocket connection to the endpoint and sends speech configuration information.
    async configureConnection() {
      const a = await this.connectImpl();
      return this.configConnectionOverride !== void 0 ? this.configConnectionOverride(a) : (this.setSpeechConfigSynthesisSection(), await this.sendSpeechServiceConfig(a, this.privSynthesizerConfig.SpeechServiceConfig.serialize()), a);
    }
    onAvatarEvent(a) {
    }
    onSynthesisStarted(a) {
    }
    onSynthesizing(a) {
    }
    onSynthesisCancelled(a) {
    }
    onSynthesisCompleted(a) {
    }
    onWordBoundary(a) {
    }
    onVisemeReceived(a) {
    }
    onBookmarkReached(a) {
    }
  };
  return Ui.SynthesisAdapterBase = s, s.telemetryDataEnabled = !0, Ui;
}
var Hi = {}, eh;
function eE() {
  if (eh)
    return Hi;
  eh = 1, Object.defineProperty(Hi, "__esModule", { value: !0 }), Hi.AvatarSynthesisAdapter = void 0;
  const t = R(), e = A();
  let n = class extends e.SynthesisAdapterBase {
    constructor(s, o, a, i, c) {
      super(s, o, a, void 0), this.privAvatarSynthesizer = i, this.privSynthesizer = i, this.privAvatarConfig = c;
    }
    setSynthesisContextSynthesisSection() {
      this.privSynthesisContext.setSynthesisSection(void 0);
    }
    setSpeechConfigSynthesisSection() {
      var s, o, a, i, c, u, p, d, l, h, v, g, f, m, S, y, P;
      this.privSynthesizerConfig.synthesisVideoSection = {
        format: {
          bitrate: (s = this.privAvatarConfig.videoFormat) == null ? void 0 : s.bitrate,
          codec: (o = this.privAvatarConfig.videoFormat) == null ? void 0 : o.codec,
          crop: {
            bottomRight: {
              x: (c = (i = (a = this.privAvatarConfig.videoFormat) == null ? void 0 : a.cropRange) == null ? void 0 : i.bottomRight) == null ? void 0 : c.x,
              y: (d = (p = (u = this.privAvatarConfig.videoFormat) == null ? void 0 : u.cropRange) == null ? void 0 : p.bottomRight) == null ? void 0 : d.y
            },
            topLeft: {
              x: (v = (h = (l = this.privAvatarConfig.videoFormat) == null ? void 0 : l.cropRange) == null ? void 0 : h.topLeft) == null ? void 0 : v.x,
              y: (m = (f = (g = this.privAvatarConfig.videoFormat) == null ? void 0 : g.cropRange) == null ? void 0 : f.topLeft) == null ? void 0 : m.y
            }
          },
          resolution: {
            height: (S = this.privAvatarConfig.videoFormat) == null ? void 0 : S.height,
            width: (y = this.privAvatarConfig.videoFormat) == null ? void 0 : y.width
          }
        },
        protocol: {
          name: "WebRTC",
          webrtcConfig: {
            clientDescription: btoa(this.privSynthesizerConfig.parameters.getProperty(t.PropertyId.TalkingAvatarService_WebRTC_SDP)),
            iceServers: this.privAvatarConfig.remoteIceServers ?? this.privAvatarSynthesizer.iceServers
          }
        },
        talkingAvatar: {
          background: {
            color: this.privAvatarConfig.backgroundColor,
            image: {
              url: (P = this.privAvatarConfig.backgroundImage) == null ? void 0 : P.toString()
            }
          },
          character: this.privAvatarConfig.character,
          customized: this.privAvatarConfig.customized,
          style: this.privAvatarConfig.style
        }
      };
    }
    onAvatarEvent(s) {
      if (this.privAvatarSynthesizer.avatarEventReceived) {
        const o = new t.AvatarEventArgs(s.Data.Offset, s.Data.Name);
        try {
          this.privAvatarSynthesizer.avatarEventReceived(this.privAvatarSynthesizer, o);
        } catch {
        }
      }
    }
  };
  return Hi.AvatarSynthesisAdapter = n, Hi;
}
var Wi = {}, th;
function tE() {
  if (th)
    return Wi;
  th = 1, Object.defineProperty(Wi, "__esModule", { value: !0 }), Wi.SpeechSynthesisAdapter = void 0;
  const t = R(), e = A();
  let n = class extends e.SynthesisAdapterBase {
    constructor(s, o, a, i, c) {
      super(s, o, a, c), this.privSpeechSynthesizer = i, this.privSynthesizer = i;
    }
    setSynthesisContextSynthesisSection() {
      this.privSynthesisContext.setSynthesisSection(this.privSpeechSynthesizer);
    }
    onSynthesisStarted(s) {
      const o = new t.SpeechSynthesisEventArgs(new t.SpeechSynthesisResult(s, t.ResultReason.SynthesizingAudioStarted));
      this.privSpeechSynthesizer.synthesisStarted && this.privSpeechSynthesizer.synthesisStarted(this.privSpeechSynthesizer, o);
    }
    onSynthesizing(s) {
      if (this.privSpeechSynthesizer.synthesizing)
        try {
          const o = this.privSynthesisTurn.audioOutputFormat.addHeader(s), a = new t.SpeechSynthesisEventArgs(new t.SpeechSynthesisResult(this.privSynthesisTurn.requestId, t.ResultReason.SynthesizingAudio, o));
          this.privSpeechSynthesizer.synthesizing(this.privSpeechSynthesizer, a);
        } catch {
        }
    }
    onSynthesisCancelled(s) {
      if (this.privSpeechSynthesizer.SynthesisCanceled) {
        const o = new t.SpeechSynthesisEventArgs(s);
        try {
          this.privSpeechSynthesizer.SynthesisCanceled(this.privSpeechSynthesizer, o);
        } catch {
        }
      }
    }
    onSynthesisCompleted(s) {
      if (this.privSpeechSynthesizer.synthesisCompleted)
        try {
          this.privSpeechSynthesizer.synthesisCompleted(this.privSpeechSynthesizer, new t.SpeechSynthesisEventArgs(s));
        } catch {
        }
    }
    onWordBoundary(s) {
      if (this.privSpeechSynthesizer.wordBoundary)
        try {
          this.privSpeechSynthesizer.wordBoundary(this.privSpeechSynthesizer, s);
        } catch {
        }
    }
    onVisemeReceived(s) {
      if (this.privSpeechSynthesizer.visemeReceived)
        try {
          this.privSpeechSynthesizer.visemeReceived(this.privSpeechSynthesizer, s);
        } catch {
        }
    }
    onBookmarkReached(s) {
      if (this.privSpeechSynthesizer.bookmarkReached)
        try {
          this.privSpeechSynthesizer.bookmarkReached(this.privSpeechSynthesizer, s);
        } catch {
        }
    }
  };
  return Wi.SpeechSynthesisAdapter = n, Wi;
}
var Vi = {}, nh;
function nE() {
  if (nh)
    return Vi;
  nh = 1, Object.defineProperty(Vi, "__esModule", { value: !0 }), Vi.SynthesisRestAdapter = void 0;
  const t = ye(), e = R(), n = ot(), r = Se;
  let s = class {
    constructor(a, i) {
      let c = a.parameters.getProperty(e.PropertyId.SpeechServiceConnection_Endpoint, void 0);
      if (!c) {
        const p = a.parameters.getProperty(e.PropertyId.SpeechServiceConnection_Region, "westus"), d = n.ConnectionFactoryBase.getHostSuffix(p);
        c = a.parameters.getProperty(e.PropertyId.SpeechServiceConnection_Host, `https://${p}.tts.speech${d}`);
      }
      this.privUri = `${c}/cognitiveservices/voices/list`;
      const u = t.RestConfigBase.requestOptions;
      this.privRestAdapter = new t.RestMessageAdapter(u), this.privAuthentication = i;
    }
    /**
     * Sends list voices request to endpoint.
     * @function
     * @public
     * @param connectionId - guid for connectionId
     * @returns {Promise<IRestResponse>} rest response to status request
     */
    getVoicesList(a) {
      return this.privRestAdapter.setHeaders(r.HeaderNames.ConnectionId, a), this.privAuthentication.fetch(a).then((i) => (this.privRestAdapter.setHeaders(i.headerName, i.token), this.privRestAdapter.request(t.RestRequestType.Get, this.privUri)));
    }
  };
  return Vi.SynthesisRestAdapter = s, Vi;
}
var Ic = {}, rh;
function rE() {
  return rh || (rh = 1, function(t) {
    Object.defineProperty(t, "__esModule", { value: !0 }), t.SynthesizerConfig = t.SynthesisServiceType = void 0;
    const e = A();
    var n;
    (function(s) {
      s[s.Standard = 0] = "Standard", s[s.Custom = 1] = "Custom";
    })(n = t.SynthesisServiceType || (t.SynthesisServiceType = {}));
    class r {
      constructor(o, a) {
        this.privSynthesisServiceType = n.Standard, this.avatarEnabled = !1, this.privSpeechServiceConfig = o || new e.SpeechServiceConfig(new e.Context(null)), this.privParameters = a;
      }
      get parameters() {
        return this.privParameters;
      }
      get synthesisServiceType() {
        return this.privSynthesisServiceType;
      }
      set synthesisServiceType(o) {
        this.privSynthesisServiceType = o;
      }
      set synthesisVideoSection(o) {
        this.privSpeechServiceConfig.Context.synthesis = {
          video: o
        };
      }
      get SpeechServiceConfig() {
        return this.privSpeechServiceConfig;
      }
    }
    t.SynthesizerConfig = r;
  }(Ic)), Ic;
}
var Ki = {}, ih;
function iE() {
  if (ih)
    return Ki;
  ih = 1, Object.defineProperty(Ki, "__esModule", { value: !0 }), Ki.SynthesisContext = void 0;
  const t = R();
  let e = class {
    constructor() {
      this.privContext = {};
    }
    /**
     * Adds a section to the synthesis.context object.
     * @param sectionName Name of the section to add.
     * @param value JSON serializable object that represents the value.
     */
    setSection(r, s) {
      this.privContext[r] = s;
    }
    /**
     * Sets the audio output format for synthesis context generation.
     * @param format {AudioOutputFormatImpl} the output format
     */
    set audioOutputFormat(r) {
      this.privAudioOutputFormat = r;
    }
    toJSON() {
      return JSON.stringify(this.privContext);
    }
    setSynthesisSection(r) {
      const s = this.buildSynthesisContext(r);
      this.setSection("synthesis", s);
    }
    buildSynthesisContext(r) {
      return {
        audio: {
          metadataOptions: {
            bookmarkEnabled: !!(r != null && r.bookmarkReached),
            punctuationBoundaryEnabled: r == null ? void 0 : r.properties.getProperty(t.PropertyId.SpeechServiceResponse_RequestPunctuationBoundary, !!(r != null && r.wordBoundary)),
            sentenceBoundaryEnabled: r == null ? void 0 : r.properties.getProperty(t.PropertyId.SpeechServiceResponse_RequestSentenceBoundary, !1),
            sessionEndEnabled: !0,
            visemeEnabled: !!(r != null && r.visemeReceived),
            wordBoundaryEnabled: r == null ? void 0 : r.properties.getProperty(t.PropertyId.SpeechServiceResponse_RequestWordBoundary, !!(r != null && r.wordBoundary))
          },
          outputFormat: this.privAudioOutputFormat.requestAudioFormatString
        },
        language: {
          autoDetection: r == null ? void 0 : r.autoDetectSourceLanguage
        }
      };
    }
  };
  return Ki.SynthesisContext = e, Ki;
}
var Ji = {}, sh;
function sE() {
  if (sh)
    return Ji;
  sh = 1, Object.defineProperty(Ji, "__esModule", { value: !0 }), Ji.SpeakerRecognitionConfig = void 0;
  const t = A();
  let e = class {
    constructor(r, s) {
      this.privContext = r || new t.Context(null), this.privParameters = s;
    }
    get parameters() {
      return this.privParameters;
    }
    get Context() {
      return this.privContext;
    }
  };
  return Ji.SpeakerRecognitionConfig = e, Ji;
}
var Gi = {}, oh;
function oE() {
  if (oh)
    return Gi;
  oh = 1, Object.defineProperty(Gi, "__esModule", { value: !0 }), Gi.SpeakerServiceRecognizer = void 0;
  const t = ye(), e = k(), n = R(), r = A(), s = It;
  let o = class extends r.ServiceRecognizerBase {
    constructor(i, c, u, p, d) {
      super(i, c, u, p, d), this.privSpeakerRecognizer = d, this.privSpeakerAudioSource = u, this.recognizeSpeaker = (l) => this.recognizeSpeakerOnce(l), this.sendPrePayloadJSONOverride = () => this.noOp();
    }
    processTypeSpecificMessages(i) {
      let c = !1;
      const u = new n.PropertyCollection();
      switch (i.messageType === e.MessageType.Text && u.setProperty(n.PropertyId.SpeechServiceResponse_JsonResult, i.textBody), i.path.toLowerCase()) {
        case "speaker.response":
          const d = JSON.parse(i.textBody);
          let l;
          d.status.statusCode.toLowerCase() !== "success" ? l = new n.SpeakerRecognitionResult(d, n.ResultReason.Canceled, n.CancellationErrorCode.ServiceError, d.status.reason) : l = new n.SpeakerRecognitionResult(d, n.ResultReason.RecognizedSpeaker), this.privResultDeferral && this.privResultDeferral.resolve(l), c = !0;
          break;
      }
      const p = new e.Deferred();
      return p.resolve(c), p.promise;
    }
    // Cancels recognition.
    cancelRecognition(i, c, u, p, d) {
      if (new n.PropertyCollection().setProperty(r.CancellationErrorCodePropertyName, n.CancellationErrorCode[p]), this.privResultDeferral) {
        const h = new n.SpeakerRecognitionResult({
          scenario: this.privSpeakerModel.scenario,
          status: { statusCode: d, reason: d }
        }, n.ResultReason.Canceled, p, d);
        try {
          this.privResultDeferral.resolve(h);
        } catch (v) {
          this.privResultDeferral.reject(v);
        }
      }
    }
    async recognizeSpeakerOnce(i) {
      this.privSpeakerModel = i, this.voiceProfileType = i.scenario, this.privResultDeferral || (this.privResultDeferral = new e.Deferred()), this.privRequestSession.startNewRecognition(), this.privRequestSession.listenForServiceTelemetry(this.privSpeakerAudioSource.events), this.privRecognizerConfig.parameters.setProperty(n.PropertyId.Speech_SessionId, this.privRequestSession.sessionId);
      const c = this.connectImpl(), u = this.sendPreAudioMessages(this.extractSpeakerContext(i)), p = await this.privSpeakerAudioSource.attach(this.privRequestSession.audioNodeId), d = await this.privSpeakerAudioSource.format, l = await this.privSpeakerAudioSource.deviceInfo, h = new t.ReplayableAudioNode(p, d.avgBytesPerSec);
      await this.privRequestSession.onAudioSourceAttachCompleted(h, !1), this.privRecognizerConfig.SpeechServiceConfig.Context.audio = { source: l };
      try {
        await c, await u;
      } catch (f) {
        this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, n.CancellationReason.Error, n.CancellationErrorCode.ConnectionFailure, f);
      }
      const v = new n.SessionEventArgs(this.privRequestSession.sessionId);
      return this.privRecognizer.sessionStarted && this.privRecognizer.sessionStarted(this.privRecognizer, v), this.receiveMessage(), this.sendAudio(h).then(() => {
      }, (f) => {
        this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, n.CancellationReason.Error, n.CancellationErrorCode.RuntimeError, f);
      }), this.privResultDeferral.promise;
    }
    async sendPreAudioMessages(i) {
      const c = await this.fetchConnection();
      await this.sendSpeakerRecognition(c, i);
    }
    async sendSpeakerRecognition(i, c) {
      const u = JSON.stringify(c);
      return i.send(new s.SpeechConnectionMessage(e.MessageType.Text, "speaker.context", this.privRequestSession.requestId, "application/json; charset=utf-8", u));
    }
    extractSpeakerContext(i) {
      return {
        features: {
          interimResult: "enabled",
          progressiveDetection: "disabled"
        },
        profileIds: i.profileIds,
        scenario: i.scenario
      };
    }
  };
  return Gi.SpeakerServiceRecognizer = o, Gi;
}
var Qi = {}, ah;
function aE() {
  if (ah)
    return Qi;
  ah = 1, Object.defineProperty(Qi, "__esModule", { value: !0 }), Qi.VoiceServiceRecognizer = void 0;
  const t = ye(), e = k(), n = R(), r = A(), s = It;
  let o = class extends r.ServiceRecognizerBase {
    constructor(i, c, u, p, d) {
      super(i, c, u, p, d), this.privDeferralMap = new e.DeferralMap(), this.privSpeakerAudioSource = u, this.sendPrePayloadJSONOverride = () => this.noOp();
    }
    set SpeakerAudioSource(i) {
      this.privSpeakerAudioSource = i;
    }
    processTypeSpecificMessages(i) {
      let c = !1;
      const u = new n.PropertyCollection();
      switch (i.messageType === e.MessageType.Text && u.setProperty(n.PropertyId.SpeechServiceResponse_JsonResult, i.textBody), i.path.toLowerCase()) {
        case "speaker.profiles":
          const d = JSON.parse(i.textBody);
          switch (d.operation.toLowerCase()) {
            case "create":
              this.handleCreateResponse(d, i.requestId);
              break;
            case "delete":
            case "reset":
              this.handleResultResponse(d, i.requestId);
              break;
            case "fetch":
              const g = JSON.parse(i.textBody);
              this.handleFetchResponse(g, i.requestId);
              break;
          }
          c = !0;
          break;
        case "speaker.phrases":
          const l = JSON.parse(i.textBody);
          this.handlePhrasesResponse(l, i.requestId), c = !0;
          break;
        case "speaker.profile.enrollment":
          const h = JSON.parse(i.textBody), v = new n.VoiceProfileEnrollmentResult(this.enrollmentReasonFrom(h.enrollment ? h.enrollment.enrollmentStatus : h.status.statusCode), h.enrollment ? JSON.stringify(h.enrollment) : void 0, h.status.reason);
          this.privDeferralMap.getId(i.requestId) && this.privDeferralMap.complete(i.requestId, v), this.privRequestSession.onSpeechEnded(), c = !0;
          break;
      }
      const p = new e.Deferred();
      return p.resolve(c), p.promise;
    }
    // Cancels recognition.
    cancelRecognition(i, c, u, p, d) {
      new n.PropertyCollection().setProperty(r.CancellationErrorCodePropertyName, n.CancellationErrorCode[p]);
      const h = new n.VoiceProfileEnrollmentResult(n.ResultReason.Canceled, d, d);
      this.privDeferralMap.getId(c) && this.privDeferralMap.complete(c, h);
    }
    async createProfile(i, c) {
      this.voiceProfileType = i.toString();
      const u = this.connectImpl();
      try {
        const p = new e.Deferred();
        return await u, await this.sendCreateProfile(p, i, c), this.receiveMessage(), p.promise;
      } catch (p) {
        throw p;
      }
    }
    async resetProfile(i) {
      return this.voiceProfileType = i.profileType.toString(), this.sendCommonRequest("reset", i.profileType, i);
    }
    async deleteProfile(i) {
      return this.voiceProfileType = i.profileType.toString(), this.sendCommonRequest("delete", i.profileType, i);
    }
    async retrieveEnrollmentResult(i) {
      return this.voiceProfileType = i.profileType.toString(), this.privExpectedProfileId = i.profileId, this.sendCommonRequest("fetch", i.profileType, i);
    }
    async getAllProfiles(i) {
      return this.voiceProfileType = i.toString(), this.sendCommonRequest("fetch", i);
    }
    async getActivationPhrases(i, c) {
      this.voiceProfileType = i.toString();
      const u = this.connectImpl();
      try {
        const p = new e.Deferred();
        return await u, await this.sendPhrasesRequest(p, i, c), this.receiveMessage(), p.promise;
      } catch (p) {
        throw p;
      }
    }
    async enrollProfile(i) {
      this.voiceProfileType = i.profileType.toString();
      const c = new e.Deferred();
      this.privRequestSession.startNewRecognition(), this.privRequestSession.listenForServiceTelemetry(this.privSpeakerAudioSource.events), this.privRecognizerConfig.parameters.setProperty(n.PropertyId.Speech_SessionId, this.privRequestSession.sessionId);
      const u = this.connectImpl(), p = this.sendPreAudioMessages(i, c), d = await this.privSpeakerAudioSource.attach(this.privRequestSession.audioNodeId), l = await this.privSpeakerAudioSource.format, h = await this.privSpeakerAudioSource.deviceInfo, v = new t.ReplayableAudioNode(d, l.avgBytesPerSec);
      await this.privRequestSession.onAudioSourceAttachCompleted(v, !1), this.privRecognizerConfig.SpeechServiceConfig.Context.audio = { source: h };
      try {
        await u, await p;
      } catch (m) {
        this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, n.CancellationReason.Error, n.CancellationErrorCode.ConnectionFailure, m);
      }
      const g = new n.SessionEventArgs(this.privRequestSession.sessionId);
      return this.privRecognizer.sessionStarted && this.privRecognizer.sessionStarted(this.privRecognizer, g), this.receiveMessage(), this.sendAudio(v).then(() => {
      }, (m) => {
        this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, n.CancellationReason.Error, n.CancellationErrorCode.RuntimeError, m);
      }), c.promise;
    }
    async sendPreAudioMessages(i, c) {
      const u = await this.fetchConnection();
      this.privRequestSession.onSpeechContext(), this.privDeferralMap.add(this.privRequestSession.requestId, c), await this.sendBaseRequest(u, "enroll", this.scenarioFrom(i.profileType), i);
    }
    async sendPhrasesRequest(i, c, u) {
      const p = await this.fetchConnection();
      this.privRequestSession.onSpeechContext(), this.privDeferralMap.add(this.privRequestSession.requestId, i);
      const d = this.scenarioFrom(c), l = {
        locale: u,
        scenario: d
      };
      return p.send(new s.SpeechConnectionMessage(e.MessageType.Text, "speaker.profile.phrases", this.privRequestSession.requestId, "application/json; charset=utf-8", JSON.stringify(l)));
    }
    async sendCreateProfile(i, c, u) {
      const p = await this.fetchConnection();
      this.privRequestSession.onSpeechContext(), this.privDeferralMap.add(this.privRequestSession.requestId, i);
      const d = c === n.VoiceProfileType.TextIndependentIdentification ? "TextIndependentIdentification" : c === n.VoiceProfileType.TextIndependentVerification ? "TextIndependentVerification" : "TextDependentVerification", l = {
        locale: u,
        number: "1",
        scenario: d
      };
      return p.send(new s.SpeechConnectionMessage(e.MessageType.Text, "speaker.profile.create", this.privRequestSession.requestId, "application/json; charset=utf-8", JSON.stringify(l)));
    }
    async sendCommonRequest(i, c, u = void 0) {
      const p = this.connectImpl();
      try {
        const d = new e.Deferred();
        this.privRequestSession.onSpeechContext(), await p;
        const l = await this.fetchConnection();
        return this.privDeferralMap.add(this.privRequestSession.requestId, d), await this.sendBaseRequest(l, i, this.scenarioFrom(c), u), this.receiveMessage(), d.promise;
      } catch (d) {
        throw d;
      }
    }
    async sendBaseRequest(i, c, u, p) {
      const d = {
        scenario: u
      };
      return p ? d.profileIds = [p.profileId] : d.maxPageSize = -1, i.send(new s.SpeechConnectionMessage(e.MessageType.Text, `speaker.profile.${c}`, this.privRequestSession.requestId, "application/json; charset=utf-8", JSON.stringify(d)));
    }
    extractSpeakerContext(i) {
      return {
        features: {
          interimResult: "enabled",
          progressiveDetection: "disabled"
        },
        profileIds: i.profileIds,
        scenario: i.scenario
      };
    }
    handlePhrasesResponse(i, c) {
      if (this.privDeferralMap.getId(c))
        if (i.status.statusCode.toLowerCase() !== "success") {
          const u = n.ResultReason.Canceled, p = new n.VoiceProfilePhraseResult(u, i.status.statusCode, i.passPhraseType, []);
          this.privDeferralMap.complete(c, p);
        } else if (i.phrases && i.phrases.length > 0) {
          const u = n.ResultReason.EnrollingVoiceProfile, p = new n.VoiceProfilePhraseResult(u, i.status.statusCode, i.passPhraseType, i.phrases);
          this.privDeferralMap.complete(c, p);
        } else
          throw new Error("Voice Profile get activation phrases failed, no phrases received");
      else
        throw new Error(`Voice Profile get activation phrases request for requestID ${c} not found`);
    }
    handleCreateResponse(i, c) {
      if (i.profiles && i.profiles.length > 0)
        if (this.privDeferralMap.getId(c)) {
          const u = i.profiles.map((p) => p.profileId);
          this.privDeferralMap.complete(c, u);
        } else
          throw new Error(`Voice Profile create request for requestID ${c} not found`);
      else
        throw new Error("Voice Profile create failed, no profile id received");
    }
    handleResultResponse(i, c) {
      if (this.privDeferralMap.getId(c)) {
        const u = i.operation.toLowerCase() === "delete" ? n.ResultReason.DeletedVoiceProfile : n.ResultReason.ResetVoiceProfile, p = i.status.statusCode.toLowerCase() === "success" ? u : n.ResultReason.Canceled, d = new n.VoiceProfileResult(p, `statusCode: ${i.status.statusCode}, errorDetails: ${i.status.reason}`);
        this.privDeferralMap.complete(c, d);
      } else
        throw new Error(`Voice Profile create request for requestID ${c} not found`);
    }
    handleFetchResponse(i, c) {
      if (this.privDeferralMap.getId(c) && i.profiles[0]) {
        if (this.privExpectedProfileId && i.profiles.length === 1 && i.profiles[0].profileId === this.privExpectedProfileId) {
          this.privExpectedProfileId = void 0;
          const u = i.profiles[0], p = new n.VoiceProfileEnrollmentResult(this.enrollmentReasonFrom(u.enrollmentStatus), JSON.stringify(u), i.status.reason);
          this.privDeferralMap.complete(c, p);
        } else if (i.profiles.length > 0) {
          const u = i.profiles, p = [];
          for (const d of u)
            p.push(new n.VoiceProfileEnrollmentResult(this.enrollmentReasonFrom(d.enrollmentStatus), JSON.stringify(d), i.status.reason));
          this.privDeferralMap.complete(c, p);
        }
      } else
        throw new Error(`Voice Profile fetch request for requestID ${c} not found`);
    }
    enrollmentReasonFrom(i) {
      switch (i.toLowerCase()) {
        case "enrolled":
          return n.ResultReason.EnrolledVoiceProfile;
        case "invalidlocale":
        case "invalidphrase":
        case "invalidaudioformat":
        case "invalidscenario":
        case "invalidprofilecount":
        case "invalidoperation":
        case "audiotooshort":
        case "audiotoolong":
        case "toomanyenrollments":
        case "storageconflict":
        case "profilenotfound":
        case "incompatibleprofiles":
        case "incompleteenrollment":
          return n.ResultReason.Canceled;
        default:
          return n.ResultReason.EnrollingVoiceProfile;
      }
    }
    scenarioFrom(i) {
      return i === n.VoiceProfileType.TextIndependentIdentification ? "TextIndependentIdentification" : i === n.VoiceProfileType.TextIndependentVerification ? "TextIndependentVerification" : "TextDependentVerification";
    }
  };
  return Qi.VoiceServiceRecognizer = o, Qi;
}
var gg = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.type = t.connectivity = t.Device = t.OS = t.System = t.Context = t.SpeechServiceConfig = void 0;
  class e {
    constructor(i) {
      this.context = i;
    }
    serialize() {
      return JSON.stringify(this, (i, c) => {
        if (c && typeof c == "object" && !Array.isArray(c)) {
          const u = {};
          for (const p in c)
            Object.hasOwnProperty.call(c, p) && (u[p && p.charAt(0).toLowerCase() + p.substring(1)] = c[p]);
          return u;
        }
        return c;
      });
    }
    get Context() {
      return this.context;
    }
    get Recognition() {
      return this.recognition;
    }
    set Recognition(i) {
      this.recognition = i.toLowerCase();
    }
  }
  t.SpeechServiceConfig = e;
  class n {
    constructor(i) {
      this.system = new r(), this.os = i;
    }
  }
  t.Context = n;
  class r {
    constructor() {
      const i = "1.42.0";
      this.name = "SpeechSDK", this.version = i, this.build = "JavaScript", this.lang = "JavaScript";
    }
  }
  t.System = r;
  class s {
    constructor(i, c, u) {
      this.platform = i, this.name = c, this.version = u;
    }
  }
  t.OS = s;
  class o {
    constructor(i, c, u) {
      this.manufacturer = i, this.model = c, this.version = u;
    }
  }
  t.Device = o, function(a) {
    a.Bluetooth = "Bluetooth", a.Wired = "Wired", a.WiFi = "WiFi", a.Cellular = "Cellular", a.InBuilt = "InBuilt", a.Unknown = "Unknown";
  }(t.connectivity || (t.connectivity = {})), function(a) {
    a.Phone = "Phone", a.Speaker = "Speaker", a.Car = "Car", a.Headset = "Headset", a.Thermostat = "Thermostat", a.Microphones = "Microphones", a.Deskphone = "Deskphone", a.RemoteControl = "RemoteControl", a.Unknown = "Unknown", a.File = "File", a.Stream = "Stream";
  }(t.type || (t.type = {}));
})(gg);
var ch;
function A() {
  return ch || (ch = 1, function(t) {
    var e = W && W.__createBinding || (Object.create ? function(o, a, i, c) {
      c === void 0 && (c = i), Object.defineProperty(o, c, { enumerable: !0, get: function() {
        return a[i];
      } });
    } : function(o, a, i, c) {
      c === void 0 && (c = i), o[c] = a[i];
    }), n = W && W.__exportStar || function(o, a) {
      for (var i in o)
        i !== "default" && !a.hasOwnProperty(i) && e(a, o, i);
    };
    Object.defineProperty(t, "__esModule", { value: !0 }), t.AutoDetectSourceLanguagesOpenRangeOptionName = t.ForceDictationPropertyName = t.ServicePropertiesPropertyName = t.CancellationErrorCodePropertyName = t.OutputFormatPropertyName = void 0, n(Ao, t), n(Qo, t), n(nr, t), n(vf, t), n(ff, t), n(YR(), t), n(ZR(), t), n(Ea, t), n(XR(), t), n(eP(), t), n(tP(), t), n(ag, t), n(Ta, t), n(rP(), t), n(iP(), t), n(sP(), t), n(oP(), t), n(ig(), t), n(aP(), t), n(cg, t), n(cP(), t), n(Ia, t), n(pP(), t), n(dP(), t), n(wa, t), n(ba, t), n(Aa, t), n(lP(), t), n(hP(), t), n(vP(), t), n(fP(), t), n(gP(), t), n(Ma, t), n(SP(), t), n(ka, t), n(lg, t), n(Oa, t), n(Na, t), n(La, t), n(hg, t), n(MP(), t), n(xa, t), n(JP(), t), n(Xu, t), n(ZP(), t), n(XP(), t);
    var r = eE();
    Object.defineProperty(t, "AvatarSynthesisAdapter", { enumerable: !0, get: function() {
      return r.AvatarSynthesisAdapter;
    } });
    var s = tE();
    Object.defineProperty(t, "SpeechSynthesisAdapter", { enumerable: !0, get: function() {
      return s.SpeechSynthesisAdapter;
    } }), n(nE(), t), n(rE(), t), n(iE(), t), n(sE(), t), n(oE(), t), n(aE(), t), n(gg, t), t.OutputFormatPropertyName = "OutputFormat", t.CancellationErrorCodePropertyName = "CancellationErrorCode", t.ServicePropertiesPropertyName = "ServiceProperties", t.ForceDictationPropertyName = "ForceDictation", t.AutoDetectSourceLanguagesOpenRangeOptionName = "OpenRange";
  }(oc)), oc;
}
(function(t) {
  var e = W && W.__createBinding || (Object.create ? function(s, o, a, i) {
    i === void 0 && (i = a), Object.defineProperty(s, i, { enumerable: !0, get: function() {
      return o[a];
    } });
  } : function(s, o, a, i) {
    i === void 0 && (i = a), s[i] = o[a];
  }), n = W && W.__exportStar || function(s, o) {
    for (var a in s)
      a !== "default" && !o.hasOwnProperty(a) && e(o, s, a);
  };
  Object.defineProperty(t, "__esModule", { value: !0 });
  const r = A();
  new r.AgentConfig(), n(R(), t);
})(jn);
const uh = "DID_AGENT_STT_TOKEN", mg = 1e3 * 60 * 9, cE = () => {
  const {
    agentManager: t
  } = je(Pn);
  return mn(async () => {
    const e = JSON.parse(localStorage.getItem(uh) ?? "null"), n = (/* @__PURE__ */ new Date()).getTime();
    if (e && n < e.expiry)
      return e;
    const r = await (t == null ? void 0 : t.getSTTToken()), s = {
      token: r,
      expiry: n + mg
    };
    return r && localStorage.setItem(uh, JSON.stringify(s)), s;
  }, [t == null ? void 0 : t.getSTTToken]);
};
class uE {
  constructor({
    events: e,
    getSTTToken: n
  }) {
    Ne(this, "events");
    Ne(this, "getSTTToken");
    Ne(this, "recognizer");
    Ne(this, "intervalId");
    Ne(this, "isCancelled");
    Ne(this, "isDestroyed");
    Ne(this, "initEvents", () => {
      this.recognizer && (this.recognizer.recognized = (e, n) => {
        var r, s, o;
        this.isCancelled || (this.events.onresult(n), (r = this.recognizer) == null || r.stopContinuousRecognitionAsync()), this.isCancelled = !1, (o = (s = this.events).onend) == null || o.call(s);
      }, this.recognizer.canceled = (e, n) => {
        var r, s;
        (s = (r = this.events).onerror) == null || s.call(r, n);
      });
    });
    Ne(this, "refreshToken", async () => {
      var n, r;
      if (this.isDestroyed)
        return;
      const e = await this.getSTTToken();
      e.token && ((n = this.recognizer) == null || n.properties.setProperty(jn.PropertyId.SpeechServiceConnection_Region, e.token.token), (r = this.recognizer) == null || r.properties.setProperty(jn.PropertyId.SpeechServiceAuthorization_Token, e.token.region));
    });
    Ne(this, "initTokenRefreshInterval", (e) => {
      const n = (/* @__PURE__ */ new Date()).getTime();
      window.setTimeout(() => {
        this.isDestroyed || (this.refreshToken(), this.intervalId = window.setInterval(this.refreshToken, mg));
      }, e - n + 1);
    });
    Ne(this, "init", async (e) => {
      const n = await this.getSTTToken();
      if (!(n != null && n.token))
        return;
      const r = jn.AudioConfig.fromDefaultMicrophoneInput(), s = jn.SpeechConfig.fromAuthorizationToken(n.token.token, n.token.region);
      s.speechRecognitionLanguage = e, this.recognizer = new jn.SpeechRecognizer(s, r), this.initEvents(), this.initTokenRefreshInterval(n.expiry);
    });
    Ne(this, "start", () => {
      var e, n, r;
      this.isCancelled = !1, (n = (e = this.events).onstart) == null || n.call(e), (r = this.recognizer) == null || r.startContinuousRecognitionAsync();
    });
    Ne(this, "stop", () => {
      var e;
      (e = this.recognizer) == null || e.stopContinuousRecognitionAsync();
    });
    Ne(this, "abort", () => {
      var e;
      this.isCancelled = !0, (e = this.recognizer) == null || e.stopContinuousRecognitionAsync();
    });
    /**
     * Destroy the recognizer. This is needed to avoid memory leaks.
     * If you need to use the recognizer again, you need to create a new instance.
     */
    Ne(this, "destroy", () => {
      var e, n;
      this.isDestroyed = !0, (e = this.recognizer) == null || e.stopContinuousRecognitionAsync(), (n = this.recognizer) == null || n.close(), this.recognizer = void 0, window.clearInterval(this.intervalId);
    });
    this.events = e, this.getSTTToken = n, this.isCancelled = !1, this.isDestroyed = !1;
  }
}
const ph = [{
  label: "Arabic",
  value: "ar-SA",
  equivalentValues: ["ar-AE", "ar-BH", "ar-DZ", "ar-EG", "ar-IL", "ar-IQ", "ar-JO", "ar-KW", "ar-LB", "ar-LY", "ar-MA", "ar-OM", "ar-PS", "ar-QA", "ar-SA", "ar-SY", "ar-TN", "ar-YE"]
}, {
  label: "Bulgarian",
  value: "bg-BG",
  equivalentValues: ["bg-BG"]
}, {
  label: "Chinese",
  value: "zh-CN",
  equivalentValues: ["wuu-CN", "yue-CN", "zh-CN", "zh-CN-shandong", "zh-CN-sichuan", "zh-HK", "zh-TW"]
}, {
  label: "Croatian",
  value: "hr-HR",
  equivalentValues: ["hr-HR"]
}, {
  label: "Czech",
  value: "cs-CZ",
  equivalentValues: ["cs-CZ"]
}, {
  label: "Danish",
  value: "da-DK",
  equivalentValues: ["da-DK"]
}, {
  label: "Dutch",
  value: "nl-NL",
  equivalentValues: ["nl-NL", "nl-BE"]
}, {
  label: "English",
  value: "en-US",
  equivalentValues: ["en-AU", "en-CA", "en-GB", "en-GH", "en-HK", "en-IE", "en-IN", "en-KE", "en-NG", "en-NZ", "en-PH", "en-SG", "en-TZ", "en-US", "en-ZA"]
}, {
  label: "Filipino",
  value: "fil-PH",
  equivalentValues: ["fil-PH"]
}, {
  label: "Finnish",
  value: "fi-FI",
  equivalentValues: ["fi-FI"]
}, {
  label: "French",
  value: "fr-FR",
  equivalentValues: ["fr-BE", "fr-CA", "fr-CH", "fr-FR"]
}, {
  label: "German",
  value: "de-DE",
  equivalentValues: ["de-AT", "de-CH", "de-DE"]
}, {
  label: "Greek",
  value: "el-GR",
  equivalentValues: ["el-GR"]
}, {
  label: "Hebrew",
  value: "he-IL",
  equivalentValues: ["he-IL"]
}, {
  label: "Hindi",
  value: "hi-IN",
  equivalentValues: ["hi-IN"]
}, {
  label: "Hungarian",
  value: "hu-HU",
  equivalentValues: ["hu-HU"]
}, {
  label: "Indonesian",
  value: "id-ID",
  equivalentValues: ["id-ID"]
}, {
  label: "Italian",
  value: "it-IT",
  equivalentValues: ["it-IT", "it-CH"]
}, {
  label: "Japanese",
  value: "ja-JP",
  equivalentValues: ["ja-JP"]
}, {
  label: "Korean",
  value: "ko-KR",
  equivalentValues: ["ko-KR"]
}, {
  label: "Malay",
  value: "ms-MY",
  equivalentValues: ["ms-MY"]
}, {
  label: "Malayalam",
  value: "ml-IN",
  equivalentValues: ["ml-IN"]
}, {
  label: "Norwegian",
  value: "no-NO",
  equivalentValues: ["no-NO"]
}, {
  label: "Polish",
  value: "pl-PL",
  equivalentValues: ["pl-PL"]
}, {
  label: "Portuguese",
  value: "pt-PT",
  equivalentValues: ["pt-PT", "pt-BR"]
}, {
  label: "Romanian",
  value: "ro-RO",
  equivalentValues: ["ro-RO"]
}, {
  label: "Russian",
  value: "ru-RU",
  equivalentValues: ["ru-RU"]
}, {
  label: "Slovak",
  value: "sk-SK",
  equivalentValues: ["sk-SK"]
}, {
  label: "Spanish",
  value: "es-ES",
  equivalentValues: ["es-AR", "es-BO", "es-CL", "es-CO", "es-CR", "es-CU", "es-DO", "es-EC", "es-ES", "es-GQ", "es-GT", "es-HN", "es-MX", "es-NI", "es-PA", "es-PE", "es-PR", "es-PY", "es-SV", "es-US", "es-UY", "es-VE"]
}, {
  label: "Swedish",
  value: "sv-SE",
  equivalentValues: ["sv-SE"]
}, {
  label: "Tamil",
  value: "ta-IN",
  equivalentValues: ["ta-IN"]
}, {
  label: "Turkish",
  value: "tr-TR",
  equivalentValues: ["tr-TR"]
}, {
  label: "Ukrainian",
  value: "uk-UA",
  equivalentValues: ["uk-UA"]
}, {
  label: "Vietnamese",
  value: "vi-VN",
  equivalentValues: ["vi-VN"]
}], wc = "en-US", pE = () => {
  var r, s, o;
  const {
    agentManager: t
  } = je(Pn), e = ((o = (s = (r = t == null ? void 0 : t.agent) == null ? void 0 : r.presenter) == null ? void 0 : s.voice) == null ? void 0 : o.language) || "English", n = e === "Multilingual";
  return bo(() => {
    var c;
    if (!n)
      return ((c = ph.find(({
        label: u
      }) => e.includes(u))) == null ? void 0 : c.value) || wc;
    const a = navigator == null ? void 0 : navigator.language;
    return !a || !!!ph.find(({
      equivalentValues: u
    }) => u.includes(a)) ? wc : a;
  }, [n, e]);
};
function dE({
  text: t,
  onSend: e,
  onTranscript: n,
  isSttSendDisabled: r,
  isMessageSendDisabled: s,
  className: o
}) {
  const [a, i] = H(!1), {
    connectionState: c,
    reconnect: u,
    agentManager: p,
    enabled: d
  } = je(Pn), {
    isAuthenticated: l
  } = je(ls), h = pt(), v = cE(), g = pE();
  if (oe(() => ((() => {
    var m;
    if (!(!(p != null && p.getSTTToken) || !d))
      return (m = h.current) == null || m.destroy(), h.current = new uE({
        getSTTToken: v,
        events: {
          onresult(S) {
            n(S.result.text);
          },
          onstart: () => {
            lt("agent-stt", {
              event: "start",
              engine: "azure"
            }), i(!0);
          },
          onend: () => {
            var S;
            (S = document.activeElement) == null || S.blur(), i(!1);
          },
          onerror: (S) => lt("agent-stt", {
            event: "error",
            error: S.errorDetails,
            errorCode: S.errorCode,
            engine: "azure"
          })
        }
      }), h.current.init(g);
  })(), () => {
    var m;
    return (m = h.current) == null ? void 0 : m.destroy();
  }), [p == null ? void 0 : p.getSTTToken, d, g]), oe(() => {
    h.current && (h.current.events.onresult = (f) => n(f.result.text));
  }, [n]), l && !a && c === Q.Connecting)
    return E("button", {
      className: "didagaent__send__button didagaent__send__button__loader " + o,
      disabled: !0,
      "data-testid": "send_loader",
      children: E(Qe, {
        src: Uv,
        size: "60%",
        color: "var(--did-primary-black-700)"
      })
    });
  if (t.length === 0) {
    const f = async () => {
      if (h.current) {
        const m = a ? "stop" : "start";
        Wc.includes(c) && await u(), setTimeout(() => {
          var S;
          return (S = h.current) == null ? void 0 : S[m]();
        }), lt("agent-stt", {
          event: m,
          engine: "azure"
        });
      }
    };
    return E(xt, {
      children: [a && E("button", {
        disabled: r,
        className: "didagaent__send__button didagaent__send__button__record " + o,
        onClick: () => {
          var m;
          (m = h.current) == null || m.abort(), i(!1);
        },
        children: E(Qe, {
          src: Wv,
          size: "60%",
          color: "var(--did-primary-black-700)"
        })
      }), E("button", {
        className: `didagaent__send__button ${a ? "" : "didagaent__send__button__record"} ${o}`,
        onClick: f,
        disabled: r,
        "data-testid": "send_record",
        children: E(Qe, {
          src: a ? Ny : Oy,
          size: "60%",
          color: a ? "white" : "var(--did-primary-black-700)"
        })
      })]
    });
  }
  return E("button", {
    className: "didagaent__send__button  didagaent__send__button_actions " + o + (s ? " didagent__send__button__disabled" : ""),
    onClick: e,
    disabled: s,
    "data-testid": "send_text",
    children: E(Qe, {
      src: Dy,
      size: "60%",
      color: "white"
    })
  });
}
const lE = "data:image/svg+xml,%3csvg%20width='20'%20height='20'%20viewBox='0%200%2020%2020'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M15.3035%206.70851L14.7142%206.11925C12.1107%203.51576%207.88961%203.51576%205.28612%206.11925C2.68262%208.72275%202.68262%2012.9438%205.28612%2015.5473C7.88961%2018.1508%2012.1107%2018.1508%2014.7142%2015.5473C16.2282%2014.0333%2016.8618%2011.9723%2016.6149%2010.0004M15.3035%206.70851H11.7679M15.3035%206.70851V3.17297'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e", hE = "data:image/svg+xml,%3csvg%20width='20'%20height='21'%20viewBox='0%200%2020%2021'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M13.5417%2010.2484C13.5417%209.90318%2013.2618%209.62336%2012.9167%209.62336C12.5715%209.62336%2012.2917%209.90318%2012.2917%2010.2484H13.5417ZM5.84683%206.04679L5.9509%206.66307L5.84683%206.04679ZM7.1661%205.43188L6.82206%204.91009L6.82206%204.91009L7.1661%205.43188ZM6.43996%205.86885L6.69231%206.44064L6.43996%205.86885ZM2.78323%2014.184L2.5208%2014.7512L2.78323%2014.184ZM1.27899%2011.1054L0.655149%2011.1434L1.27899%2011.1054ZM1.63212%2013.1009L2.18233%2012.8044L1.63212%2013.1009ZM11.4167%2016.9775L11.2149%2016.3859L11.4167%2016.9775ZM12.8439%2012.4195L13.4683%2012.4485L12.8439%2012.4195ZM11.8997%2016.7317L12.2591%2017.243L11.8997%2016.7317ZM7.34855%205.31159L7.69258%205.83338L7.69258%205.83338L7.34855%205.31159ZM11.4167%203.51926L11.2149%204.11077L11.4167%203.51926ZM11.8997%203.76506L12.2591%203.25371L11.8997%203.76506ZM2.78323%206.31276L2.5208%205.74553L2.78323%206.31276ZM1.27899%209.39136L0.655149%209.35333L1.27899%209.39136ZM1.63212%207.39586L2.18233%207.69232L1.63212%207.39586ZM8.25923%2015.0362C7.97052%2014.847%207.5831%2014.9277%207.39391%2015.2164C7.20472%2015.5051%207.28539%2015.8926%207.57411%2016.0817L8.25923%2015.0362ZM7.51013%205.95367L7.69258%205.83338L7.00451%204.7898L6.82206%204.91009L7.51013%205.95367ZM1.90283%2011.0673C1.88521%2010.7782%201.875%2010.501%201.875%2010.2484H0.625C0.625%2010.533%200.636444%2010.8365%200.655149%2011.1434L1.90283%2011.0673ZM1.875%2010.2484C1.875%209.99567%201.88521%209.71852%201.90283%209.42938L0.655149%209.35333C0.636444%209.66022%200.625%209.96371%200.625%2010.2484H1.875ZM12.2917%2010.2484C12.2917%2010.6748%2012.263%2011.4575%2012.2196%2012.3905L13.4683%2012.4485C13.5114%2011.5194%2013.5417%2010.7084%2013.5417%2010.2484H12.2917ZM5.00007%206.70669C5.40642%206.70669%205.68068%206.7087%205.9509%206.66307L5.74276%205.43052C5.59964%205.45469%205.44717%205.45669%205.00007%205.45669V6.70669ZM6.82206%204.91009C6.4488%205.1562%206.3204%205.23846%206.18761%205.29706L6.69231%206.44064C6.94302%206.32999%207.17089%206.17735%207.51014%205.95367L6.82206%204.91009ZM5.9509%206.66307C6.2063%206.61994%206.45534%206.54522%206.69231%206.44064L6.18761%205.29706C6.04543%205.35981%205.896%205.40464%205.74276%205.43052L5.9509%206.66307ZM5.00007%2015.04C5.44717%2015.04%205.59964%2015.042%205.74276%2015.0662L5.9509%2013.8337C5.68068%2013.788%205.40642%2013.79%205.00007%2013.79V15.04ZM5.00007%2013.79C3.79701%2013.79%203.39093%2013.7765%203.04567%2013.6167L2.5208%2014.7512C3.17442%2015.0536%203.91327%2015.04%205.00007%2015.04V13.79ZM0.655149%2011.1434C0.713737%2012.1046%200.741742%2012.766%201.0819%2013.3973L2.18233%2012.8044C2.00044%2012.4668%201.96704%2012.1208%201.90283%2011.0673L0.655149%2011.1434ZM3.04567%2013.6167C2.71204%2013.4624%202.3567%2013.128%202.18233%2012.8044L1.0819%2013.3973C1.38451%2013.959%201.9418%2014.4833%202.5208%2014.7512L3.04567%2013.6167ZM12.2196%2012.3905C12.1603%2013.6661%2012.1175%2014.5594%2012.0013%2015.2051C11.8855%2015.848%2011.7209%2016.0934%2011.5404%2016.2203L12.2591%2017.243C12.8475%2016.8295%2013.0965%2016.1762%2013.2315%2015.4266C13.3659%2014.68%2013.4107%2013.6874%2013.4683%2012.4485L12.2196%2012.3905ZM11.6186%2017.569C11.8451%2017.4916%2012.0632%2017.3807%2012.2591%2017.243L11.5404%2016.2203C11.4414%2016.2899%2011.3294%2016.3469%2011.2149%2016.3859L11.6186%2017.569ZM7.69258%205.83338C8.76742%205.1247%209.52165%204.62895%2010.1169%204.33981C10.7104%204.05147%2011.0072%204.03991%2011.2149%204.11077L11.6186%202.92775C10.9368%202.69508%2010.259%202.88107%209.57067%203.21546C8.88394%203.54906%208.04882%204.10124%207.00451%204.7898L7.69258%205.83338ZM11.2149%204.11077C11.3294%204.14984%2011.4414%204.20686%2011.5404%204.27642L12.2591%203.25371C12.0632%203.11606%2011.8451%203.00507%2011.6186%202.92775L11.2149%204.11077ZM5.00007%205.45669C3.91327%205.45669%203.17442%205.44313%202.5208%205.74553L3.04567%206.88C3.39093%206.72026%203.79701%206.70669%205.00007%206.70669V5.45669ZM1.90283%209.42938C1.96704%208.37591%202.00044%208.02991%202.18233%207.69232L1.0819%207.0994C0.741742%207.73072%200.713737%208.39208%200.655149%209.35333L1.90283%209.42938ZM2.5208%205.74553C1.9418%206.01341%201.38451%206.53777%201.0819%207.0994L2.18233%207.69232C2.3567%207.36869%202.71204%207.03435%203.04567%206.88L2.5208%205.74553ZM7.57411%2016.0817C8.43976%2016.649%209.15622%2017.1023%209.76703%2017.3725C10.3856%2017.6461%2011.0002%2017.78%2011.6186%2017.569L11.2149%2016.3859C11.027%2016.45%2010.7656%2016.4474%2010.2727%2016.2293C9.77201%2016.0079%209.14153%2015.6144%208.25923%2015.0362L7.57411%2016.0817ZM13.4359%207.36502C13.3854%206.3424%2013.3303%205.50424%2013.1891%204.85648C13.046%204.19945%2012.792%203.62818%2012.2591%203.25371L11.5404%204.27642C11.7036%204.39113%2011.8545%204.60276%2011.9678%205.1226C12.0831%205.65169%2012.1359%206.38434%2012.1874%207.42669L13.4359%207.36502Z'%20fill='%23090604'/%3e%3cpath%20d='M16.6665%2015.2487C16.6665%2015.2487%2017.9165%2013.7487%2017.9165%2010.2487C17.9165%208.22085%2017.4969%206.86438%2017.1439%206.08203'%20stroke='%23090604'%20stroke-width='1.25'%20stroke-linecap='round'/%3e%3cpath%20d='M15%2012.7487C15%2012.7487%2015.4167%2011.9987%2015.4167%2010.2487C15.4167%209.53046%2015.3465%208.98066%2015.2637%208.58203'%20stroke='%23090604'%20stroke-width='1.25'%20stroke-linecap='round'/%3e%3cpath%20d='M18.3332%201.91797L1.6665%2018.5846'%20stroke='%23090604'%20stroke-width='1.25'%20stroke-linecap='round'/%3e%3c/svg%3e", vE = "data:image/svg+xml,%3csvg%20width='20'%20height='20'%20viewBox='0%200%2020%2020'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M1.27899%209.14136C1.34039%208.134%201.37109%207.63031%201.63212%207.14586C1.87061%206.70323%202.32692%206.27388%202.78323%206.06276C3.28268%205.83169%203.85514%205.83169%205.00007%205.83169C5.4268%205.83169%205.64016%205.83169%205.84683%205.79679C6.05115%205.76229%206.25039%205.70252%206.43996%205.61885C6.63171%205.53423%206.80984%205.41678%207.1661%205.18188L7.34855%205.06159C9.46769%203.66435%2010.5273%202.96573%2011.4167%203.26926C11.5872%203.32746%2011.7523%203.41146%2011.8997%203.51506C12.6687%204.05544%2012.7271%205.3127%2012.8439%207.8272C12.8872%208.75826%2012.9167%209.55512%2012.9167%209.99836C12.9167%2010.4416%2012.8872%2011.2385%2012.8439%2012.1695C12.7271%2014.684%2012.6687%2015.9413%2011.8997%2016.4817C11.7523%2016.5853%2011.5872%2016.6693%2011.4167%2016.7275C10.5273%2017.031%209.46769%2016.3324%207.34854%2014.9351L7.1661%2014.8148C6.80984%2014.5799%206.63171%2014.4625%206.43996%2014.3779C6.25039%2014.2942%206.05115%2014.2344%205.84683%2014.1999C5.64016%2014.165%205.4268%2014.165%205.00007%2014.165C3.85514%2014.165%203.28268%2014.165%202.78323%2013.934C2.32692%2013.7228%201.87061%2013.2935%201.63212%2012.8509C1.37109%2012.3664%201.34039%2011.8627%201.27899%2010.8554C1.26083%2010.5573%201.25%2010.267%201.25%209.99836C1.25%209.72969%201.26083%209.43937%201.27899%209.14136Z'%20stroke='white'%20stroke-width='1.5'/%3e%3cpath%20d='M15%207.5C15%207.5%2015.4167%208.25%2015.4167%2010C15.4167%2011.75%2015%2012.5%2015%2012.5'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'/%3e%3c/svg%3e";
function fE({
  show: t,
  muted: e,
  onClick: n,
  className: r
}) {
  return t ? E("button", {
    onClick: n,
    title: "Mute Sound",
    className: `${r}`,
    children: E(Qe, {
      src: e ? hE : vE,
      size: "20px"
    })
  }) : null;
}
function gE({
  name: t,
  icon: e,
  displayRestart: n,
  displayMuteButton: r,
  onRestart: s,
  restartDisabled: o,
  onMute: a,
  muted: i,
  isRestarting: c,
  onClose: u,
  onEasterEgg: p,
  closeClassName: d
}) {
  const l = pt(0), {
    error: h
  } = je(Pn), {
    configurations: v
  } = je($t);
  function g() {
    l.current += 1, l.current === 5 && (p == null || p(), l.current = 0);
  }
  const f = [M.Maintenance].includes(v.chatMode);
  return E("header", {
    className: "didagent__header",
    children: [E("div", {
      className: "didagent__header-left",
      children: [v.mode === "fabio" && E("button", {
        onClick: u,
        className: `didagent__close__button didagent__header-bg ${d}`,
        children: E(Qe, {
          src: Wv,
          size: "20px"
        })
      }), !f && E("div", {
        "data-testid": "didagent__header__name",
        className: `didagent__header__name ${e ? "" : "didagent__header-bg"}`,
        onClick: g,
        children: e ? E("img", {
          src: e,
          alt: "Agent Logo"
        }) : t
      }), n && E("button", {
        onClick: s,
        disabled: o,
        title: "Restart conversation",
        className: `didagent__header__menu__item ${c ? "didagent__header__menu__item-rotate" : ""} didagent__header-bg`,
        children: E(Qe, {
          src: lE,
          size: "20px"
        })
      }), E(fE, {
        show: r,
        muted: i,
        onClick: a,
        className: `${i ? "didagent__header__menu__item-active" : ""} didagent__header-bg`
      })]
    }), E("div", {
      className: "didagent__header-center",
      children: E(Ay, {
        hide: !h,
        text: h
      })
    })]
  });
}
const mE = "data:image/svg+xml,%3csvg%20version='1.1'%20id='L5'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20x='0px'%20y='0px'%20viewBox='0%200%2052%2042'%20enable-background='new%200%200%200%200'%20xml:space='preserve'%3e%3ccircle%20fill='%23fff'%20stroke='none'%20cx='6'%20cy='21'%20r='6'%3e%3canimateTransform%20attributeName='transform'%20dur='1s'%20type='translate'%20values='0%2015%20;%200%20-15;%200%2015'%20repeatCount='indefinite'%20begin='0.1'/%3e%3c/circle%3e%3ccircle%20fill='%23fff'%20stroke='none'%20cx='25'%20cy='21'%20r='6'%3e%3canimateTransform%20attributeName='transform'%20dur='1s'%20type='translate'%20values='0%2010%20;%200%20-10;%200%2010'%20repeatCount='indefinite'%20begin='0.2'/%3e%3c/circle%3e%3ccircle%20fill='%23fff'%20stroke='none'%20cx='44'%20cy='21'%20r='6'%3e%3canimateTransform%20attributeName='transform'%20dur='1s'%20type='translate'%20values='0%205%20;%200%20-5;%200%205'%20repeatCount='indefinite'%20begin='0.3'/%3e%3c/circle%3e%3c/svg%3e";
function Sg(t, e) {
  for (var n in e)
    t[n] = e[n];
  return t;
}
function dh(t, e) {
  for (var n in t)
    if (n !== "__source" && !(n in e))
      return !0;
  for (var r in e)
    if (r !== "__source" && t[r] !== e[r])
      return !0;
  return !1;
}
function lh(t, e) {
  this.props = t, this.context = e;
}
(lh.prototype = new _t()).isPureReactComponent = !0, lh.prototype.shouldComponentUpdate = function(t, e) {
  return dh(this.props, t) || dh(this.state, e);
};
var hh = U.__b;
U.__b = function(t) {
  t.type && t.type.__f && t.ref && (t.props.ref = t.ref, t.ref = null), hh && hh(t);
};
var SE = typeof Symbol < "u" && Symbol.for && Symbol.for("react.forward_ref") || 3911;
function yE(t) {
  function e(n) {
    var r = Sg({}, n);
    return delete r.ref, t(r, n.ref || null);
  }
  return e.$$typeof = SE, e.render = e, e.prototype.isReactComponent = e.__f = !0, e.displayName = "ForwardRef(" + (t.displayName || t.name) + ")", e;
}
var CE = U.__e;
U.__e = function(t, e, n, r) {
  if (t.then) {
    for (var s, o = e; o = o.__; )
      if ((s = o.__c) && s.__c)
        return e.__e == null && (e.__e = n.__e, e.__k = n.__k), s.__c(t, e);
  }
  CE(t, e, n, r);
};
var vh = U.unmount;
function yg(t, e, n) {
  return t && (t.__c && t.__c.__H && (t.__c.__H.__.forEach(function(r) {
    typeof r.__c == "function" && r.__c();
  }), t.__c.__H = null), (t = Sg({}, t)).__c != null && (t.__c.__P === n && (t.__c.__P = e), t.__c = null), t.__k = t.__k && t.__k.map(function(r) {
    return yg(r, e, n);
  })), t;
}
function Cg(t, e, n) {
  return t && n && (t.__v = null, t.__k = t.__k && t.__k.map(function(r) {
    return Cg(r, e, n);
  }), t.__c && t.__c.__P === e && (t.__e && n.appendChild(t.__e), t.__c.__e = !0, t.__c.__P = n)), t;
}
function bc() {
  this.__u = 0, this.t = null, this.__b = null;
}
function _g(t) {
  var e = t.__.__c;
  return e && e.__a && e.__a(t);
}
function Ws() {
  this.u = null, this.o = null;
}
U.unmount = function(t) {
  var e = t.__c;
  e && e.__R && e.__R(), e && 32 & t.__u && (t.type = null), vh && vh(t);
}, (bc.prototype = new _t()).__c = function(t, e) {
  var n = e.__c, r = this;
  r.t == null && (r.t = []), r.t.push(n);
  var s = _g(r.__v), o = !1, a = function() {
    o || (o = !0, n.__R = null, s ? s(i) : i());
  };
  n.__R = a;
  var i = function() {
    if (!--r.__u) {
      if (r.state.__a) {
        var c = r.state.__a;
        r.__v.__k[0] = Cg(c, c.__c.__P, c.__c.__O);
      }
      var u;
      for (r.setState({ __a: r.__b = null }); u = r.t.pop(); )
        u.forceUpdate();
    }
  };
  r.__u++ || 32 & e.__u || r.setState({ __a: r.__b = r.__v.__k[0] }), t.then(a, a);
}, bc.prototype.componentWillUnmount = function() {
  this.t = [];
}, bc.prototype.render = function(t, e) {
  if (this.__b) {
    if (this.__v.__k) {
      var n = document.createElement("div"), r = this.__v.__k[0].__c;
      this.__v.__k[0] = yg(this.__b, n, r.__O = r.__P);
    }
    this.__b = null;
  }
  var s = e.__a && rs(xt, null, t.fallback);
  return s && (s.__u &= -33), [rs(xt, null, e.__a ? null : t.children), s];
};
var fh = function(t, e, n) {
  if (++n[1] === n[0] && t.o.delete(e), t.props.revealOrder && (t.props.revealOrder[0] !== "t" || !t.o.size))
    for (n = t.u; n; ) {
      for (; n.length > 3; )
        n.pop()();
      if (n[1] < n[0])
        break;
      t.u = n = n[2];
    }
};
function _E(t) {
  return this.getChildContext = function() {
    return t.context;
  }, t.children;
}
function RE(t) {
  var e = this, n = t.i;
  e.componentWillUnmount = function() {
    fo(null, e.l), e.l = null, e.i = null;
  }, e.i && e.i !== n && e.componentWillUnmount(), e.l || (e.i = n, e.l = { nodeType: 1, parentNode: n, childNodes: [], appendChild: function(r) {
    this.childNodes.push(r), e.i.appendChild(r);
  }, insertBefore: function(r, s) {
    this.childNodes.push(r), e.i.appendChild(r);
  }, removeChild: function(r) {
    this.childNodes.splice(this.childNodes.indexOf(r) >>> 1, 1), e.i.removeChild(r);
  } }), fo(rs(_E, { context: e.context }, t.__v), e.l);
}
function gh(t, e) {
  var n = rs(RE, { __v: t, i: e });
  return n.containerInfo = e, n;
}
(Ws.prototype = new _t()).__a = function(t) {
  var e = this, n = _g(e.__v), r = e.o.get(t);
  return r[0]++, function(s) {
    var o = function() {
      e.props.revealOrder ? (r.push(s), fh(e, t, r)) : s();
    };
    n ? n(o) : o();
  };
}, Ws.prototype.render = function(t) {
  this.u = null, this.o = /* @__PURE__ */ new Map();
  var e = vo(t.children);
  t.revealOrder && t.revealOrder[0] === "b" && e.reverse();
  for (var n = e.length; n--; )
    this.o.set(e[n], this.u = [1, 0, this.u]);
  return t.children;
}, Ws.prototype.componentDidUpdate = Ws.prototype.componentDidMount = function() {
  var t = this;
  this.o.forEach(function(e, n) {
    fh(t, n, e);
  });
};
var PE = typeof Symbol < "u" && Symbol.for && Symbol.for("react.element") || 60103, EE = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image(!S)|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/, TE = /^on(Ani|Tra|Tou|BeforeInp|Compo)/, IE = /[A-Z0-9]/g, wE = typeof document < "u", bE = function(t) {
  return (typeof Symbol < "u" && typeof Symbol() == "symbol" ? /fil|che|rad/ : /fil|che|ra/).test(t);
};
_t.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function(t) {
  Object.defineProperty(_t.prototype, t, { configurable: !0, get: function() {
    return this["UNSAFE_" + t];
  }, set: function(e) {
    Object.defineProperty(this, t, { configurable: !0, writable: !0, value: e });
  } });
});
var mh = U.event;
function AE() {
}
function ME() {
  return this.cancelBubble;
}
function kE() {
  return this.defaultPrevented;
}
U.event = function(t) {
  return mh && (t = mh(t)), t.persist = AE, t.isPropagationStopped = ME, t.isDefaultPrevented = kE, t.nativeEvent = t;
};
var OE = { enumerable: !1, configurable: !0, get: function() {
  return this.class;
} }, Sh = U.vnode;
U.vnode = function(t) {
  typeof t.type == "string" && function(e) {
    var n = e.props, r = e.type, s = {};
    for (var o in n) {
      var a = n[o];
      if (!(o === "value" && "defaultValue" in n && a == null || wE && o === "children" && r === "noscript" || o === "class" || o === "className")) {
        var i = o.toLowerCase();
        o === "defaultValue" && "value" in n && n.value == null ? o = "value" : o === "download" && a === !0 ? a = "" : i === "translate" && a === "no" ? a = !1 : i === "ondoubleclick" ? o = "ondblclick" : i !== "onchange" || r !== "input" && r !== "textarea" || bE(n.type) ? i === "onfocus" ? o = "onfocusin" : i === "onblur" ? o = "onfocusout" : TE.test(o) ? o = i : r.indexOf("-") === -1 && EE.test(o) ? o = o.replace(IE, "-$&").toLowerCase() : a === null && (a = void 0) : i = o = "oninput", i === "oninput" && s[o = i] && (o = "oninputCapture"), s[o] = a;
      }
    }
    r == "select" && s.multiple && Array.isArray(s.value) && (s.value = vo(n.children).forEach(function(c) {
      c.props.selected = s.value.indexOf(c.props.value) != -1;
    })), r == "select" && s.defaultValue != null && (s.value = vo(n.children).forEach(function(c) {
      c.props.selected = s.multiple ? s.defaultValue.indexOf(c.props.value) != -1 : s.defaultValue == c.props.value;
    })), n.class && !n.className ? (s.class = n.class, Object.defineProperty(s, "className", OE)) : (n.className && !n.class || n.class && n.className) && (s.class = s.className = n.className), e.props = s;
  }(t), t.$$typeof = PE, Sh && Sh(t);
};
var yh = U.__r;
U.__r = function(t) {
  yh && yh(t), t.__c;
};
var Ch = U.diffed;
U.diffed = function(t) {
  Ch && Ch(t);
  var e = t.props, n = t.__e;
  n != null && t.type === "textarea" && "value" in e && e.value !== n.value && (n.value = e.value == null ? "" : e.value);
};
function DE(t, e, n) {
  return t ? "var(--did-primary-black-9080)" : "var(--did-primary-black-9060)";
}
function _h({
  negative: t,
  toggled: e,
  onClick: n,
  disabled: r
}) {
  if (!e && r)
    return null;
  const s = t === !0, o = {
    "--hover-color": "var(--did-primary-black-9080)",
    "--color": DE(e, s, r === !0),
    "--cursor": r === !0 ? "default" : "pointer"
  };
  return E("div", {
    className: "didagent__thumb__container",
    style: o,
    onClick: () => !r && (n == null ? void 0 : n(!e)),
    children: s ? "👎" : "👍"
  });
}
const NE = (t, e) => t === "up" ? e === tt.Positive ? tt.Unrated : tt.Positive : e === tt.Negative ? tt.Unrated : tt.Negative;
function LE({
  className: t,
  show: e,
  onRate: n,
  message: r,
  style: s
}) {
  const [o, a] = H(tt.Unrated), [i, c] = H(), [u, p] = H(!1);
  if (!e)
    return null;
  function d(l) {
    return async () => {
      var g;
      const h = NE(l, o);
      a(h), p(!0);
      const v = await (n == null ? void 0 : n(h, r, i));
      c(v), (g = window.dataLayer) == null || g.push({
        event: "rated_reply",
        rating: h,
        message: r
      });
    };
  }
  return E("div", {
    className: `${t} didagent__rating`,
    style: s,
    children: [E(_h, {
      disabled: u,
      toggled: o === tt.Positive,
      onClick: d("up")
    }), E(_h, {
      disabled: u,
      negative: !0,
      toggled: o === tt.Negative,
      onClick: d("down")
    })]
  });
}
const zE = /(https?:\/\/[^\s]+)/g, Rh = {
  "#general#": 280,
  ".": 620,
  ",": 500,
  "?": 500,
  "!": 500
};
function jE({
  text: t,
  role: e,
  onTypingStatusChange: n,
  scrollToBottom: r
}) {
  const [s, o] = H([]), [a, i] = H(0), [c, u] = H([]);
  return oe(() => u(t.split(" ")), [t]), oe(() => {
    if (a < c.length) {
      const p = c[a], d = Rh[p.split("").pop() ?? ""] || Rh["#general#"], h = zE.test(p) ? E("a", {
        href: p,
        target: "_blank",
        rel: "noreferrer",
        className: "didagent__message__url",
        children: p
      }) : E("span", {
        children: p
      }), v = setTimeout(() => {
        o((g) => [...g, g.length ? " " : "", h]), i((g) => g + 1), r();
      }, d);
      return () => clearTimeout(v);
    }
  }, [a, c]), oe(() => {
    a === 0 ? n("start", e) : a >= c.length && n("done", e);
  }, [a, c]), e === "user" ? E("span", {
    children: t
  }) : E("span", {
    className: "appear-animation",
    children: s
  });
}
const xE = ["Juggling thoughts and data...", "Processing, just a moment...", "Cooking up a response...", "Brainstorming potential answers...", "Let me look this up..."], Ph = ["Pondering the best reply...", "Processing, just a moment...", "Convincing my electrons to run faster...", "This is interesting..."], BE = [{
  text: [""],
  duration: 2e3
}, {
  text: ["Thinking..."],
  duration: 3e3
}, {
  text: xE,
  duration: 4e3
}, {
  text: Ph,
  duration: 4e3
}, {
  text: Ph,
  duration: 4e3
}];
function qE(t) {
  return t[Math.floor(Math.random() * t.length)];
}
function FE(t) {
  const [e, n] = H(t[0].text[0]), r = pt(), s = (a = 0) => {
    a < t.length && !r.current && (r.current = setTimeout(() => {
      r.current = void 0;
      const i = (a + 1) % t.length;
      n(qE(t[i].text)), s(i);
    }, t[a].duration));
  };
  return {
    text: e,
    doStep: s,
    clear: () => {
      clearTimeout(r.current), n(t[0].text[0]), r.current = void 0;
    }
  };
}
const $E = "#b8b8b8", UE = yE(({
  messages: t,
  isLoading: e,
  onRate: n,
  scrollToBottom: r,
  onScroll: s
}, o) => {
  const [a, i] = H(!1), {
    doStep: c,
    text: u,
    clear: p
  } = FE(BE);
  oe(() => e ? c() : p(), [e]);
  const d = mn((v, g) => {
    i(v === "start" ? !1 : g === "assistant");
  }, [i]), l = t[t.length - 1], h = e && l.role === "assistant" ? t.slice(0, t.length - 1) : t;
  return E("div", {
    className: "didagent__messages__container",
    ref: o,
    "data-testid": "didagent_messages",
    onScroll: s,
    children: [h.filter(({
      content: v
    }) => !!v).map((v, g) => E("div", {
      className: `didagent__message__container didagent__message__container__${v.role}`,
      children: [E("pre", {
        className: `didagent__message didagent__message__${v.role}`,
        children: E(jE, {
          text: v.content,
          role: v.role,
          onTypingStatusChange: d,
          scrollToBottom: r
        }, v.id)
      }), g > 0 && v.role === "assistant" && E(LE, {
        className: "didagent__message__rating",
        message: v,
        show: a,
        onRate: n,
        style: {
          opacity: g === t.length - 1 ? 1 : void 0
        }
      })]
    }, v.id)), e && E("div", {
      className: "didagent__message__container didagent__message__container__assistant",
      "data-testid": "didagent_message_loader",
      children: E("pre", {
        className: "didagent__message didagent__message__assistant didagent__message__assistant__loader",
        children: [E(Qe, {
          src: mE,
          color: $E,
          size: "22px"
        }), u]
      })
    })]
  });
}), HE = "data:image/svg+xml,%3csvg%20width='22'%20height='12'%20viewBox='0%200%2022%2012'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M20.7997%201.79923L10.9997%2010.1992L1.19971%201.79922'%20stroke='%23FFFEFD'%20stroke-width='2.1'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e";
function WE(t) {
  return t ? {
    maxHeight: "180px",
    paddingbottom: "8px",
    marginBottom: "-8px"
  } : {
    maxHeight: "0",
    paddingBottom: "0",
    marginBottom: "0"
  };
}
function VE({
  messages: t,
  onClick: e,
  show: n,
  enabled: r
}) {
  const [s, o] = H(!1);
  oe(() => {
    n && t.length > 0 && setTimeout(() => {
      o(!0);
    }, 2e3);
  }, [n, t]);
  const a = (i) => {
    var c;
    r && e(i), (c = window.dataLayer) == null || c.push({
      event: "clicked_starter_message",
      message: i
    });
  };
  return E("div", {
    className: "didagent__starter_messages__container",
    style: WE(s && n),
    children: t.map((i) => E("div", {
      className: `didagent__starter_message__container ${r ? "" : "disabled"}`,
      onClick: () => a(i),
      children: [E("div", {
        className: "didagent__starter_message__container_text",
        children: i
      }), E(Qe, {
        src: HE,
        size: "16px",
        color: "rgba(255, 255, 255, 0.7)",
        className: "didagent__starter_message__arrow"
      })]
    }, i))
  });
}
function KE({
  streamState: t,
  connectionState: e,
  srcObject: n,
  idleVideo: r,
  isBlur: s,
  muted: o,
  posterImg: a,
  onVideoPlay: i,
  onVideoStop: c,
  onIdleLoad: u
}) {
  const p = pt(null), d = pt(null), {
    configurations: l
  } = je($t), [h, v] = H(!1), g = Iy();
  return oe(() => {
    n && d.current && (v(!1), d.current.srcObject = n);
  }, [n, d.current]), oe(() => {
    var f;
    if (lt("agent-stream-state-change", {
      version: 1,
      streamState: ue[t],
      connectionState: e
    }), t === ue.New)
      p.current && (p.current.currentTime = 0), c == null || c();
    else if (t === ue.Start) {
      if (g) {
        const m = wy();
        m && m >= 17 && d.current && (d.current.volume = 1);
      }
      (f = d.current) != null && f.paused && d.current.play(), i == null || i();
    }
  }, [t]), oe(() => {
    e === Q.Connected && v(!0);
  }, [e]), E("div", {
    className: "didagent__embedded__video__container",
    "data-orientation": l.orientation,
    "data-blur": s,
    children: [E("video", {
      className: "didagent__embedded__video__idle",
      "data-testid": "didagent__video_idle",
      autoPlay: !0,
      playsInline: !0,
      poster: a,
      onLoadedData: u,
      src: r,
      muted: !0,
      ref: p,
      loop: !0
    }), E("video", {
      "data-active": t === ue.Start && h,
      "data-testid": "didagent__video_stream",
      className: "didagent__embedded__video__stream",
      onPlay: () => lt("agent-video-play-event", {
        version: 1,
        event: "play",
        streamState: ue[t],
        connectionState: e,
        muted: o
      }),
      muted: o || !h,
      ref: d,
      autoPlay: !0,
      playsInline: !0,
      onAbort: (f) => c == null ? void 0 : c(f),
      onPause: (f) => {
        f.currentTarget.play(), c == null || c(f);
      }
    })]
  });
}
function JE({
  enabled: t,
  offline: e,
  styles: n,
  onClose: r,
  onError: s
}) {
  var zs, js, xs, Bs;
  const {
    isAuthenticated: o
  } = je(ls), {
    disconnect: a,
    setStreamState: i,
    streamedMessage: c,
    streamState: u,
    connectionState: p,
    agentManager: d,
    setError: l,
    srcObject: h,
    connect: v,
    messages: g,
    reconnect: f,
    terminating: m
  } = je(Pn), {
    configurations: S,
    configure: y
  } = je($t), P = pt(!0), C = pt(null), _ = pt(null), w = pt(null), [T, O] = H(""), [G, X] = H(!1), [q, b] = H(!1), [x, ee] = H(!1), [Z, L] = H(!1), [re, ce] = H(!1), [et, We] = H(0), [Ya, ks] = H(!1);
  function Os(J = !1) {
    _.current && (J || P.current) && _.current.scrollTo({
      top: _.current.scrollHeight,
      behavior: "smooth"
    });
  }
  const Ds = S.chatMode && [M.TextOnly, M.Playground].includes(S.chatMode);
  oe(() => {
    (async () => {
      var qs;
      if (S.posterSrc)
        return;
      const De = (qs = d == null ? void 0 : d.agent) == null ? void 0 : qs.presenter;
      if (!De)
        return;
      const {
        type: ht,
        poster: Ce,
        source_url: vt,
        thumbnail: bt
      } = De;
      let lr;
      if (ht === "clip")
        lr = bt || Ce;
      else if (ht === "talk")
        lr = vt || bt || Ce;
      else {
        y({
          chatMode: M.Maintenance
        });
        return;
      }
      const nc = await by(lr, Ey);
      y({
        posterSrc: nc
      });
    })();
  }, [(zs = d == null ? void 0 : d.agent) == null ? void 0 : zs.id, y]), oe(() => {
    h && C.current && (C.current.srcObject = h);
  }, [h]), fy(() => Os(!0), [g, x]), oe(() => {
    [ue.Buffering, ue.Loading].includes(u) ? ee(!0) : [ue.Start, ue.Fail].includes(u) && ee(!1);
  }, [u]), oe(() => {
    var J;
    Z ? ee(!1) : (J = w.current) == null || J.focus();
  }, [Z, c]), oe(() => {
    (q || [M.Maintenance].includes(S.chatMode)) && y({
      loaderConfig: {
        ...S.loaderConfig,
        show: !1
      }
    });
  }, [y, q, S.chatMode]), oe(() => {
    S.chatMode === M.Maintenance && (l("The agent is temporarily unavailable. Please try again later"), a());
  }, [d, S.chatMode]);
  async function Dn(J) {
    var ht;
    if (J = J.trim(), J === "")
      return;
    let De = !1;
    if (Wc.includes(p) && (await f(), De = !0), o) {
      if (![M.TextOnly, M.Playground].includes(S.chatMode) && (!_.current || J.trim().length === 0 || ![ue.New].includes(u) || !([Q.Connected].includes(p) || De)))
        return;
    } else
      return lt("agent-offline-onsend", {
        event: "click"
      }), e == null ? void 0 : e.onSend(T);
    d != null && d.starterMessages && d.starterMessages.indexOf(J) > -1 && lt("agent-starter-question", {
      event: "click",
      question: J
    }), O(""), i(ue.Loading);
    try {
      if (!d)
        throw new Error("AgentManager is not available");
      const Ce = await d.chat(J).catch(async (vt) => {
        var bt;
        if ((bt = vt == null ? void 0 : vt.message) != null && bt.includes("Playground chat limit exceeded"))
          throw new Error("Playground chat limit exceeded");
        return console.error("Error in sending message", vt), {
          chatMode: M.Maintenance,
          result: "Sorry, I am not available right now",
          matches: []
        };
      });
      if (Ce.chatMode && (d.changeMode(Ce.chatMode), Ce.chatMode === M.Maintenance))
        return s == null || s(new Error("Agent is in maintenance mode"), Ce), a();
      i([M.TextOnly, M.Playground].includes(Ce.chatMode) ? ue.New : ue.Buffering);
    } catch (Ce) {
      throw i(ue.New), Ce;
    } finally {
      (ht = w.current) == null || ht.focus();
    }
  }
  async function Za(J, De, ht) {
    if (!d)
      throw new Error("AgentManager is not available");
    return d.rate(De.id, J === tt.Positive ? 1 : -1, ht).then((Ce) => Ce.id).catch((Ce) => {
      throw console.error("Error in rating", Ce), new Error("Error in rating " + Ce.message);
    });
  }
  const Xa = mn(async () => {
    var J;
    await a(), await v(), lt("agent-new-chat", {
      event: "click",
      agentId: (J = d == null ? void 0 : d.agent) == null ? void 0 : J.id
    });
  }, [d, v, a]), ec = mn(() => {
    var De;
    const J = {
      opacity: +!!((De = S.loaderConfig) != null && De.show)
    };
    return S.loaderConfig.style === "opaque" ? {
      ...J,
      "--background-color": "var(--did-primary-black-90)"
    } : {
      ...J,
      "--background-color": "var(--did-primary-black-00030)",
      "--backdrop-filter": "blur(4px)"
    };
  }, [S.loaderConfig]), tc = bo(() => {
    var J, De;
    return t && !!((De = (J = d == null ? void 0 : d.agent.knowledge) == null ? void 0 : J.embedder) != null && De.is_limited_language);
  }, [t, d == null ? void 0 : d.agent]), Ns = S.loaderConfig.show || [ue.Start, ue.Loading, ue.Buffering].includes(u) && !Ds, Ls = Ns || T.trim() === "";
  return E("div", {
    className: `didagent__embedded__container ${re ? "didagent__fullscreen" : ""}`,
    children: [E("div", {
      className: "didagent__embedded__container__loading",
      style: ec(),
      children: [E(Qe, {
        src: Uv,
        size: "64px",
        color: "var(--did-secondary-60)"
      }), E("span", {
        children: S.loaderConfig.text || ""
      })]
    }), E(KE, {
      posterImg: S.posterSrc,
      connectionState: p,
      streamState: u,
      srcObject: h,
      idleVideo: S.chatMode === M.Playground || (js = d == null ? void 0 : d.agent.presenter) == null ? void 0 : js.idle_video,
      muted: G,
      isBlur: S.chatMode === M.Maintenance,
      onVideoPlay: () => L(!0),
      onVideoStop: () => L(!1),
      onIdleLoad: () => b(!0)
    }), E(ky, {
      hide: ![M.TextOnly, M.Playground].includes(S.chatMode),
      content: `${S.chatMode === M.TextOnly && ((xs = d == null ? void 0 : d.agent) == null ? void 0 : xs.status) === "done" ? "Performance mode" : "You’re in preview mode"}, sound and face animations won’t show`
    }), E(gE, {
      name: (d == null ? void 0 : d.agent.preview_name) ?? "Agent",
      icon: d == null ? void 0 : d.agent.logo,
      displayRestart: g.length > 1 || S.chatMode === M.Maintenance,
      onRestart: Xa,
      restartDisabled: ![Q.Connected, Q.New, Q.Disconnected, Q.Fail].includes(p),
      displayMuteButton: !Ds,
      onMute: () => X((J) => !J),
      muted: G,
      isRestarting: m,
      closeClassName: n == null ? void 0 : n.closeClassName,
      onClose: r,
      onEasterEgg: () => {
        console.log("onEaster"), ce(!re);
      }
    }), E("div", {
      className: "didagent__filler"
    }), S.chatMode !== M.Maintenance && E("div", {
      className: "didagent__main__container",
      children: [E(UE, {
        messages: g,
        isLoading: x,
        ref: _,
        onRate: Za,
        onScroll: () => {
          _.current && (P.current = _.current.scrollHeight - _.current.scrollTop <= _.current.clientHeight + 20);
        },
        scrollToBottom: Os
      }), E(My, {
        display: tc,
        content: `This agent only interacts in ${(Bs = d == null ? void 0 : d.agent.presenter.voice) == null ? void 0 : Bs.language}`
      }), E(VE, {
        show: g.length <= 1 && !S.loaderConfig.show,
        enabled: p === Q.Connected || [M.TextOnly, M.Playground].includes(S.chatMode),
        messages: (d == null ? void 0 : d.starterMessages) ?? [],
        onClick: Dn
      }), E("div", {
        className: "didagent__main__input",
        style: {
          height: et > 1 ? "68px" : "52px",
          "--focus": Ya ? "white" : void 0
        },
        children: [E("textarea", {
          disabled: [M.Maintenance, M.DirectPlayback].includes(S.chatMode) || S.loaderConfig.show,
          ref: w,
          placeholder: "Type here...",
          value: T,
          maxLength: 790,
          onFocus: () => ks(!0),
          onBlur: () => ks(!1),
          onInput: (J) => {
            We(Ty(J.currentTarget)), O(J.currentTarget.value), Wc.includes(p) && f();
          },
          onKeyPress: async (J) => {
            !J.shiftKey && J.key === "Enter" && (J.preventDefault(), Ls || Dn(T));
          }
        }), E(dE, {
          onSend: () => Dn(T),
          onTranscript: Dn,
          text: T,
          isSttSendDisabled: Ns,
          isMessageSendDisabled: Ls,
          className: "didagent__main__input-send"
        })]
      })]
    })]
  });
}
function Rg({
  offline: t,
  isOwner: e,
  didApiUrl: n,
  didSocketApiUrl: r,
  onError: s,
  customMixpanelKey: o,
  onAgentReady: a,
  styles: i,
  onClose: c,
  enabled: u = !0
}) {
  const {
    configurations: p
  } = je($t);
  return window.localStorage.setItem("track_enabled", (p.track ?? !0).toString()), Uc.mixpanelKey = o || Uc.mixpanelKey, gy((d) => s == null ? void 0 : s(d, {})), E(_y, {
    auth: p.auth,
    didApiUrl: n ?? py,
    didSocketApiUrl: r ?? dy,
    children: E(Py, {
      agentId: p.agentId,
      enabled: u,
      onAgentReady: a,
      onError: s,
      children: E(JE, {
        enabled: u,
        offline: t,
        isOwner: e,
        styles: i,
        onClose: c,
        onError: s
      })
    })
  });
}
function GE(t, e) {
  return {
    cursor: t ? "pointer" : "progress",
    opacity: e || !t ? "0" : "1",
    pointerEvents: t ? "auto" : "none",
    border: e ? "none" : "3px solid var(--did-primary-black-300)",
    bottom: t ? "0" : "-50%"
  };
}
function QE(t) {
  const e = {
    opacity: +t,
    translate: t ? "0px -50%" : "0px -60%"
  };
  return t || (e.background = "transparent"), e;
}
function YE(t) {
  var h;
  const {
    configurations: e
  } = je($t), [n, r] = H(), [s, o] = H(!1), [a, i] = H(!1), [c, u] = H(!1), p = a && !c;
  if (oe(() => {
    var v;
    n && !((v = n.presenter) != null && v.idle_video) && n.preview_thumbnail && o(!0);
  }, [n]), oe(() => {
    s && setTimeout(() => {
      i(!0), setTimeout(() => {
        i(!1);
      }, 3e3);
    }, 3e3);
  }, [s]), !e.visible)
    return null;
  const d = (v) => {
    var g;
    r(v), (g = t.onAgentReady) == null || g.call(t, v);
  }, l = () => {
    var v;
    u(!1), (v = window.dataLayer) == null || v.push({
      event: "close_widget"
    });
  };
  return E("span", {
    className: "didagent__fabio",
    "data-position": e.position,
    "data-enabled": c,
    children: [E("button", {
      "data-testid": "didagent__fabio__button",
      style: GE(s, c),
      onClick: () => {
        var v;
        (v = window.dataLayer) == null || v.push({
          event: "open_widget"
        }), s && (u(!c), lt("agent-fab", {
          event: "click"
        }));
      },
      children: [E("div", {
        className: `didagent__fabio__speak_with ${c ? "didagent__transition_out" : ""}`,
        style: QE(p),
        children: E("div", {
          children: "Let's chat"
        })
      }), E("video", {
        src: (n == null ? void 0 : n.preview_url) ?? ((h = n == null ? void 0 : n.presenter) == null ? void 0 : h.idle_video),
        poster: n == null ? void 0 : n.preview_thumbnail,
        alt: "toggle fabio",
        autoPlay: !0,
        playsInline: !0,
        loop: !0,
        muted: !0,
        onLoadedData: () => {
          o(!0), lt("agent-fab", {
            event: "view"
          });
        }
      })]
    }), E("div", {
      onClick: (v) => v.stopPropagation(),
      className: "didagent__fabio__container",
      "data-enabled": c,
      "data-position": e.position,
      "data-orientation": e.orientation,
      children: E(Rg, {
        ...t,
        onClose: l,
        enabled: c,
        onAgentReady: d
      })
    })]
  });
}
let Ac = [];
function ZE() {
  if (Ac.length === 0) {
    const t = document.getElementById("d-id-agent-style");
    Ac = t ? [t] : [];
  }
  return Ac;
}
function XE(t) {
  const e = pt(null), {
    configurations: n
  } = je($t), [r, s] = H();
  return oe(() => {
    const o = ZE();
    if (n.agentId) {
      if (!n.auth)
        throw new Error("No auth provider");
    } else
      throw new Error("No agent provider");
    if (n.mode === "fabio") {
      if (e.current) {
        const a = e.current.shadowRoot ? e.current.shadowRoot : e.current.attachShadow({
          mode: "open"
        });
        o.forEach((i) => a.appendChild(i)), s(gh(E(YE, {
          ...t
        }), a));
      }
    } else if (n.mode === "full") {
      const a = typeof n.targetElement == "string" ? document.getElementById(n.targetElement) : n.targetElement;
      if (n.targetElement) {
        if (!a)
          throw new Error(`No target element for id: ${n.targetElement}`);
      } else
        throw new Error("No target element id");
      const i = a.shadowRoot ? a.shadowRoot : a.attachShadow({
        mode: "open"
      });
      o.forEach((c) => i.appendChild(c)), s(gh(E(Rg, {
        ...t
      }), i));
    } else
      throw new Error("Invalid mode");
  }, [n.mode, n.targetElement, n.agentId, n.auth]), E(xt, {
    children: [E("div", {
      ref: e,
      "data-testid": "didagent_root"
    }), r]
  });
}
const Pg = Object.prototype.toString;
function Eg(t) {
  switch (Pg.call(t)) {
    case "[object Error]":
    case "[object Exception]":
    case "[object DOMException]":
      return !0;
    default:
      return Et(t, Error);
  }
}
function ir(t, e) {
  return Pg.call(t) === `[object ${e}]`;
}
function Tg(t) {
  return ir(t, "ErrorEvent");
}
function Eh(t) {
  return ir(t, "DOMError");
}
function eT(t) {
  return ir(t, "DOMException");
}
function Pt(t) {
  return ir(t, "String");
}
function ep(t) {
  return typeof t == "object" && t !== null && "__sentry_template_string__" in t && "__sentry_template_values__" in t;
}
function tp(t) {
  return t === null || ep(t) || typeof t != "object" && typeof t != "function";
}
function Kn(t) {
  return ir(t, "Object");
}
function Ua(t) {
  return typeof Event < "u" && Et(t, Event);
}
function tT(t) {
  return typeof Element < "u" && Et(t, Element);
}
function nT(t) {
  return ir(t, "RegExp");
}
function Ha(t) {
  return !!(t && t.then && typeof t.then == "function");
}
function rT(t) {
  return Kn(t) && "nativeEvent" in t && "preventDefault" in t && "stopPropagation" in t;
}
function Et(t, e) {
  try {
    return t instanceof e;
  } catch {
    return !1;
  }
}
function Ig(t) {
  return !!(typeof t == "object" && t !== null && (t.__isVue || t._isVue));
}
function Fn(t, e = 0) {
  return typeof t != "string" || e === 0 || t.length <= e ? t : `${t.slice(0, e)}...`;
}
function Th(t, e) {
  if (!Array.isArray(t))
    return "";
  const n = [];
  for (let r = 0; r < t.length; r++) {
    const s = t[r];
    try {
      Ig(s) ? n.push("[VueViewModel]") : n.push(String(s));
    } catch {
      n.push("[value cannot be serialized]");
    }
  }
  return n.join(e);
}
function iT(t, e, n = !1) {
  return Pt(t) ? nT(e) ? e.test(t) : Pt(e) ? n ? t === e : t.includes(e) : !1 : !1;
}
function hn(t, e = [], n = !1) {
  return e.some((r) => iT(t, r, n));
}
function sT(t, e, n = 250, r, s, o, a) {
  if (!o.exception || !o.exception.values || !a || !Et(a.originalException, Error))
    return;
  const i = o.exception.values.length > 0 ? o.exception.values[o.exception.values.length - 1] : void 0;
  i && (o.exception.values = oT(
    Zc(
      t,
      e,
      s,
      a.originalException,
      r,
      o.exception.values,
      i,
      0
    ),
    n
  ));
}
function Zc(t, e, n, r, s, o, a, i) {
  if (o.length >= n + 1)
    return o;
  let c = [...o];
  if (Et(r[s], Error)) {
    Ih(a, i);
    const u = t(e, r[s]), p = c.length;
    wh(u, s, p, i), c = Zc(
      t,
      e,
      n,
      r[s],
      s,
      [u, ...c],
      u,
      p
    );
  }
  return Array.isArray(r.errors) && r.errors.forEach((u, p) => {
    if (Et(u, Error)) {
      Ih(a, i);
      const d = t(e, u), l = c.length;
      wh(d, `errors[${p}]`, l, i), c = Zc(
        t,
        e,
        n,
        u,
        s,
        [d, ...c],
        d,
        l
      );
    }
  }), c;
}
function Ih(t, e) {
  t.mechanism = t.mechanism || { type: "generic", handled: !0 }, t.mechanism = {
    ...t.mechanism,
    ...t.type === "AggregateError" && { is_exception_group: !0 },
    exception_id: e
  };
}
function wh(t, e, n, r) {
  t.mechanism = t.mechanism || { type: "generic", handled: !0 }, t.mechanism = {
    ...t.mechanism,
    type: "chained",
    source: e,
    exception_id: n,
    parent_id: r
  };
}
function oT(t, e) {
  return t.map((n) => (n.value && (n.value = Fn(n.value, e)), n));
}
const Y = globalThis;
function np(t, e, n) {
  const r = Y, s = r.__SENTRY__ = r.__SENTRY__ || {};
  return s[t] || (s[t] = e());
}
const $n = Y, aT = 80;
function Jn(t, e = {}) {
  if (!t)
    return "<unknown>";
  try {
    let n = t;
    const r = 5, s = [];
    let o = 0, a = 0;
    const i = " > ", c = i.length;
    let u;
    const p = Array.isArray(e) ? e : e.keyAttrs, d = !Array.isArray(e) && e.maxStringLength || aT;
    for (; n && o++ < r && (u = cT(n, p), !(u === "html" || o > 1 && a + s.length * c + u.length >= d)); )
      s.push(u), a += u.length, n = n.parentNode;
    return s.reverse().join(i);
  } catch {
    return "<unknown>";
  }
}
function cT(t, e) {
  const n = t, r = [];
  let s, o, a, i, c;
  if (!n || !n.tagName)
    return "";
  if ($n.HTMLElement && n instanceof HTMLElement && n.dataset) {
    if (n.dataset.sentryComponent)
      return n.dataset.sentryComponent;
    if (n.dataset.sentryElement)
      return n.dataset.sentryElement;
  }
  r.push(n.tagName.toLowerCase());
  const u = e && e.length ? e.filter((d) => n.getAttribute(d)).map((d) => [d, n.getAttribute(d)]) : null;
  if (u && u.length)
    u.forEach((d) => {
      r.push(`[${d[0]}="${d[1]}"]`);
    });
  else if (n.id && r.push(`#${n.id}`), s = n.className, s && Pt(s))
    for (o = s.split(/\s+/), c = 0; c < o.length; c++)
      r.push(`.${o[c]}`);
  const p = ["aria-label", "type", "name", "title", "alt"];
  for (c = 0; c < p.length; c++)
    a = p[c], i = n.getAttribute(a), i && r.push(`[${a}="${i}"]`);
  return r.join("");
}
function uT() {
  try {
    return $n.document.location.href;
  } catch {
    return "";
  }
}
function pT(t) {
  return $n.document && $n.document.querySelector ? $n.document.querySelector(t) : null;
}
function wg(t) {
  if (!$n.HTMLElement)
    return null;
  let e = t;
  const n = 5;
  for (let r = 0; r < n; r++) {
    if (!e)
      return null;
    if (e instanceof HTMLElement) {
      if (e.dataset.sentryComponent)
        return e.dataset.sentryComponent;
      if (e.dataset.sentryElement)
        return e.dataset.sentryElement;
    }
    e = e.parentNode;
  }
  return null;
}
const sr = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__, dT = "Sentry Logger ", Xc = [
  "debug",
  "info",
  "warn",
  "error",
  "log",
  "assert",
  "trace"
], So = {};
function Ts(t) {
  if (!("console" in Y))
    return t();
  const e = Y.console, n = {}, r = Object.keys(So);
  r.forEach((s) => {
    const o = So[s];
    n[s] = e[s], e[s] = o;
  });
  try {
    return t();
  } finally {
    r.forEach((s) => {
      e[s] = n[s];
    });
  }
}
function lT() {
  let t = !1;
  const e = {
    enable: () => {
      t = !0;
    },
    disable: () => {
      t = !1;
    },
    isEnabled: () => t
  };
  return sr ? Xc.forEach((n) => {
    e[n] = (...r) => {
      t && Ts(() => {
        Y.console[n](`${dT}[${n}]:`, ...r);
      });
    };
  }) : Xc.forEach((n) => {
    e[n] = () => {
    };
  }), e;
}
const I = lT(), hT = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;
function vT(t) {
  return t === "http" || t === "https";
}
function Is(t, e = !1) {
  const { host: n, path: r, pass: s, port: o, projectId: a, protocol: i, publicKey: c } = t;
  return `${i}://${c}${e && s ? `:${s}` : ""}@${n}${o ? `:${o}` : ""}/${r && `${r}/`}${a}`;
}
function fT(t) {
  const e = hT.exec(t);
  if (!e) {
    Ts(() => {
      console.error(`Invalid Sentry Dsn: ${t}`);
    });
    return;
  }
  const [n, r, s = "", o, a = "", i] = e.slice(1);
  let c = "", u = i;
  const p = u.split("/");
  if (p.length > 1 && (c = p.slice(0, -1).join("/"), u = p.pop()), u) {
    const d = u.match(/^\d+/);
    d && (u = d[0]);
  }
  return bg({ host: o, pass: s, path: c, projectId: u, port: a, protocol: n, publicKey: r });
}
function bg(t) {
  return {
    protocol: t.protocol,
    publicKey: t.publicKey || "",
    pass: t.pass || "",
    host: t.host,
    port: t.port || "",
    path: t.path || "",
    projectId: t.projectId
  };
}
function gT(t) {
  if (!sr)
    return !0;
  const { port: e, projectId: n, protocol: r } = t;
  return ["protocol", "publicKey", "host", "projectId"].find((a) => t[a] ? !1 : (I.error(`Invalid Sentry Dsn: ${a} missing`), !0)) ? !1 : n.match(/^\d+$/) ? vT(r) ? e && isNaN(parseInt(e, 10)) ? (I.error(`Invalid Sentry Dsn: Invalid port ${e}`), !1) : !0 : (I.error(`Invalid Sentry Dsn: Invalid protocol ${r}`), !1) : (I.error(`Invalid Sentry Dsn: Invalid projectId ${n}`), !1);
}
function mT(t) {
  const e = typeof t == "string" ? fT(t) : bg(t);
  if (!(!e || !gT(e)))
    return e;
}
class ut extends Error {
  /** Display name of this error instance. */
  constructor(e, n = "warn") {
    super(e), this.message = e, this.name = new.target.prototype.constructor.name, Object.setPrototypeOf(this, new.target.prototype), this.logLevel = n;
  }
}
function Pe(t, e, n) {
  if (!(e in t))
    return;
  const r = t[e], s = n(r);
  typeof s == "function" && Ag(s, r), t[e] = s;
}
function rt(t, e, n) {
  try {
    Object.defineProperty(t, e, {
      // enumerable: false, // the default, so we can save on bundle size by not explicitly setting it
      value: n,
      writable: !0,
      configurable: !0
    });
  } catch {
    sr && I.log(`Failed to add non-enumerable property "${e}" to object`, t);
  }
}
function Ag(t, e) {
  try {
    const n = e.prototype || {};
    t.prototype = e.prototype = n, rt(t, "__sentry_original__", e);
  } catch {
  }
}
function rp(t) {
  return t.__sentry_original__;
}
function ST(t) {
  return Object.keys(t).map((e) => `${encodeURIComponent(e)}=${encodeURIComponent(t[e])}`).join("&");
}
function Mg(t) {
  if (Eg(t))
    return {
      message: t.message,
      name: t.name,
      stack: t.stack,
      ...Ah(t)
    };
  if (Ua(t)) {
    const e = {
      type: t.type,
      target: bh(t.target),
      currentTarget: bh(t.currentTarget),
      ...Ah(t)
    };
    return typeof CustomEvent < "u" && Et(t, CustomEvent) && (e.detail = t.detail), e;
  } else
    return t;
}
function bh(t) {
  try {
    return tT(t) ? Jn(t) : Object.prototype.toString.call(t);
  } catch {
    return "<unknown>";
  }
}
function Ah(t) {
  if (typeof t == "object" && t !== null) {
    const e = {};
    for (const n in t)
      Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
    return e;
  } else
    return {};
}
function yT(t, e = 40) {
  const n = Object.keys(Mg(t));
  if (n.sort(), !n.length)
    return "[object has no keys]";
  if (n[0].length >= e)
    return Fn(n[0], e);
  for (let r = n.length; r > 0; r--) {
    const s = n.slice(0, r).join(", ");
    if (!(s.length > e))
      return r === n.length ? s : Fn(s, e);
  }
  return "";
}
function ze(t) {
  return eu(t, /* @__PURE__ */ new Map());
}
function eu(t, e) {
  if (CT(t)) {
    const n = e.get(t);
    if (n !== void 0)
      return n;
    const r = {};
    e.set(t, r);
    for (const s of Object.keys(t))
      typeof t[s] < "u" && (r[s] = eu(t[s], e));
    return r;
  }
  if (Array.isArray(t)) {
    const n = e.get(t);
    if (n !== void 0)
      return n;
    const r = [];
    return e.set(t, r), t.forEach((s) => {
      r.push(eu(s, e));
    }), r;
  }
  return t;
}
function CT(t) {
  if (!Kn(t))
    return !1;
  try {
    const e = Object.getPrototypeOf(t).constructor.name;
    return !e || e === "Object";
  } catch {
    return !0;
  }
}
const kg = 50, or = "?", Mh = /\(error: (.*)\)/, kh = /captureMessage|captureException/;
function Og(...t) {
  const e = t.sort((n, r) => n[0] - r[0]).map((n) => n[1]);
  return (n, r = 0, s = 0) => {
    const o = [], a = n.split(`
`);
    for (let i = r; i < a.length; i++) {
      const c = a[i];
      if (c.length > 1024)
        continue;
      const u = Mh.test(c) ? c.replace(Mh, "$1") : c;
      if (!u.match(/\S*Error: /)) {
        for (const p of e) {
          const d = p(u);
          if (d) {
            o.push(d);
            break;
          }
        }
        if (o.length >= kg + s)
          break;
      }
    }
    return RT(o.slice(s));
  };
}
function _T(t) {
  return Array.isArray(t) ? Og(...t) : t;
}
function RT(t) {
  if (!t.length)
    return [];
  const e = Array.from(t);
  return /sentryWrapped/.test(e[e.length - 1].function || "") && e.pop(), e.reverse(), kh.test(e[e.length - 1].function || "") && (e.pop(), kh.test(e[e.length - 1].function || "") && e.pop()), e.slice(0, kg).map((n) => ({
    ...n,
    filename: n.filename || e[e.length - 1].filename,
    function: n.function || or
  }));
}
const Mc = "<anonymous>";
function Tt(t) {
  try {
    return !t || typeof t != "function" ? Mc : t.name || Mc;
  } catch {
    return Mc;
  }
}
const so = {}, Oh = {};
function In(t, e) {
  so[t] = so[t] || [], so[t].push(e);
}
function wn(t, e) {
  Oh[t] || (e(), Oh[t] = !0);
}
function nt(t, e) {
  const n = t && so[t];
  if (n)
    for (const r of n)
      try {
        r(e);
      } catch (s) {
        sr && I.error(
          `Error while triggering instrumentation handler.
Type: ${t}
Name: ${Tt(r)}
Error:`,
          s
        );
      }
}
function PT(t) {
  const e = "console";
  In(e, t), wn(e, ET);
}
function ET() {
  "console" in Y && Xc.forEach(function(t) {
    t in Y.console && Pe(Y.console, t, function(e) {
      return So[t] = e, function(...n) {
        nt("console", { args: n, level: t });
        const s = So[t];
        s && s.apply(Y.console, n);
      };
    });
  });
}
const tu = Y;
function Dg() {
  if (!("fetch" in tu))
    return !1;
  try {
    return new Headers(), new Request("http://www.example.com"), new Response(), !0;
  } catch {
    return !1;
  }
}
function nu(t) {
  return t && /^function\s+\w+\(\)\s+\{\s+\[native code\]\s+\}$/.test(t.toString());
}
function TT() {
  if (typeof EdgeRuntime == "string")
    return !0;
  if (!Dg())
    return !1;
  if (nu(tu.fetch))
    return !0;
  let t = !1;
  const e = tu.document;
  if (e && typeof e.createElement == "function")
    try {
      const n = e.createElement("iframe");
      n.hidden = !0, e.head.appendChild(n), n.contentWindow && n.contentWindow.fetch && (t = nu(n.contentWindow.fetch)), e.head.removeChild(n);
    } catch (n) {
      sr && I.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", n);
    }
  return t;
}
const Ng = 1e3;
function ws() {
  return Date.now() / Ng;
}
function IT() {
  const { performance: t } = Y;
  if (!t || !t.now)
    return ws;
  const e = Date.now() - t.now(), n = t.timeOrigin == null ? e : t.timeOrigin;
  return () => (n + t.now()) / Ng;
}
const Ue = IT(), Ze = (() => {
  const { performance: t } = Y;
  if (!t || !t.now)
    return;
  const e = 3600 * 1e3, n = t.now(), r = Date.now(), s = t.timeOrigin ? Math.abs(t.timeOrigin + n - r) : e, o = s < e, a = t.timing && t.timing.navigationStart, c = typeof a == "number" ? Math.abs(a + n - r) : e, u = c < e;
  return o || u ? s <= c ? t.timeOrigin : a : r;
})();
function Lg(t) {
  const e = "fetch";
  In(e, t), wn(e, wT);
}
function wT() {
  TT() && Pe(Y, "fetch", function(t) {
    return function(...e) {
      const { method: n, url: r } = bT(e), s = {
        args: e,
        fetchData: {
          method: n,
          url: r
        },
        startTimestamp: Ue() * 1e3
      };
      return nt("fetch", {
        ...s
      }), t.apply(Y, e).then(
        (o) => {
          const a = {
            ...s,
            endTimestamp: Ue() * 1e3,
            response: o
          };
          return nt("fetch", a), o;
        },
        (o) => {
          const a = {
            ...s,
            endTimestamp: Ue() * 1e3,
            error: o
          };
          throw nt("fetch", a), o;
        }
      );
    };
  });
}
function ru(t, e) {
  return !!t && typeof t == "object" && !!t[e];
}
function Dh(t) {
  return typeof t == "string" ? t : t ? ru(t, "url") ? t.url : t.toString ? t.toString() : "" : "";
}
function bT(t) {
  if (t.length === 0)
    return { method: "GET", url: "" };
  if (t.length === 2) {
    const [n, r] = t;
    return {
      url: Dh(n),
      method: ru(r, "method") ? String(r.method).toUpperCase() : "GET"
    };
  }
  const e = t[0];
  return {
    url: Dh(e),
    method: ru(e, "method") ? String(e.method).toUpperCase() : "GET"
  };
}
let Vs = null;
function zg(t) {
  const e = "error";
  In(e, t), wn(e, AT);
}
function AT() {
  Vs = Y.onerror, Y.onerror = function(t, e, n, r, s) {
    return nt("error", {
      column: r,
      error: s,
      line: n,
      msg: t,
      url: e
    }), Vs && !Vs.__SENTRY_LOADER__ ? Vs.apply(this, arguments) : !1;
  }, Y.onerror.__SENTRY_INSTRUMENTED__ = !0;
}
let Ks = null;
function jg(t) {
  const e = "unhandledrejection";
  In(e, t), wn(e, MT);
}
function MT() {
  Ks = Y.onunhandledrejection, Y.onunhandledrejection = function(t) {
    return nt("unhandledrejection", t), Ks && !Ks.__SENTRY_LOADER__ ? Ks.apply(this, arguments) : !0;
  }, Y.onunhandledrejection.__SENTRY_INSTRUMENTED__ = !0;
}
function kT() {
  return "npm";
}
function OT() {
  const t = typeof WeakSet == "function", e = t ? /* @__PURE__ */ new WeakSet() : [];
  function n(s) {
    if (t)
      return e.has(s) ? !0 : (e.add(s), !1);
    for (let o = 0; o < e.length; o++)
      if (e[o] === s)
        return !0;
    return e.push(s), !1;
  }
  function r(s) {
    if (t)
      e.delete(s);
    else
      for (let o = 0; o < e.length; o++)
        if (e[o] === s) {
          e.splice(o, 1);
          break;
        }
  }
  return [n, r];
}
function se() {
  const t = Y, e = t.crypto || t.msCrypto;
  let n = () => Math.random() * 16;
  try {
    if (e && e.randomUUID)
      return e.randomUUID().replace(/-/g, "");
    e && e.getRandomValues && (n = () => {
      const r = new Uint8Array(1);
      return e.getRandomValues(r), r[0];
    });
  } catch {
  }
  return ("10000000100040008000" + 1e11).replace(
    /[018]/g,
    (r) => (
      // eslint-disable-next-line no-bitwise
      (r ^ (n() & 15) >> r / 4).toString(16)
    )
  );
}
function xg(t) {
  return t.exception && t.exception.values ? t.exception.values[0] : void 0;
}
function pn(t) {
  const { message: e, event_id: n } = t;
  if (e)
    return e;
  const r = xg(t);
  return r ? r.type && r.value ? `${r.type}: ${r.value}` : r.type || r.value || n || "<unknown>" : n || "<unknown>";
}
function iu(t, e, n) {
  const r = t.exception = t.exception || {}, s = r.values = r.values || [], o = s[0] = s[0] || {};
  o.value || (o.value = e || ""), o.type || (o.type = "Error");
}
function cs(t, e) {
  const n = xg(t);
  if (!n)
    return;
  const r = { type: "generic", handled: !0 }, s = n.mechanism;
  if (n.mechanism = { ...r, ...s, ...e }, e && "data" in e) {
    const o = { ...s && s.data, ...e.data };
    n.mechanism.data = o;
  }
}
function Nh(t) {
  if (t && t.__sentry_captured__)
    return !0;
  try {
    rt(t, "__sentry_captured__", !0);
  } catch {
  }
  return !1;
}
function Bg(t) {
  return Array.isArray(t) ? t : [t];
}
function Ot(t, e = 100, n = 1 / 0) {
  try {
    return su("", t, e, n);
  } catch (r) {
    return { ERROR: `**non-serializable** (${r})` };
  }
}
function qg(t, e = 3, n = 100 * 1024) {
  const r = Ot(t, e);
  return zT(r) > n ? qg(t, e - 1, n) : r;
}
function su(t, e, n = 1 / 0, r = 1 / 0, s = OT()) {
  const [o, a] = s;
  if (e == null || // this matches null and undefined -> eqeq not eqeqeq
  ["number", "boolean", "string"].includes(typeof e) && !Number.isNaN(e))
    return e;
  const i = DT(t, e);
  if (!i.startsWith("[object "))
    return i;
  if (e.__sentry_skip_normalization__)
    return e;
  const c = typeof e.__sentry_override_normalization_depth__ == "number" ? e.__sentry_override_normalization_depth__ : n;
  if (c === 0)
    return i.replace("object ", "");
  if (o(e))
    return "[Circular ~]";
  const u = e;
  if (u && typeof u.toJSON == "function")
    try {
      const h = u.toJSON();
      return su("", h, c - 1, r, s);
    } catch {
    }
  const p = Array.isArray(e) ? [] : {};
  let d = 0;
  const l = Mg(e);
  for (const h in l) {
    if (!Object.prototype.hasOwnProperty.call(l, h))
      continue;
    if (d >= r) {
      p[h] = "[MaxProperties ~]";
      break;
    }
    const v = l[h];
    p[h] = su(h, v, c - 1, r, s), d++;
  }
  return a(e), p;
}
function DT(t, e) {
  try {
    if (t === "domain" && e && typeof e == "object" && e._events)
      return "[Domain]";
    if (t === "domainEmitter")
      return "[DomainEmitter]";
    if (typeof global < "u" && e === global)
      return "[Global]";
    if (typeof window < "u" && e === window)
      return "[Window]";
    if (typeof document < "u" && e === document)
      return "[Document]";
    if (Ig(e))
      return "[VueViewModel]";
    if (rT(e))
      return "[SyntheticEvent]";
    if (typeof e == "number" && e !== e)
      return "[NaN]";
    if (typeof e == "function")
      return `[Function: ${Tt(e)}]`;
    if (typeof e == "symbol")
      return `[${String(e)}]`;
    if (typeof e == "bigint")
      return `[BigInt: ${String(e)}]`;
    const n = NT(e);
    return /^HTML(\w*)Element$/.test(n) ? `[HTMLElement: ${n}]` : `[object ${n}]`;
  } catch (n) {
    return `**non-serializable** (${n})`;
  }
}
function NT(t) {
  const e = Object.getPrototypeOf(t);
  return e ? e.constructor.name : "null prototype";
}
function LT(t) {
  return ~-encodeURI(t).split(/%..|./).length;
}
function zT(t) {
  return LT(JSON.stringify(t));
}
var yt;
(function(t) {
  t[t.PENDING = 0] = "PENDING";
  const n = 1;
  t[t.RESOLVED = n] = "RESOLVED";
  const r = 2;
  t[t.REJECTED = r] = "REJECTED";
})(yt || (yt = {}));
function Cn(t) {
  return new Ge((e) => {
    e(t);
  });
}
function yo(t) {
  return new Ge((e, n) => {
    n(t);
  });
}
class Ge {
  constructor(e) {
    Ge.prototype.__init.call(this), Ge.prototype.__init2.call(this), Ge.prototype.__init3.call(this), Ge.prototype.__init4.call(this), this._state = yt.PENDING, this._handlers = [];
    try {
      e(this._resolve, this._reject);
    } catch (n) {
      this._reject(n);
    }
  }
  /** JSDoc */
  then(e, n) {
    return new Ge((r, s) => {
      this._handlers.push([
        !1,
        (o) => {
          if (!e)
            r(o);
          else
            try {
              r(e(o));
            } catch (a) {
              s(a);
            }
        },
        (o) => {
          if (!n)
            s(o);
          else
            try {
              r(n(o));
            } catch (a) {
              s(a);
            }
        }
      ]), this._executeHandlers();
    });
  }
  /** JSDoc */
  catch(e) {
    return this.then((n) => n, e);
  }
  /** JSDoc */
  finally(e) {
    return new Ge((n, r) => {
      let s, o;
      return this.then(
        (a) => {
          o = !1, s = a, e && e();
        },
        (a) => {
          o = !0, s = a, e && e();
        }
      ).then(() => {
        if (o) {
          r(s);
          return;
        }
        n(s);
      });
    });
  }
  /** JSDoc */
  __init() {
    this._resolve = (e) => {
      this._setResult(yt.RESOLVED, e);
    };
  }
  /** JSDoc */
  __init2() {
    this._reject = (e) => {
      this._setResult(yt.REJECTED, e);
    };
  }
  /** JSDoc */
  __init3() {
    this._setResult = (e, n) => {
      if (this._state === yt.PENDING) {
        if (Ha(n)) {
          n.then(this._resolve, this._reject);
          return;
        }
        this._state = e, this._value = n, this._executeHandlers();
      }
    };
  }
  /** JSDoc */
  __init4() {
    this._executeHandlers = () => {
      if (this._state === yt.PENDING)
        return;
      const e = this._handlers.slice();
      this._handlers = [], e.forEach((n) => {
        n[0] || (this._state === yt.RESOLVED && n[1](this._value), this._state === yt.REJECTED && n[2](this._value), n[0] = !0);
      });
    };
  }
}
function jT(t) {
  const e = [];
  function n() {
    return t === void 0 || e.length < t;
  }
  function r(a) {
    return e.splice(e.indexOf(a), 1)[0];
  }
  function s(a) {
    if (!n())
      return yo(new ut("Not adding Promise because buffer limit was reached."));
    const i = a();
    return e.indexOf(i) === -1 && e.push(i), i.then(() => r(i)).then(
      null,
      () => r(i).then(null, () => {
      })
    ), i;
  }
  function o(a) {
    return new Ge((i, c) => {
      let u = e.length;
      if (!u)
        return i(!0);
      const p = setTimeout(() => {
        a && a > 0 && i(!1);
      }, a);
      e.forEach((d) => {
        Cn(d).then(() => {
          --u || (clearTimeout(p), i(!0));
        }, c);
      });
    });
  }
  return {
    $: e,
    add: s,
    drain: o
  };
}
function vn(t) {
  if (!t)
    return {};
  const e = t.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
  if (!e)
    return {};
  const n = e[6] || "", r = e[8] || "";
  return {
    host: e[4],
    path: e[5],
    protocol: e[2],
    search: n,
    hash: r,
    relative: e[5] + n + r
    // everything minus origin
  };
}
const xT = ["fatal", "error", "warning", "log", "info", "debug"];
function BT(t) {
  return t === "warn" ? "warning" : xT.includes(t) ? t : "log";
}
const ou = "baggage", Fg = "sentry-", qT = /^sentry-/, FT = 8192;
function $T(t) {
  const e = UT(t);
  if (!e)
    return;
  const n = Object.entries(e).reduce((r, [s, o]) => {
    if (s.match(qT)) {
      const a = s.slice(Fg.length);
      r[a] = o;
    }
    return r;
  }, {});
  if (Object.keys(n).length > 0)
    return n;
}
function $g(t) {
  if (!t)
    return;
  const e = Object.entries(t).reduce(
    (n, [r, s]) => (s && (n[`${Fg}${r}`] = s), n),
    {}
  );
  return HT(e);
}
function UT(t) {
  if (!(!t || !Pt(t) && !Array.isArray(t)))
    return Array.isArray(t) ? t.reduce((e, n) => {
      const r = Lh(n);
      for (const s of Object.keys(r))
        e[s] = r[s];
      return e;
    }, {}) : Lh(t);
}
function Lh(t) {
  return t.split(",").map((e) => e.split("=").map((n) => decodeURIComponent(n.trim()))).reduce((e, [n, r]) => (e[n] = r, e), {});
}
function HT(t) {
  if (Object.keys(t).length !== 0)
    return Object.entries(t).reduce((e, [n, r], s) => {
      const o = `${encodeURIComponent(n)}=${encodeURIComponent(r)}`, a = s === 0 ? o : `${e},${o}`;
      return a.length > FT ? (sr && I.warn(
        `Not adding key: ${n} with val: ${r} to baggage header due to exceeding baggage size limits.`
      ), e) : a;
    }, "");
}
const WT = new RegExp(
  "^[ \\t]*([0-9a-f]{32})?-?([0-9a-f]{16})?-?([01])?[ \\t]*$"
  // whitespace
);
function VT(t) {
  if (!t)
    return;
  const e = t.match(WT);
  if (!e)
    return;
  let n;
  return e[3] === "1" ? n = !0 : e[3] === "0" && (n = !1), {
    traceId: e[1],
    parentSampled: n,
    parentSpanId: e[2]
  };
}
function KT(t, e) {
  const n = VT(t), r = $T(e), { traceId: s, parentSpanId: o, parentSampled: a } = n || {};
  return n ? {
    traceId: s || se(),
    parentSpanId: o || se().substring(16),
    spanId: se().substring(16),
    sampled: a,
    dsc: r || {}
    // If we have traceparent data but no DSC it means we are not head of trace and we must freeze it
  } : {
    traceId: s || se(),
    spanId: se().substring(16)
  };
}
function ip(t = se(), e = se().substring(16), n) {
  let r = "";
  return n !== void 0 && (r = n ? "-1" : "-0"), `${t}-${e}${r}`;
}
function ar(t, e = []) {
  return [t, e];
}
function JT(t, e) {
  const [n, r] = t;
  return [n, [...r, e]];
}
function zh(t, e) {
  const n = t[1];
  for (const r of n) {
    const s = r[0].type;
    if (e(r, s))
      return !0;
  }
  return !1;
}
function au(t) {
  return Y.__SENTRY__ && Y.__SENTRY__.encodePolyfill ? Y.__SENTRY__.encodePolyfill(t) : new TextEncoder().encode(t);
}
function GT(t) {
  const [e, n] = t;
  let r = JSON.stringify(e);
  function s(o) {
    typeof r == "string" ? r = typeof o == "string" ? r + o : [au(r), o] : r.push(typeof o == "string" ? au(o) : o);
  }
  for (const o of n) {
    const [a, i] = o;
    if (s(`
${JSON.stringify(a)}
`), typeof i == "string" || i instanceof Uint8Array)
      s(i);
    else {
      let c;
      try {
        c = JSON.stringify(i);
      } catch {
        c = JSON.stringify(Ot(i));
      }
      s(c);
    }
  }
  return typeof r == "string" ? r : QT(r);
}
function QT(t) {
  const e = t.reduce((s, o) => s + o.length, 0), n = new Uint8Array(e);
  let r = 0;
  for (const s of t)
    n.set(s, r), r += s.length;
  return n;
}
function YT(t) {
  return [{
    type: "span"
  }, t];
}
function ZT(t) {
  const e = typeof t.data == "string" ? au(t.data) : t.data;
  return [
    ze({
      type: "attachment",
      length: e.length,
      filename: t.filename,
      content_type: t.contentType,
      attachment_type: t.attachmentType
    }),
    e
  ];
}
const XT = {
  session: "session",
  sessions: "session",
  attachment: "attachment",
  transaction: "transaction",
  event: "error",
  client_report: "internal",
  user_report: "default",
  profile: "profile",
  replay_event: "replay",
  replay_recording: "replay",
  check_in: "monitor",
  feedback: "feedback",
  span: "span",
  statsd: "metric_bucket"
};
function jh(t) {
  return XT[t];
}
function Ug(t) {
  if (!t || !t.sdk)
    return;
  const { name: e, version: n } = t.sdk;
  return { name: e, version: n };
}
function eI(t, e, n, r) {
  const s = t.sdkProcessingMetadata && t.sdkProcessingMetadata.dynamicSamplingContext;
  return {
    event_id: t.event_id,
    sent_at: (/* @__PURE__ */ new Date()).toISOString(),
    ...e && { sdk: e },
    ...!!n && r && { dsn: Is(r) },
    ...s && {
      trace: ze({ ...s })
    }
  };
}
function tI(t, e, n) {
  const r = [
    { type: "client_report" },
    {
      timestamp: ws(),
      discarded_events: t
    }
  ];
  return ar(e ? { dsn: e } : {}, [r]);
}
const nI = 60 * 1e3;
function rI(t, e = Date.now()) {
  const n = parseInt(`${t}`, 10);
  if (!isNaN(n))
    return n * 1e3;
  const r = Date.parse(`${t}`);
  return isNaN(r) ? nI : r - e;
}
function iI(t, e) {
  return t[e] || t.all || 0;
}
function sI(t, e, n = Date.now()) {
  return iI(t, e) > n;
}
function oI(t, { statusCode: e, headers: n }, r = Date.now()) {
  const s = {
    ...t
  }, o = n && n["x-sentry-rate-limits"], a = n && n["retry-after"];
  if (o)
    for (const i of o.trim().split(",")) {
      const [c, u, , , p] = i.split(":", 5), d = parseInt(c, 10), l = (isNaN(d) ? 60 : d) * 1e3;
      if (!u)
        s.all = r + l;
      else
        for (const h of u.split(";"))
          h === "metric_bucket" ? (!p || p.split(";").includes("custom")) && (s[h] = r + l) : s[h] = r + l;
    }
  else
    a ? s.all = r + rI(a, r) : e === 429 && (s.all = r + 60 * 1e3);
  return s;
}
function aI(t) {
  let e, n = t[0], r = 1;
  for (; r < t.length; ) {
    const s = t[r], o = t[r + 1];
    if (r += 2, (s === "optionalAccess" || s === "optionalCall") && n == null)
      return;
    s === "access" || s === "optionalAccess" ? (e = n, n = o(n)) : (s === "call" || s === "optionalCall") && (n = o((...a) => n.call(e, ...a)), e = void 0);
  }
  return n;
}
const Js = Y;
function cI() {
  const t = Js.chrome, e = t && t.app && t.app.runtime, n = "history" in Js && !!Js.history.pushState && !!Js.history.replaceState;
  return !e && n;
}
const K = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__;
function bn() {
  return Wa(Y), Y;
}
function Wa(t) {
  return t.__SENTRY__ || (t.__SENTRY__ = {
    extensions: {}
  }), t.__SENTRY__;
}
function uI(t) {
  const e = Ue(), n = {
    sid: se(),
    init: !0,
    timestamp: e,
    started: e,
    duration: 0,
    status: "ok",
    errors: 0,
    ignoreDuration: !1,
    toJSON: () => dI(n)
  };
  return t && Gn(n, t), n;
}
function Gn(t, e = {}) {
  if (e.user && (!t.ipAddress && e.user.ip_address && (t.ipAddress = e.user.ip_address), !t.did && !e.did && (t.did = e.user.id || e.user.email || e.user.username)), t.timestamp = e.timestamp || Ue(), e.abnormal_mechanism && (t.abnormal_mechanism = e.abnormal_mechanism), e.ignoreDuration && (t.ignoreDuration = e.ignoreDuration), e.sid && (t.sid = e.sid.length === 32 ? e.sid : se()), e.init !== void 0 && (t.init = e.init), !t.did && e.did && (t.did = `${e.did}`), typeof e.started == "number" && (t.started = e.started), t.ignoreDuration)
    t.duration = void 0;
  else if (typeof e.duration == "number")
    t.duration = e.duration;
  else {
    const n = t.timestamp - t.started;
    t.duration = n >= 0 ? n : 0;
  }
  e.release && (t.release = e.release), e.environment && (t.environment = e.environment), !t.ipAddress && e.ipAddress && (t.ipAddress = e.ipAddress), !t.userAgent && e.userAgent && (t.userAgent = e.userAgent), typeof e.errors == "number" && (t.errors = e.errors), e.status && (t.status = e.status);
}
function pI(t, e) {
  let n = {};
  t.status === "ok" && (n = { status: "exited" }), Gn(t, n);
}
function dI(t) {
  return ze({
    sid: `${t.sid}`,
    init: t.init,
    // Make sure that sec is converted to ms for date constructor
    started: new Date(t.started * 1e3).toISOString(),
    timestamp: new Date(t.timestamp * 1e3).toISOString(),
    status: t.status,
    errors: t.errors,
    did: typeof t.did == "number" || typeof t.did == "string" ? `${t.did}` : void 0,
    duration: t.duration,
    abnormal_mechanism: t.abnormal_mechanism,
    attrs: {
      release: t.release,
      environment: t.environment,
      ip_address: t.ipAddress,
      user_agent: t.userAgent
    }
  });
}
const cu = "_sentrySpan";
function us(t, e) {
  e ? rt(t, cu, e) : delete t[cu];
}
function Co(t) {
  return t[cu];
}
const lI = 100;
class sp {
  /** Flag if notifying is happening. */
  /** Callback for client to receive scope changes. */
  /** Callback list that will be called during event processing. */
  /** Array of breadcrumbs. */
  /** User */
  /** Tags */
  /** Extra */
  /** Contexts */
  /** Attachments */
  /** Propagation Context for distributed tracing */
  /**
   * A place to stash data which is needed at some point in the SDK's event processing pipeline but which shouldn't get
   * sent to Sentry
   */
  /** Fingerprint */
  /** Severity */
  /**
   * Transaction Name
   *
   * IMPORTANT: The transaction name on the scope has nothing to do with root spans/transaction objects.
   * It's purpose is to assign a transaction to the scope that's added to non-transaction events.
   */
  /** Session */
  /** Request Mode Session Status */
  /** The client on this scope */
  /** Contains the last event id of a captured event.  */
  // NOTE: Any field which gets added here should get added not only to the constructor but also to the `clone` method.
  constructor() {
    this._notifyingListeners = !1, this._scopeListeners = [], this._eventProcessors = [], this._breadcrumbs = [], this._attachments = [], this._user = {}, this._tags = {}, this._extra = {}, this._contexts = {}, this._sdkProcessingMetadata = {}, this._propagationContext = xh();
  }
  /**
   * @inheritDoc
   */
  clone() {
    const e = new sp();
    return e._breadcrumbs = [...this._breadcrumbs], e._tags = { ...this._tags }, e._extra = { ...this._extra }, e._contexts = { ...this._contexts }, e._user = this._user, e._level = this._level, e._session = this._session, e._transactionName = this._transactionName, e._fingerprint = this._fingerprint, e._eventProcessors = [...this._eventProcessors], e._requestSession = this._requestSession, e._attachments = [...this._attachments], e._sdkProcessingMetadata = { ...this._sdkProcessingMetadata }, e._propagationContext = { ...this._propagationContext }, e._client = this._client, e._lastEventId = this._lastEventId, us(e, Co(this)), e;
  }
  /**
   * @inheritDoc
   */
  setClient(e) {
    this._client = e;
  }
  /**
   * @inheritDoc
   */
  setLastEventId(e) {
    this._lastEventId = e;
  }
  /**
   * @inheritDoc
   */
  getClient() {
    return this._client;
  }
  /**
   * @inheritDoc
   */
  lastEventId() {
    return this._lastEventId;
  }
  /**
   * @inheritDoc
   */
  addScopeListener(e) {
    this._scopeListeners.push(e);
  }
  /**
   * @inheritDoc
   */
  addEventProcessor(e) {
    return this._eventProcessors.push(e), this;
  }
  /**
   * @inheritDoc
   */
  setUser(e) {
    return this._user = e || {
      email: void 0,
      id: void 0,
      ip_address: void 0,
      username: void 0
    }, this._session && Gn(this._session, { user: e }), this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  getUser() {
    return this._user;
  }
  /**
   * @inheritDoc
   */
  getRequestSession() {
    return this._requestSession;
  }
  /**
   * @inheritDoc
   */
  setRequestSession(e) {
    return this._requestSession = e, this;
  }
  /**
   * @inheritDoc
   */
  setTags(e) {
    return this._tags = {
      ...this._tags,
      ...e
    }, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setTag(e, n) {
    return this._tags = { ...this._tags, [e]: n }, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setExtras(e) {
    return this._extra = {
      ...this._extra,
      ...e
    }, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setExtra(e, n) {
    return this._extra = { ...this._extra, [e]: n }, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setFingerprint(e) {
    return this._fingerprint = e, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setLevel(e) {
    return this._level = e, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setTransactionName(e) {
    return this._transactionName = e, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setContext(e, n) {
    return n === null ? delete this._contexts[e] : this._contexts[e] = n, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setSession(e) {
    return e ? this._session = e : delete this._session, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  getSession() {
    return this._session;
  }
  /**
   * @inheritDoc
   */
  update(e) {
    if (!e)
      return this;
    const n = typeof e == "function" ? e(this) : e, [r, s] = n instanceof _n ? [n.getScopeData(), n.getRequestSession()] : Kn(n) ? [e, e.requestSession] : [], { tags: o, extra: a, user: i, contexts: c, level: u, fingerprint: p = [], propagationContext: d } = r || {};
    return this._tags = { ...this._tags, ...o }, this._extra = { ...this._extra, ...a }, this._contexts = { ...this._contexts, ...c }, i && Object.keys(i).length && (this._user = i), u && (this._level = u), p.length && (this._fingerprint = p), d && (this._propagationContext = d), s && (this._requestSession = s), this;
  }
  /**
   * @inheritDoc
   */
  clear() {
    return this._breadcrumbs = [], this._tags = {}, this._extra = {}, this._user = {}, this._contexts = {}, this._level = void 0, this._transactionName = void 0, this._fingerprint = void 0, this._requestSession = void 0, this._session = void 0, us(this, void 0), this._attachments = [], this._propagationContext = xh(), this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  addBreadcrumb(e, n) {
    const r = typeof n == "number" ? n : lI;
    if (r <= 0)
      return this;
    const s = {
      timestamp: ws(),
      ...e
    }, o = this._breadcrumbs;
    return o.push(s), this._breadcrumbs = o.length > r ? o.slice(-r) : o, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  getLastBreadcrumb() {
    return this._breadcrumbs[this._breadcrumbs.length - 1];
  }
  /**
   * @inheritDoc
   */
  clearBreadcrumbs() {
    return this._breadcrumbs = [], this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  addAttachment(e) {
    return this._attachments.push(e), this;
  }
  /**
   * @inheritDoc
   */
  clearAttachments() {
    return this._attachments = [], this;
  }
  /** @inheritDoc */
  getScopeData() {
    return {
      breadcrumbs: this._breadcrumbs,
      attachments: this._attachments,
      contexts: this._contexts,
      tags: this._tags,
      extra: this._extra,
      user: this._user,
      level: this._level,
      fingerprint: this._fingerprint || [],
      eventProcessors: this._eventProcessors,
      propagationContext: this._propagationContext,
      sdkProcessingMetadata: this._sdkProcessingMetadata,
      transactionName: this._transactionName,
      span: Co(this)
    };
  }
  /**
   * @inheritDoc
   */
  setSDKProcessingMetadata(e) {
    return this._sdkProcessingMetadata = { ...this._sdkProcessingMetadata, ...e }, this;
  }
  /**
   * @inheritDoc
   */
  setPropagationContext(e) {
    return this._propagationContext = e, this;
  }
  /**
   * @inheritDoc
   */
  getPropagationContext() {
    return this._propagationContext;
  }
  /**
   * @inheritDoc
   */
  captureException(e, n) {
    const r = n && n.event_id ? n.event_id : se();
    if (!this._client)
      return I.warn("No client configured on scope - will not capture exception!"), r;
    const s = new Error("Sentry syntheticException");
    return this._client.captureException(
      e,
      {
        originalException: e,
        syntheticException: s,
        ...n,
        event_id: r
      },
      this
    ), r;
  }
  /**
   * @inheritDoc
   */
  captureMessage(e, n, r) {
    const s = r && r.event_id ? r.event_id : se();
    if (!this._client)
      return I.warn("No client configured on scope - will not capture message!"), s;
    const o = new Error(e);
    return this._client.captureMessage(
      e,
      n,
      {
        originalException: e,
        syntheticException: o,
        ...r,
        event_id: s
      },
      this
    ), s;
  }
  /**
   * @inheritDoc
   */
  captureEvent(e, n) {
    const r = n && n.event_id ? n.event_id : se();
    return this._client ? (this._client.captureEvent(e, { ...n, event_id: r }, this), r) : (I.warn("No client configured on scope - will not capture event!"), r);
  }
  /**
   * This will be called on every set call.
   */
  _notifyScopeListeners() {
    this._notifyingListeners || (this._notifyingListeners = !0, this._scopeListeners.forEach((e) => {
      e(this);
    }), this._notifyingListeners = !1);
  }
}
const _n = sp;
function xh() {
  return {
    traceId: se(),
    spanId: se().substring(16)
  };
}
function hI() {
  return np("defaultCurrentScope", () => new _n());
}
function vI() {
  return np("defaultIsolationScope", () => new _n());
}
class fI {
  constructor(e, n) {
    let r;
    e ? r = e : r = new _n();
    let s;
    n ? s = n : s = new _n(), this._stack = [{ scope: r }], this._isolationScope = s;
  }
  /**
   * Fork a scope for the stack.
   */
  withScope(e) {
    const n = this._pushScope();
    let r;
    try {
      r = e(n);
    } catch (s) {
      throw this._popScope(), s;
    }
    return Ha(r) ? r.then(
      (s) => (this._popScope(), s),
      (s) => {
        throw this._popScope(), s;
      }
    ) : (this._popScope(), r);
  }
  /**
   * Get the client of the stack.
   */
  getClient() {
    return this.getStackTop().client;
  }
  /**
   * Returns the scope of the top stack.
   */
  getScope() {
    return this.getStackTop().scope;
  }
  /**
   * Get the isolation scope for the stack.
   */
  getIsolationScope() {
    return this._isolationScope;
  }
  /**
   * Returns the scope stack for domains or the process.
   */
  getStack() {
    return this._stack;
  }
  /**
   * Returns the topmost scope layer in the order domain > local > process.
   */
  getStackTop() {
    return this._stack[this._stack.length - 1];
  }
  /**
   * Push a scope to the stack.
   */
  _pushScope() {
    const e = this.getScope().clone();
    return this.getStack().push({
      client: this.getClient(),
      scope: e
    }), e;
  }
  /**
   * Pop a scope from the stack.
   */
  _popScope() {
    return this.getStack().length <= 1 ? !1 : !!this.getStack().pop();
  }
}
function Qn() {
  const t = bn(), e = Wa(t);
  return e.hub || (e.hub = new fI(hI(), vI())), e.hub;
}
function gI(t) {
  return Qn().withScope(t);
}
function mI(t, e) {
  const n = Qn();
  return n.withScope(() => (n.getStackTop().scope = t, e(t)));
}
function Bh(t) {
  return Qn().withScope(() => t(Qn().getIsolationScope()));
}
function SI() {
  return {
    withIsolationScope: Bh,
    withScope: gI,
    withSetScope: mI,
    withSetIsolationScope: (t, e) => Bh(e),
    getCurrentScope: () => Qn().getScope(),
    getIsolationScope: () => Qn().getIsolationScope()
  };
}
function bs(t) {
  const e = Wa(t);
  return e.acs ? e.acs : SI();
}
function pe() {
  const t = bn();
  return bs(t).getCurrentScope();
}
function wt() {
  const t = bn();
  return bs(t).getIsolationScope();
}
function Hg() {
  return np("globalScope", () => new _n());
}
function op(...t) {
  const e = bn(), n = bs(e);
  if (t.length === 2) {
    const [r, s] = t;
    return r ? n.withSetScope(r, s) : n.withScope(s);
  }
  return n.withScope(t[0]);
}
function ne() {
  return pe().getClient();
}
const Lt = "sentry.source", Wg = "sentry.sample_rate", ps = "sentry.op", xe = "sentry.origin", uu = "sentry.idle_span_finish_reason", ap = "sentry.measurement_unit", cp = "sentry.measurement_value", yI = "sentry.profile_id", Vg = "sentry.exclusive_time", CI = 0, Kg = 1, me = 2;
function _I(t) {
  if (t < 400 && t >= 100)
    return { code: Kg };
  if (t >= 400 && t < 500)
    switch (t) {
      case 401:
        return { code: me, message: "unauthenticated" };
      case 403:
        return { code: me, message: "permission_denied" };
      case 404:
        return { code: me, message: "not_found" };
      case 409:
        return { code: me, message: "already_exists" };
      case 413:
        return { code: me, message: "failed_precondition" };
      case 429:
        return { code: me, message: "resource_exhausted" };
      case 499:
        return { code: me, message: "cancelled" };
      default:
        return { code: me, message: "invalid_argument" };
    }
  if (t >= 500 && t < 600)
    switch (t) {
      case 501:
        return { code: me, message: "unimplemented" };
      case 503:
        return { code: me, message: "unavailable" };
      case 504:
        return { code: me, message: "deadline_exceeded" };
      default:
        return { code: me, message: "internal_error" };
    }
  return { code: me, message: "unknown_error" };
}
function Jg(t, e) {
  t.setAttribute("http.response.status_code", e);
  const n = _I(e);
  n.message !== "unknown_error" && t.setStatus(n);
}
const Gg = 0, Qg = 1;
function RI(t) {
  const { spanId: e, traceId: n } = t.spanContext(), { data: r, op: s, parent_span_id: o, status: a, origin: i } = te(t);
  return ze({
    parent_span_id: o,
    span_id: e,
    trace_id: n,
    data: r,
    op: s,
    status: a,
    origin: i
  });
}
function PI(t) {
  const { spanId: e, traceId: n } = t.spanContext(), { parent_span_id: r } = te(t);
  return ze({ parent_span_id: r, span_id: e, trace_id: n });
}
function Yg(t) {
  const { traceId: e, spanId: n } = t.spanContext(), r = An(t);
  return ip(e, n, r);
}
function fn(t) {
  return typeof t == "number" ? qh(t) : Array.isArray(t) ? t[0] + t[1] / 1e9 : t instanceof Date ? qh(t.getTime()) : Ue();
}
function qh(t) {
  return t > 9999999999 ? t / 1e3 : t;
}
function te(t) {
  if (TI(t))
    return t.getSpanJSON();
  try {
    const { spanId: e, traceId: n } = t.spanContext();
    if (EI(t)) {
      const { attributes: r, startTime: s, name: o, endTime: a, parentSpanId: i, status: c } = t;
      return ze({
        span_id: e,
        trace_id: n,
        data: r,
        description: o,
        parent_span_id: i,
        start_timestamp: fn(s),
        // This is [0,0] by default in OTEL, in which case we want to interpret this as no end time
        timestamp: fn(a) || void 0,
        status: Zg(c),
        op: r[ps],
        origin: r[xe],
        _metrics_summary: void 0
      });
    }
    return {
      span_id: e,
      trace_id: n
    };
  } catch {
    return {};
  }
}
function EI(t) {
  const e = t;
  return !!e.attributes && !!e.startTime && !!e.name && !!e.endTime && !!e.status;
}
function TI(t) {
  return typeof t.getSpanJSON == "function";
}
function An(t) {
  const { traceFlags: e } = t.spanContext();
  return e === Qg;
}
function Zg(t) {
  if (!(!t || t.code === CI))
    return t.code === Kg ? "ok" : t.message || "unknown_error";
}
const zt = "_sentryChildSpans", pu = "_sentryRootSpan";
function Xg(t, e) {
  const n = t[pu] || t;
  rt(e, pu, n), t[zt] && t[zt].size < 1e3 ? t[zt].add(e) : rt(t, zt, /* @__PURE__ */ new Set([e]));
}
function II(t, e) {
  t[zt] && t[zt].delete(e);
}
function oo(t) {
  const e = /* @__PURE__ */ new Set();
  function n(r) {
    if (!e.has(r) && An(r)) {
      e.add(r);
      const s = r[zt] ? Array.from(r[zt]) : [];
      for (const o of s)
        n(o);
    }
  }
  return n(t), Array.from(e);
}
function He(t) {
  return t[pu] || t;
}
function Xe() {
  const t = bn(), e = bs(t);
  return e.getActiveSpan ? e.getActiveSpan() : Co(pe());
}
let Fh = !1;
function wI() {
  Fh || (Fh = !0, zg(du), jg(du));
}
function du() {
  const t = Xe(), e = t && He(t);
  if (e) {
    const n = "internal_error";
    K && I.log(`[Tracing] Root span: ${n} -> Global error occured`), e.setStatus({ code: me, message: n });
  }
}
du.tag = "sentry_tracingErrorCallback";
const em = "_sentryScope", tm = "_sentryIsolationScope";
function bI(t, e, n) {
  t && (rt(t, tm, n), rt(t, em, e));
}
function $h(t) {
  return {
    scope: t[em],
    isolationScope: t[tm]
  };
}
function Ft(t) {
  if (typeof __SENTRY_TRACING__ == "boolean" && !__SENTRY_TRACING__)
    return !1;
  const e = t || AI();
  return !!e && (e.enableTracing || "tracesSampleRate" in e || "tracesSampler" in e);
}
function AI() {
  const t = ne();
  return t && t.getOptions();
}
class cr {
  constructor(e = {}) {
    this._traceId = e.traceId || se(), this._spanId = e.spanId || se().substring(16);
  }
  /** @inheritdoc */
  spanContext() {
    return {
      spanId: this._spanId,
      traceId: this._traceId,
      traceFlags: Gg
    };
  }
  /** @inheritdoc */
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  end(e) {
  }
  /** @inheritdoc */
  setAttribute(e, n) {
    return this;
  }
  /** @inheritdoc */
  setAttributes(e) {
    return this;
  }
  /** @inheritdoc */
  setStatus(e) {
    return this;
  }
  /** @inheritdoc */
  updateName(e) {
    return this;
  }
  /** @inheritdoc */
  isRecording() {
    return !1;
  }
  /** @inheritdoc */
  addEvent(e, n, r) {
    return this;
  }
}
const up = "production", nm = "_frozenDsc";
function Uh(t, e) {
  rt(t, nm, e);
}
function Va(t, e) {
  const n = e.getOptions(), { publicKey: r } = e.getDsn() || {}, s = ze({
    environment: n.environment || up,
    release: n.release,
    public_key: r,
    trace_id: t
  });
  return e.emit("createDsc", s), s;
}
function Mn(t) {
  const e = ne();
  if (!e)
    return {};
  const n = Va(te(t).trace_id || "", e), r = He(t);
  if (!r)
    return n;
  const s = r[nm];
  if (s)
    return s;
  const o = te(r), a = o.data || {}, i = a[Wg];
  i != null && (n.sample_rate = `${i}`);
  const c = a[Lt];
  return c && c !== "url" && (n.transaction = o.description), n.sampled = String(An(r)), e.emit("createDsc", n), n;
}
function MI(t) {
  if (!K)
    return;
  const { description: e = "< unknown name >", op: n = "< unknown op >", parent_span_id: r } = te(t), { spanId: s } = t.spanContext(), o = An(t), a = He(t), i = a === t, c = `[Tracing] Starting ${o ? "sampled" : "unsampled"} ${i ? "root " : ""}span`, u = [`op: ${n}`, `name: ${e}`, `ID: ${s}`];
  if (r && u.push(`parent ID: ${r}`), !i) {
    const { op: p, description: d } = te(a);
    u.push(`root ID: ${a.spanContext().spanId}`), p && u.push(`root op: ${p}`), d && u.push(`root description: ${d}`);
  }
  I.log(`${c}
  ${u.join(`
  `)}`);
}
function kI(t) {
  if (!K)
    return;
  const { description: e = "< unknown name >", op: n = "< unknown op >" } = te(t), { spanId: r } = t.spanContext(), o = He(t) === t, a = `[Tracing] Finishing "${n}" ${o ? "root " : ""}span "${e}" with ID ${r}`;
  I.log(a);
}
function rm(t) {
  if (typeof t == "boolean")
    return Number(t);
  const e = typeof t == "string" ? parseFloat(t) : t;
  if (typeof e != "number" || isNaN(e) || e < 0 || e > 1) {
    K && I.warn(
      `[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(
        t
      )} of type ${JSON.stringify(typeof t)}.`
    );
    return;
  }
  return e;
}
function OI(t, e) {
  if (!Ft(t))
    return [!1];
  let n;
  typeof t.tracesSampler == "function" ? n = t.tracesSampler(e) : e.parentSampled !== void 0 ? n = e.parentSampled : typeof t.tracesSampleRate < "u" ? n = t.tracesSampleRate : n = 1;
  const r = rm(n);
  return r === void 0 ? (K && I.warn("[Tracing] Discarding transaction because of invalid sample rate."), [!1]) : r ? Math.random() < r ? [!0, r] : (K && I.log(
    `[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(
      n
    )})`
  ), [!1, r]) : (K && I.log(
    `[Tracing] Discarding transaction because ${typeof t.tracesSampler == "function" ? "tracesSampler returned 0 or false" : "a negative sampling decision was inherited or tracesSampleRate is set to 0"}`
  ), [!1, r]);
}
function DI(t, e) {
  return e && (t.sdk = t.sdk || {}, t.sdk.name = t.sdk.name || e.name, t.sdk.version = t.sdk.version || e.version, t.sdk.integrations = [...t.sdk.integrations || [], ...e.integrations || []], t.sdk.packages = [...t.sdk.packages || [], ...e.packages || []]), t;
}
function NI(t, e, n, r) {
  const s = Ug(n), o = {
    sent_at: (/* @__PURE__ */ new Date()).toISOString(),
    ...s && { sdk: s },
    ...!!r && e && { dsn: Is(e) }
  }, a = "aggregates" in t ? [{ type: "sessions" }, t] : [{ type: "session" }, t.toJSON()];
  return ar(o, [a]);
}
function LI(t, e, n, r) {
  const s = Ug(n), o = t.type && t.type !== "replay_event" ? t.type : "event";
  DI(t, n && n.sdk);
  const a = eI(t, s, r, e);
  return delete t.sdkProcessingMetadata, ar(a, [[{ type: o }, t]]);
}
function zI(t, e) {
  function n(p) {
    return !!p.trace_id && !!p.public_key;
  }
  const r = Mn(t[0]), s = e && e.getDsn(), o = e && e.getOptions().tunnel, a = {
    sent_at: (/* @__PURE__ */ new Date()).toISOString(),
    ...n(r) && { trace: r },
    ...!!o && s && { dsn: Is(s) }
  }, i = e && e.getOptions().beforeSendSpan, c = i ? (p) => i(te(p)) : (p) => te(p), u = [];
  for (const p of t) {
    const d = c(p);
    d && u.push(YT(d));
  }
  return ar(a, u);
}
function jI(t, e, n) {
  const r = Xe(), s = r && He(r);
  s && s.addEvent(t, {
    [cp]: e,
    [ap]: n
  });
}
function Hh(t) {
  if (!t || t.length === 0)
    return;
  const e = {};
  return t.forEach((n) => {
    const r = n.attributes || {}, s = r[ap], o = r[cp];
    typeof s == "string" && typeof o == "number" && (e[n.name] = { value: o, unit: s });
  }), e;
}
class pp {
  /** Epoch timestamp in seconds when the span started. */
  /** Epoch timestamp in seconds when the span ended. */
  /** Internal keeper of the status */
  /** The timed events added to this span. */
  /** if true, treat span as a standalone span (not part of a transaction) */
  /**
   * You should never call the constructor manually, always use `Sentry.startSpan()`
   * or other span methods.
   * @internal
   * @hideconstructor
   * @hidden
   */
  constructor(e = {}) {
    this._traceId = e.traceId || se(), this._spanId = e.spanId || se().substring(16), this._startTime = e.startTimestamp || Ue(), this._attributes = {}, this.setAttributes({
      [xe]: "manual",
      [ps]: e.op,
      ...e.attributes
    }), this._name = e.name, e.parentSpanId && (this._parentSpanId = e.parentSpanId), "sampled" in e && (this._sampled = e.sampled), e.endTimestamp && (this._endTime = e.endTimestamp), this._events = [], this._isStandaloneSpan = e.isStandalone, this._endTime && this._onSpanEnded();
  }
  /** @inheritdoc */
  spanContext() {
    const { _spanId: e, _traceId: n, _sampled: r } = this;
    return {
      spanId: e,
      traceId: n,
      traceFlags: r ? Qg : Gg
    };
  }
  /** @inheritdoc */
  setAttribute(e, n) {
    n === void 0 ? delete this._attributes[e] : this._attributes[e] = n;
  }
  /** @inheritdoc */
  setAttributes(e) {
    Object.keys(e).forEach((n) => this.setAttribute(n, e[n]));
  }
  /**
   * This should generally not be used,
   * but we need it for browser tracing where we want to adjust the start time afterwards.
   * USE THIS WITH CAUTION!
   *
   * @hidden
   * @internal
   */
  updateStartTime(e) {
    this._startTime = fn(e);
  }
  /**
   * @inheritDoc
   */
  setStatus(e) {
    return this._status = e, this;
  }
  /**
   * @inheritDoc
   */
  updateName(e) {
    return this._name = e, this;
  }
  /** @inheritdoc */
  end(e) {
    this._endTime || (this._endTime = fn(e), kI(this), this._onSpanEnded());
  }
  /**
   * Get JSON representation of this span.
   *
   * @hidden
   * @internal This method is purely for internal purposes and should not be used outside
   * of SDK code. If you need to get a JSON representation of a span,
   * use `spanToJSON(span)` instead.
   */
  getSpanJSON() {
    return ze({
      data: this._attributes,
      description: this._name,
      op: this._attributes[ps],
      parent_span_id: this._parentSpanId,
      span_id: this._spanId,
      start_timestamp: this._startTime,
      status: Zg(this._status),
      timestamp: this._endTime,
      trace_id: this._traceId,
      origin: this._attributes[xe],
      _metrics_summary: void 0,
      profile_id: this._attributes[yI],
      exclusive_time: this._attributes[Vg],
      measurements: Hh(this._events),
      is_segment: this._isStandaloneSpan && He(this) === this || void 0,
      segment_id: this._isStandaloneSpan ? He(this).spanContext().spanId : void 0
    });
  }
  /** @inheritdoc */
  isRecording() {
    return !this._endTime && !!this._sampled;
  }
  /**
   * @inheritdoc
   */
  addEvent(e, n, r) {
    K && I.log("[Tracing] Adding an event to span:", e);
    const s = Wh(n) ? n : r || Ue(), o = Wh(n) ? {} : n || {}, a = {
      name: e,
      time: fn(s),
      attributes: o
    };
    return this._events.push(a), this;
  }
  /**
   * This method should generally not be used,
   * but for now we need a way to publicly check if the `_isStandaloneSpan` flag is set.
   * USE THIS WITH CAUTION!
   * @internal
   * @hidden
   * @experimental
   */
  isStandaloneSpan() {
    return !!this._isStandaloneSpan;
  }
  /** Emit `spanEnd` when the span is ended. */
  _onSpanEnded() {
    const e = ne();
    if (e && e.emit("spanEnd", this), !(this._isStandaloneSpan || this === He(this)))
      return;
    if (this._isStandaloneSpan) {
      BI(zI([this], e));
      return;
    }
    const r = this._convertSpanToTransaction();
    r && ($h(this).scope || pe()).captureEvent(r);
  }
  /**
   * Finish the transaction & prepare the event to send to Sentry.
   */
  _convertSpanToTransaction() {
    if (!Vh(te(this)))
      return;
    this._name || (K && I.warn("Transaction has no name, falling back to `<unlabeled transaction>`."), this._name = "<unlabeled transaction>");
    const { scope: e, isolationScope: n } = $h(this), s = (e || pe()).getClient() || ne();
    if (this._sampled !== !0) {
      K && I.log("[Tracing] Discarding transaction because its trace was not chosen to be sampled."), s && s.recordDroppedEvent("sample_rate", "transaction");
      return;
    }
    const a = oo(this).filter((d) => d !== this && !xI(d)).map((d) => te(d)).filter(Vh), i = this._attributes[Lt], c = {
      contexts: {
        trace: RI(this)
      },
      spans: a,
      start_timestamp: this._startTime,
      timestamp: this._endTime,
      transaction: this._name,
      type: "transaction",
      sdkProcessingMetadata: {
        capturedSpanScope: e,
        capturedSpanIsolationScope: n,
        ...ze({
          dynamicSamplingContext: Mn(this)
        })
      },
      _metrics_summary: void 0,
      ...i && {
        transaction_info: {
          source: i
        }
      }
    }, u = Hh(this._events);
    return u && Object.keys(u).length && (K && I.log("[Measurements] Adding measurements to transaction", JSON.stringify(u, void 0, 2)), c.measurements = u), c;
  }
}
function Wh(t) {
  return t && typeof t == "number" || t instanceof Date || Array.isArray(t);
}
function Vh(t) {
  return !!t.start_timestamp && !!t.timestamp && !!t.span_id && !!t.trace_id;
}
function xI(t) {
  return t instanceof pp && t.isStandaloneSpan();
}
function BI(t) {
  const e = ne();
  if (!e)
    return;
  const n = t[1];
  if (!n || n.length === 0) {
    e.recordDroppedEvent("before_send", "span");
    return;
  }
  const r = e.getTransport();
  r && r.send(t).then(null, (s) => {
    K && I.error("Error while sending span:", s);
  });
}
const im = "__SENTRY_SUPPRESS_TRACING__";
function kn(t) {
  const e = sm();
  if (e.startInactiveSpan)
    return e.startInactiveSpan(t);
  const n = $I(t), r = t.scope || pe(), s = HI(r);
  return t.onlyIfParent && !s ? new cr() : FI({
    parentSpan: s,
    spanContext: n,
    forceTransaction: t.forceTransaction,
    scope: r
  });
}
function qI(t, e) {
  const n = sm();
  return n.withActiveSpan ? n.withActiveSpan(t, e) : op((r) => (us(r, t || void 0), e(r)));
}
function FI({
  parentSpan: t,
  spanContext: e,
  forceTransaction: n,
  scope: r
}) {
  if (!Ft())
    return new cr();
  const s = wt();
  let o;
  if (t && !n)
    o = UI(t, r, e), Xg(t, o);
  else if (t) {
    const a = Mn(t), { traceId: i, spanId: c } = t.spanContext(), u = An(t);
    o = Kh(
      {
        traceId: i,
        parentSpanId: c,
        ...e
      },
      r,
      u
    ), Uh(o, a);
  } else {
    const {
      traceId: a,
      dsc: i,
      parentSpanId: c,
      sampled: u
    } = {
      ...s.getPropagationContext(),
      ...r.getPropagationContext()
    };
    o = Kh(
      {
        traceId: a,
        parentSpanId: c,
        ...e
      },
      r,
      u
    ), i && Uh(o, i);
  }
  return MI(o), bI(o, r, s), o;
}
function $I(t) {
  const n = {
    isStandalone: (t.experimental || {}).standalone,
    ...t
  };
  if (t.startTime) {
    const r = { ...n };
    return r.startTimestamp = fn(t.startTime), delete r.startTime, r;
  }
  return n;
}
function sm() {
  const t = bn();
  return bs(t);
}
function Kh(t, e, n) {
  const r = ne(), s = r && r.getOptions() || {}, { name: o = "", attributes: a } = t, [i, c] = e.getScopeData().sdkProcessingMetadata[im] ? [!1] : OI(s, {
    name: o,
    parentSampled: n,
    attributes: a,
    transactionContext: {
      name: o,
      parentSampled: n
    }
  }), u = new pp({
    ...t,
    attributes: {
      [Lt]: "custom",
      ...t.attributes
    },
    sampled: i
  });
  return c !== void 0 && u.setAttribute(Wg, c), r && r.emit("spanStart", u), u;
}
function UI(t, e, n) {
  const { spanId: r, traceId: s } = t.spanContext(), o = e.getScopeData().sdkProcessingMetadata[im] ? !1 : An(t), a = o ? new pp({
    ...n,
    parentSpanId: r,
    traceId: s,
    sampled: o
  }) : new cr({ traceId: s });
  Xg(t, a);
  const i = ne();
  return i && (i.emit("spanStart", a), n.endTimestamp && i.emit("spanEnd", a)), a;
}
function HI(t) {
  const e = Co(t);
  if (!e)
    return;
  const n = ne();
  return (n ? n.getOptions() : {}).parentSpanIsAlwaysRootSpan ? He(e) : e;
}
const ao = {
  idleTimeout: 1e3,
  finalTimeout: 3e4,
  childSpanTimeout: 15e3
}, WI = "heartbeatFailed", VI = "idleTimeout", KI = "finalTimeout", JI = "externalFinish";
function om(t, e = {}) {
  const n = /* @__PURE__ */ new Map();
  let r = !1, s, o = JI, a = !e.disableAutoFinish;
  const {
    idleTimeout: i = ao.idleTimeout,
    finalTimeout: c = ao.finalTimeout,
    childSpanTimeout: u = ao.childSpanTimeout,
    beforeSpanEnd: p
  } = e, d = ne();
  if (!d || !Ft())
    return new cr();
  const l = pe(), h = Xe(), v = GI(t);
  function g(_ = Ue()) {
    const w = oo(v).filter((b) => b !== v);
    if (!w.length) {
      v.end(_);
      return;
    }
    const T = w.map((b) => te(b).timestamp).filter((b) => !!b), O = T.length ? Math.max(...T) : void 0, G = fn(_), X = te(v).start_timestamp, q = Math.min(
      X ? X + c / 1e3 : 1 / 0,
      Math.max(X || -1 / 0, Math.min(G, O || 1 / 0))
    );
    v.end(q);
  }
  function f() {
    s && (clearTimeout(s), s = void 0);
  }
  function m(_) {
    f(), s = setTimeout(() => {
      !r && n.size === 0 && a && (o = VI, g(_));
    }, i);
  }
  function S(_) {
    s = setTimeout(() => {
      !r && a && (o = WI, g(_));
    }, u);
  }
  function y(_) {
    f(), n.set(_, !0);
    const w = Ue();
    S(w + u / 1e3);
  }
  function P(_) {
    if (n.has(_) && n.delete(_), n.size === 0) {
      const w = Ue();
      m(w + i / 1e3);
    }
  }
  function C() {
    r = !0, n.clear(), p && p(v), us(l, h);
    const _ = te(v), { timestamp: w, start_timestamp: T } = _;
    if (!w || !T)
      return;
    (_.data || {})[uu] || v.setAttribute(uu, o), I.log(`[Tracing] Idle span "${_.op}" finished`);
    const G = oo(v).filter((q) => q !== v);
    let X = 0;
    G.forEach((q) => {
      q.isRecording() && (q.setStatus({ code: me, message: "cancelled" }), q.end(w), K && I.log("[Tracing] Cancelling span since span ended early", JSON.stringify(q, void 0, 2)));
      const b = te(q), { timestamp: x = 0, start_timestamp: ee = 0 } = b, Z = ee <= w, L = (c + i) / 1e3, re = x - ee < L;
      if (K) {
        const ce = JSON.stringify(q, void 0, 2);
        Z ? re || I.log("[Tracing] Discarding span since it finished after idle span final timeout", ce) : I.log("[Tracing] Discarding span since it happened after idle span was finished", ce);
      }
      (!re || !Z) && (II(v, q), X++);
    }), X > 0 && v.setAttribute("sentry.idle_span_discarded_spans", X);
  }
  return d.on("spanStart", (_) => {
    if (r || _ === v || te(_).timestamp)
      return;
    oo(v).includes(_) && y(_.spanContext().spanId);
  }), d.on("spanEnd", (_) => {
    r || (P(_.spanContext().spanId), _ === v && C());
  }), d.on("idleSpanEnableAutoFinish", (_) => {
    _ === v && (a = !0, m(), n.size && S());
  }), e.disableAutoFinish || m(), setTimeout(() => {
    r || (v.setStatus({ code: me, message: "deadline_exceeded" }), o = KI, g());
  }, c), v;
}
function GI(t) {
  const e = kn(t);
  return us(pe(), e), K && I.log("[Tracing] Started span is an idle span"), e;
}
function lu(t, e, n, r = 0) {
  return new Ge((s, o) => {
    const a = t[r];
    if (e === null || typeof a != "function")
      s(e);
    else {
      const i = a({ ...e }, n);
      K && a.id && i === null && I.log(`Event processor "${a.id}" dropped event`), Ha(i) ? i.then((c) => lu(t, c, n, r + 1).then(s)).then(null, o) : lu(t, i, n, r + 1).then(s).then(null, o);
    }
  });
}
function QI(t, e) {
  const { fingerprint: n, span: r, breadcrumbs: s, sdkProcessingMetadata: o } = e;
  YI(t, e), r && ew(t, r), tw(t, n), ZI(t, s), XI(t, o);
}
function Jh(t, e) {
  const {
    extra: n,
    tags: r,
    user: s,
    contexts: o,
    level: a,
    sdkProcessingMetadata: i,
    breadcrumbs: c,
    fingerprint: u,
    eventProcessors: p,
    attachments: d,
    propagationContext: l,
    transactionName: h,
    span: v
  } = e;
  Yi(t, "extra", n), Yi(t, "tags", r), Yi(t, "user", s), Yi(t, "contexts", o), Yi(t, "sdkProcessingMetadata", i), a && (t.level = a), h && (t.transactionName = h), v && (t.span = v), c.length && (t.breadcrumbs = [...t.breadcrumbs, ...c]), u.length && (t.fingerprint = [...t.fingerprint, ...u]), p.length && (t.eventProcessors = [...t.eventProcessors, ...p]), d.length && (t.attachments = [...t.attachments, ...d]), t.propagationContext = { ...t.propagationContext, ...l };
}
function Yi(t, e, n) {
  if (n && Object.keys(n).length) {
    t[e] = { ...t[e] };
    for (const r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (t[e][r] = n[r]);
  }
}
function YI(t, e) {
  const { extra: n, tags: r, user: s, contexts: o, level: a, transactionName: i } = e, c = ze(n);
  c && Object.keys(c).length && (t.extra = { ...c, ...t.extra });
  const u = ze(r);
  u && Object.keys(u).length && (t.tags = { ...u, ...t.tags });
  const p = ze(s);
  p && Object.keys(p).length && (t.user = { ...p, ...t.user });
  const d = ze(o);
  d && Object.keys(d).length && (t.contexts = { ...d, ...t.contexts }), a && (t.level = a), i && t.type !== "transaction" && (t.transaction = i);
}
function ZI(t, e) {
  const n = [...t.breadcrumbs || [], ...e];
  t.breadcrumbs = n.length ? n : void 0;
}
function XI(t, e) {
  t.sdkProcessingMetadata = {
    ...t.sdkProcessingMetadata,
    ...e
  };
}
function ew(t, e) {
  t.contexts = {
    trace: PI(e),
    ...t.contexts
  }, t.sdkProcessingMetadata = {
    dynamicSamplingContext: Mn(e),
    ...t.sdkProcessingMetadata
  };
  const n = He(e), r = te(n).description;
  r && !t.transaction && t.type === "transaction" && (t.transaction = r);
}
function tw(t, e) {
  t.fingerprint = t.fingerprint ? Bg(t.fingerprint) : [], e && (t.fingerprint = t.fingerprint.concat(e)), t.fingerprint && !t.fingerprint.length && delete t.fingerprint;
}
function nw(t, e, n, r, s, o) {
  const { normalizeDepth: a = 3, normalizeMaxBreadth: i = 1e3 } = t, c = {
    ...e,
    event_id: e.event_id || n.event_id || se(),
    timestamp: e.timestamp || ws()
  }, u = n.integrations || t.integrations.map((f) => f.name);
  rw(c, t), ow(c, u), e.type === void 0 && iw(c, t.stackParser);
  const p = cw(r, n.captureContext);
  n.mechanism && cs(c, n.mechanism);
  const d = s ? s.getEventProcessors() : [], l = Hg().getScopeData();
  if (o) {
    const f = o.getScopeData();
    Jh(l, f);
  }
  if (p) {
    const f = p.getScopeData();
    Jh(l, f);
  }
  const h = [...n.attachments || [], ...l.attachments];
  h.length && (n.attachments = h), QI(c, l);
  const v = [
    ...d,
    // Run scope event processors _after_ all other processors
    ...l.eventProcessors
  ];
  return lu(v, c, n).then((f) => (f && sw(f), typeof a == "number" && a > 0 ? aw(f, a, i) : f));
}
function rw(t, e) {
  const { environment: n, release: r, dist: s, maxValueLength: o = 250 } = e;
  "environment" in t || (t.environment = "environment" in e ? n : up), t.release === void 0 && r !== void 0 && (t.release = r), t.dist === void 0 && s !== void 0 && (t.dist = s), t.message && (t.message = Fn(t.message, o));
  const a = t.exception && t.exception.values && t.exception.values[0];
  a && a.value && (a.value = Fn(a.value, o));
  const i = t.request;
  i && i.url && (i.url = Fn(i.url, o));
}
const Gh = /* @__PURE__ */ new WeakMap();
function iw(t, e) {
  const n = Y._sentryDebugIds;
  if (!n)
    return;
  let r;
  const s = Gh.get(e);
  s ? r = s : (r = /* @__PURE__ */ new Map(), Gh.set(e, r));
  const o = Object.keys(n).reduce((a, i) => {
    let c;
    const u = r.get(i);
    u ? c = u : (c = e(i), r.set(i, c));
    for (let p = c.length - 1; p >= 0; p--) {
      const d = c[p];
      if (d.filename) {
        a[d.filename] = n[i];
        break;
      }
    }
    return a;
  }, {});
  try {
    t.exception.values.forEach((a) => {
      a.stacktrace.frames.forEach((i) => {
        i.filename && (i.debug_id = o[i.filename]);
      });
    });
  } catch {
  }
}
function sw(t) {
  const e = {};
  try {
    t.exception.values.forEach((r) => {
      r.stacktrace.frames.forEach((s) => {
        s.debug_id && (s.abs_path ? e[s.abs_path] = s.debug_id : s.filename && (e[s.filename] = s.debug_id), delete s.debug_id);
      });
    });
  } catch {
  }
  if (Object.keys(e).length === 0)
    return;
  t.debug_meta = t.debug_meta || {}, t.debug_meta.images = t.debug_meta.images || [];
  const n = t.debug_meta.images;
  Object.keys(e).forEach((r) => {
    n.push({
      type: "sourcemap",
      code_file: r,
      debug_id: e[r]
    });
  });
}
function ow(t, e) {
  e.length > 0 && (t.sdk = t.sdk || {}, t.sdk.integrations = [...t.sdk.integrations || [], ...e]);
}
function aw(t, e, n) {
  if (!t)
    return null;
  const r = {
    ...t,
    ...t.breadcrumbs && {
      breadcrumbs: t.breadcrumbs.map((s) => ({
        ...s,
        ...s.data && {
          data: Ot(s.data, e, n)
        }
      }))
    },
    ...t.user && {
      user: Ot(t.user, e, n)
    },
    ...t.contexts && {
      contexts: Ot(t.contexts, e, n)
    },
    ...t.extra && {
      extra: Ot(t.extra, e, n)
    }
  };
  return t.contexts && t.contexts.trace && r.contexts && (r.contexts.trace = t.contexts.trace, t.contexts.trace.data && (r.contexts.trace.data = Ot(t.contexts.trace.data, e, n))), t.spans && (r.spans = t.spans.map((s) => ({
    ...s,
    ...s.data && {
      data: Ot(s.data, e, n)
    }
  }))), r;
}
function cw(t, e) {
  if (!e)
    return t;
  const n = t ? t.clone() : new _n();
  return n.update(e), n;
}
function uw(t, e) {
  return pe().captureException(t, void 0);
}
function pw(t, e) {
  const r = { captureContext: e };
  return pe().captureMessage(t, void 0, r);
}
function am(t, e) {
  return pe().captureEvent(t, e);
}
function Qh(t) {
  const e = ne(), n = wt(), r = pe(), { release: s, environment: o = up } = e && e.getOptions() || {}, { userAgent: a } = Y.navigator || {}, i = uI({
    release: s,
    environment: o,
    user: r.getUser() || n.getUser(),
    ...a && { userAgent: a },
    ...t
  }), c = n.getSession();
  return c && c.status === "ok" && Gn(c, { status: "exited" }), cm(), n.setSession(i), r.setSession(i), i;
}
function cm() {
  const t = wt(), e = pe(), n = e.getSession() || t.getSession();
  n && pI(n), um(), t.setSession(), e.setSession();
}
function um() {
  const t = wt(), e = pe(), n = ne(), r = e.getSession() || t.getSession();
  r && n && n.captureSession(r);
}
function Yh(t = !1) {
  if (t) {
    cm();
    return;
  }
  um();
}
const dw = "7";
function lw(t) {
  const e = t.protocol ? `${t.protocol}:` : "", n = t.port ? `:${t.port}` : "";
  return `${e}//${t.host}${n}${t.path ? `/${t.path}` : ""}/api/`;
}
function hw(t) {
  return `${lw(t)}${t.projectId}/envelope/`;
}
function vw(t, e) {
  return ST({
    // We send only the minimum set of required information. See
    // https://github.com/getsentry/sentry-javascript/issues/2572.
    sentry_key: t.publicKey,
    sentry_version: dw,
    ...e && { sentry_client: `${e.name}/${e.version}` }
  });
}
function fw(t, e, n) {
  return e || `${hw(t)}?${vw(t, n)}`;
}
const Zh = [];
function gw(t) {
  const e = {};
  return t.forEach((n) => {
    const { name: r } = n, s = e[r];
    s && !s.isDefaultInstance && n.isDefaultInstance || (e[r] = n);
  }), Object.keys(e).map((n) => e[n]);
}
function mw(t) {
  const e = t.defaultIntegrations || [], n = t.integrations;
  e.forEach((a) => {
    a.isDefaultInstance = !0;
  });
  let r;
  Array.isArray(n) ? r = [...e, ...n] : typeof n == "function" ? r = Bg(n(e)) : r = e;
  const s = gw(r), o = yw(s, (a) => a.name === "Debug");
  if (o !== -1) {
    const [a] = s.splice(o, 1);
    s.push(a);
  }
  return s;
}
function Sw(t, e) {
  const n = {};
  return e.forEach((r) => {
    r && pm(t, r, n);
  }), n;
}
function Xh(t, e) {
  for (const n of e)
    n && n.afterAllSetup && n.afterAllSetup(t);
}
function pm(t, e, n) {
  if (n[e.name]) {
    K && I.log(`Integration skipped because it was already installed: ${e.name}`);
    return;
  }
  if (n[e.name] = e, Zh.indexOf(e.name) === -1 && typeof e.setupOnce == "function" && (e.setupOnce(), Zh.push(e.name)), e.setup && typeof e.setup == "function" && e.setup(t), typeof e.preprocessEvent == "function") {
    const r = e.preprocessEvent.bind(e);
    t.on("preprocessEvent", (s, o) => r(s, o, t));
  }
  if (typeof e.processEvent == "function") {
    const r = e.processEvent.bind(e), s = Object.assign((o, a) => r(o, a, t), {
      id: e.name
    });
    t.addEventProcessor(s);
  }
  K && I.log(`Integration installed: ${e.name}`);
}
function yw(t, e) {
  for (let n = 0; n < t.length; n++)
    if (e(t[n]) === !0)
      return n;
  return -1;
}
const ev = "Not capturing exception because it's already been captured.";
class Cw {
  /** Options passed to the SDK. */
  /** The client Dsn, if specified in options. Without this Dsn, the SDK will be disabled. */
  /** Array of set up integrations. */
  /** Number of calls being processed */
  /** Holds flushable  */
  // eslint-disable-next-line @typescript-eslint/ban-types
  /**
   * Initializes this client instance.
   *
   * @param options Options for the client.
   */
  constructor(e) {
    if (this._options = e, this._integrations = {}, this._numProcessing = 0, this._outcomes = {}, this._hooks = {}, this._eventProcessors = [], e.dsn ? this._dsn = mT(e.dsn) : K && I.warn("No DSN provided, client will not send events."), this._dsn) {
      const n = fw(
        this._dsn,
        e.tunnel,
        e._metadata ? e._metadata.sdk : void 0
      );
      this._transport = e.transport({
        tunnel: this._options.tunnel,
        recordDroppedEvent: this.recordDroppedEvent.bind(this),
        ...e.transportOptions,
        url: n
      });
    }
  }
  /**
   * @inheritDoc
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  captureException(e, n, r) {
    const s = se();
    if (Nh(e))
      return K && I.log(ev), s;
    const o = {
      event_id: s,
      ...n
    };
    return this._process(
      this.eventFromException(e, o).then(
        (a) => this._captureEvent(a, o, r)
      )
    ), o.event_id;
  }
  /**
   * @inheritDoc
   */
  captureMessage(e, n, r, s) {
    const o = {
      event_id: se(),
      ...r
    }, a = ep(e) ? e : String(e), i = tp(e) ? this.eventFromMessage(a, n, o) : this.eventFromException(e, o);
    return this._process(i.then((c) => this._captureEvent(c, o, s))), o.event_id;
  }
  /**
   * @inheritDoc
   */
  captureEvent(e, n, r) {
    const s = se();
    if (n && n.originalException && Nh(n.originalException))
      return K && I.log(ev), s;
    const o = {
      event_id: s,
      ...n
    }, i = (e.sdkProcessingMetadata || {}).capturedSpanScope;
    return this._process(this._captureEvent(e, o, i || r)), o.event_id;
  }
  /**
   * @inheritDoc
   */
  captureSession(e) {
    typeof e.release != "string" ? K && I.warn("Discarded session because of missing or non-string release") : (this.sendSession(e), Gn(e, { init: !1 }));
  }
  /**
   * @inheritDoc
   */
  getDsn() {
    return this._dsn;
  }
  /**
   * @inheritDoc
   */
  getOptions() {
    return this._options;
  }
  /**
   * @see SdkMetadata in @sentry/types
   *
   * @return The metadata of the SDK
   */
  getSdkMetadata() {
    return this._options._metadata;
  }
  /**
   * @inheritDoc
   */
  getTransport() {
    return this._transport;
  }
  /**
   * @inheritDoc
   */
  flush(e) {
    const n = this._transport;
    return n ? (this.emit("flush"), this._isClientDoneProcessing(e).then((r) => n.flush(e).then((s) => r && s))) : Cn(!0);
  }
  /**
   * @inheritDoc
   */
  close(e) {
    return this.flush(e).then((n) => (this.getOptions().enabled = !1, this.emit("close"), n));
  }
  /** Get all installed event processors. */
  getEventProcessors() {
    return this._eventProcessors;
  }
  /** @inheritDoc */
  addEventProcessor(e) {
    this._eventProcessors.push(e);
  }
  /** @inheritdoc */
  init() {
    this._isEnabled() && this._setupIntegrations();
  }
  /**
   * Gets an installed integration by its name.
   *
   * @returns The installed integration or `undefined` if no integration with that `name` was installed.
   */
  getIntegrationByName(e) {
    return this._integrations[e];
  }
  /**
   * @inheritDoc
   */
  addIntegration(e) {
    const n = this._integrations[e.name];
    pm(this, e, this._integrations), n || Xh(this, [e]);
  }
  /**
   * @inheritDoc
   */
  sendEvent(e, n = {}) {
    this.emit("beforeSendEvent", e, n);
    let r = LI(e, this._dsn, this._options._metadata, this._options.tunnel);
    for (const o of n.attachments || [])
      r = JT(r, ZT(o));
    const s = this.sendEnvelope(r);
    s && s.then((o) => this.emit("afterSendEvent", e, o), null);
  }
  /**
   * @inheritDoc
   */
  sendSession(e) {
    const n = NI(e, this._dsn, this._options._metadata, this._options.tunnel);
    this.sendEnvelope(n);
  }
  /**
   * @inheritDoc
   */
  recordDroppedEvent(e, n, r) {
    if (this._options.sendClientReports) {
      const s = `${e}:${n}`;
      K && I.log(`Adding outcome: "${s}"`), this._outcomes[s] = this._outcomes[s] + 1 || 1;
    }
  }
  // Keep on() & emit() signatures in sync with types' client.ts interface
  /* eslint-disable @typescript-eslint/unified-signatures */
  /** @inheritdoc */
  /** @inheritdoc */
  on(e, n) {
    this._hooks[e] || (this._hooks[e] = []), this._hooks[e].push(n);
  }
  /** @inheritdoc */
  /** @inheritdoc */
  emit(e, ...n) {
    this._hooks[e] && this._hooks[e].forEach((r) => r(...n));
  }
  /**
   * @inheritdoc
   */
  sendEnvelope(e) {
    return this.emit("beforeEnvelope", e), this._isEnabled() && this._transport ? this._transport.send(e).then(null, (n) => (K && I.error("Error while sending event:", n), n)) : (K && I.error("Transport disabled"), Cn({}));
  }
  /* eslint-enable @typescript-eslint/unified-signatures */
  /** Setup integrations for this client. */
  _setupIntegrations() {
    const { integrations: e } = this._options;
    this._integrations = Sw(this, e), Xh(this, e);
  }
  /** Updates existing session based on the provided event */
  _updateSessionFromEvent(e, n) {
    let r = !1, s = !1;
    const o = n.exception && n.exception.values;
    if (o) {
      s = !0;
      for (const c of o) {
        const u = c.mechanism;
        if (u && u.handled === !1) {
          r = !0;
          break;
        }
      }
    }
    const a = e.status === "ok";
    (a && e.errors === 0 || a && r) && (Gn(e, {
      ...r && { status: "crashed" },
      errors: e.errors || Number(s || r)
    }), this.captureSession(e));
  }
  /**
   * Determine if the client is finished processing. Returns a promise because it will wait `timeout` ms before saying
   * "no" (resolving to `false`) in order to give the client a chance to potentially finish first.
   *
   * @param timeout The time, in ms, after which to resolve to `false` if the client is still busy. Passing `0` (or not
   * passing anything) will make the promise wait as long as it takes for processing to finish before resolving to
   * `true`.
   * @returns A promise which will resolve to `true` if processing is already done or finishes before the timeout, and
   * `false` otherwise
   */
  _isClientDoneProcessing(e) {
    return new Ge((n) => {
      let r = 0;
      const s = 1, o = setInterval(() => {
        this._numProcessing == 0 ? (clearInterval(o), n(!0)) : (r += s, e && r >= e && (clearInterval(o), n(!1)));
      }, s);
    });
  }
  /** Determines whether this SDK is enabled and a transport is present. */
  _isEnabled() {
    return this.getOptions().enabled !== !1 && this._transport !== void 0;
  }
  /**
   * Adds common information to events.
   *
   * The information includes release and environment from `options`,
   * breadcrumbs and context (extra, tags and user) from the scope.
   *
   * Information that is already present in the event is never overwritten. For
   * nested objects, such as the context, keys are merged.
   *
   * @param event The original event.
   * @param hint May contain additional information about the original exception.
   * @param currentScope A scope containing event metadata.
   * @returns A new event with more information.
   */
  _prepareEvent(e, n, r, s = wt()) {
    const o = this.getOptions(), a = Object.keys(this._integrations);
    return !n.integrations && a.length > 0 && (n.integrations = a), this.emit("preprocessEvent", e, n), e.type || s.setLastEventId(e.event_id || n.event_id), nw(o, e, n, r, this, s).then((i) => {
      if (i === null)
        return i;
      const c = {
        ...s.getPropagationContext(),
        ...r ? r.getPropagationContext() : void 0
      };
      if (!(i.contexts && i.contexts.trace) && c) {
        const { traceId: p, spanId: d, parentSpanId: l, dsc: h } = c;
        i.contexts = {
          trace: ze({
            trace_id: p,
            span_id: d,
            parent_span_id: l
          }),
          ...i.contexts
        };
        const v = h || Va(p, this);
        i.sdkProcessingMetadata = {
          dynamicSamplingContext: v,
          ...i.sdkProcessingMetadata
        };
      }
      return i;
    });
  }
  /**
   * Processes the event and logs an error in case of rejection
   * @param event
   * @param hint
   * @param scope
   */
  _captureEvent(e, n = {}, r) {
    return this._processEvent(e, n, r).then(
      (s) => s.event_id,
      (s) => {
        if (K) {
          const o = s;
          o.logLevel === "log" ? I.log(o.message) : I.warn(o);
        }
      }
    );
  }
  /**
   * Processes an event (either error or message) and sends it to Sentry.
   *
   * This also adds breadcrumbs and context information to the event. However,
   * platform specific meta data (such as the User's IP address) must be added
   * by the SDK implementor.
   *
   *
   * @param event The event to send to Sentry.
   * @param hint May contain additional information about the original exception.
   * @param currentScope A scope containing event metadata.
   * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.
   */
  _processEvent(e, n, r) {
    const s = this.getOptions(), { sampleRate: o } = s, a = lm(e), i = dm(e), c = e.type || "error", u = `before send for type \`${c}\``, p = typeof o > "u" ? void 0 : rm(o);
    if (i && typeof p == "number" && Math.random() > p)
      return this.recordDroppedEvent("sample_rate", "error", e), yo(
        new ut(
          `Discarding event because it's not included in the random sample (sampling rate = ${o})`,
          "log"
        )
      );
    const d = c === "replay_event" ? "replay" : c, h = (e.sdkProcessingMetadata || {}).capturedSpanIsolationScope;
    return this._prepareEvent(e, n, r, h).then((v) => {
      if (v === null)
        throw this.recordDroppedEvent("event_processor", d, e), new ut("An event processor returned `null`, will not send event.", "log");
      if (n.data && n.data.__sentry__ === !0)
        return v;
      const f = Rw(s, v, n);
      return _w(f, u);
    }).then((v) => {
      if (v === null)
        throw this.recordDroppedEvent("before_send", d, e), new ut(`${u} returned \`null\`, will not send event.`, "log");
      const g = r && r.getSession();
      !a && g && this._updateSessionFromEvent(g, v);
      const f = v.transaction_info;
      if (a && f && v.transaction !== e.transaction) {
        const m = "custom";
        v.transaction_info = {
          ...f,
          source: m
        };
      }
      return this.sendEvent(v, n), v;
    }).then(null, (v) => {
      throw v instanceof ut ? v : (this.captureException(v, {
        data: {
          __sentry__: !0
        },
        originalException: v
      }), new ut(
        `Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.
Reason: ${v}`
      ));
    });
  }
  /**
   * Occupies the client with processing and event
   */
  _process(e) {
    this._numProcessing++, e.then(
      (n) => (this._numProcessing--, n),
      (n) => (this._numProcessing--, n)
    );
  }
  /**
   * Clears outcomes on this client and returns them.
   */
  _clearOutcomes() {
    const e = this._outcomes;
    return this._outcomes = {}, Object.keys(e).map((n) => {
      const [r, s] = n.split(":");
      return {
        reason: r,
        category: s,
        quantity: e[n]
      };
    });
  }
  /**
   * @inheritDoc
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
}
function _w(t, e) {
  const n = `${e} must return \`null\` or a valid event.`;
  if (Ha(t))
    return t.then(
      (r) => {
        if (!Kn(r) && r !== null)
          throw new ut(n);
        return r;
      },
      (r) => {
        throw new ut(`${e} rejected with ${r}`);
      }
    );
  if (!Kn(t) && t !== null)
    throw new ut(n);
  return t;
}
function Rw(t, e, n) {
  const { beforeSend: r, beforeSendTransaction: s, beforeSendSpan: o } = t;
  if (dm(e) && r)
    return r(e, n);
  if (lm(e)) {
    if (e.spans && o) {
      const a = [];
      for (const i of e.spans) {
        const c = o(i);
        c && a.push(c);
      }
      e.spans = a;
    }
    if (s)
      return s(e, n);
  }
  return e;
}
function dm(t) {
  return t.type === void 0;
}
function lm(t) {
  return t.type === "transaction";
}
function Pw(t, e) {
  e.debug === !0 && (K ? I.enable() : Ts(() => {
    console.warn("[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.");
  })), pe().update(e.initialScope);
  const r = new t(e);
  Ew(r), r.init();
}
function Ew(t) {
  pe().setClient(t), Tw(t);
}
function Tw(t) {
  const e = Wa(bn());
  e.hub && typeof e.hub.getStackTop == "function" && (e.hub.getStackTop().client = t);
}
const Iw = 64;
function ww(t, e, n = jT(
  t.bufferSize || Iw
)) {
  let r = {};
  const s = (a) => n.drain(a);
  function o(a) {
    const i = [];
    if (zh(a, (d, l) => {
      const h = jh(l);
      if (sI(r, h)) {
        const v = tv(d, l);
        t.recordDroppedEvent("ratelimit_backoff", h, v);
      } else
        i.push(d);
    }), i.length === 0)
      return Cn({});
    const c = ar(a[0], i), u = (d) => {
      zh(c, (l, h) => {
        const v = tv(l, h);
        t.recordDroppedEvent(d, jh(h), v);
      });
    }, p = () => e({ body: GT(c) }).then(
      (d) => (d.statusCode !== void 0 && (d.statusCode < 200 || d.statusCode >= 300) && K && I.warn(`Sentry responded with status code ${d.statusCode} to sent event.`), r = oI(r, d), d),
      (d) => {
        throw u("network_error"), d;
      }
    );
    return n.add(p).then(
      (d) => d,
      (d) => {
        if (d instanceof ut)
          return K && I.error("Skipped sending event because buffer is full."), u("queue_overflow"), Cn({});
        throw d;
      }
    );
  }
  return {
    send: o,
    flush: s
  };
}
function tv(t, e) {
  if (!(e !== "event" && e !== "transaction"))
    return Array.isArray(t) ? t[1] : void 0;
}
const nv = "8.4.0";
function bw(t, e, n = [e], r = "npm") {
  const s = t._metadata || {};
  s.sdk || (s.sdk = {
    name: `sentry.javascript.${e}`,
    packages: n.map((o) => ({
      name: `${r}:@sentry/${o}`,
      version: nv
    })),
    version: nv
  }), t._metadata = s;
}
const Aw = 100;
function Rn(t, e) {
  const n = ne(), r = wt();
  if (!n)
    return;
  const { beforeBreadcrumb: s = null, maxBreadcrumbs: o = Aw } = n.getOptions();
  if (o <= 0)
    return;
  const i = { timestamp: ws(), ...t }, c = s ? Ts(() => s(i, e)) : i;
  c !== null && (n.emit && n.emit("beforeAddBreadcrumb", c, e), r.addBreadcrumb(c, o));
}
let rv;
const Mw = "FunctionToString", iv = /* @__PURE__ */ new WeakMap(), kw = () => ({
  name: Mw,
  setupOnce() {
    rv = Function.prototype.toString;
    try {
      Function.prototype.toString = function(...t) {
        const e = rp(this), n = iv.has(ne()) && e !== void 0 ? e : this;
        return rv.apply(n, t);
      };
    } catch {
    }
  },
  setup(t) {
    iv.set(t, !0);
  }
}), Ow = kw, Dw = [
  /^Script error\.?$/,
  /^Javascript error: Script error\.? on line 0$/,
  /^ResizeObserver loop completed with undelivered notifications.$/,
  /^Cannot redefine property: googletag$/
], Nw = "InboundFilters", Lw = (t = {}) => ({
  name: Nw,
  processEvent(e, n, r) {
    const s = r.getOptions(), o = jw(t, s);
    return xw(e, o) ? null : e;
  }
}), zw = Lw;
function jw(t = {}, e = {}) {
  return {
    allowUrls: [...t.allowUrls || [], ...e.allowUrls || []],
    denyUrls: [...t.denyUrls || [], ...e.denyUrls || []],
    ignoreErrors: [
      ...t.ignoreErrors || [],
      ...e.ignoreErrors || [],
      ...t.disableErrorDefaults ? [] : Dw
    ],
    ignoreTransactions: [...t.ignoreTransactions || [], ...e.ignoreTransactions || []],
    ignoreInternal: t.ignoreInternal !== void 0 ? t.ignoreInternal : !0
  };
}
function xw(t, e) {
  return e.ignoreInternal && Hw(t) ? (K && I.warn(`Event dropped due to being internal Sentry Error.
Event: ${pn(t)}`), !0) : Bw(t, e.ignoreErrors) ? (K && I.warn(
    `Event dropped due to being matched by \`ignoreErrors\` option.
Event: ${pn(t)}`
  ), !0) : qw(t, e.ignoreTransactions) ? (K && I.warn(
    `Event dropped due to being matched by \`ignoreTransactions\` option.
Event: ${pn(t)}`
  ), !0) : Fw(t, e.denyUrls) ? (K && I.warn(
    `Event dropped due to being matched by \`denyUrls\` option.
Event: ${pn(
      t
    )}.
Url: ${_o(t)}`
  ), !0) : $w(t, e.allowUrls) ? !1 : (K && I.warn(
    `Event dropped due to not being matched by \`allowUrls\` option.
Event: ${pn(
      t
    )}.
Url: ${_o(t)}`
  ), !0);
}
function Bw(t, e) {
  return t.type || !e || !e.length ? !1 : Uw(t).some((n) => hn(n, e));
}
function qw(t, e) {
  if (t.type !== "transaction" || !e || !e.length)
    return !1;
  const n = t.transaction;
  return n ? hn(n, e) : !1;
}
function Fw(t, e) {
  if (!e || !e.length)
    return !1;
  const n = _o(t);
  return n ? hn(n, e) : !1;
}
function $w(t, e) {
  if (!e || !e.length)
    return !0;
  const n = _o(t);
  return n ? hn(n, e) : !0;
}
function Uw(t) {
  const e = [];
  t.message && e.push(t.message);
  let n;
  try {
    n = t.exception.values[t.exception.values.length - 1];
  } catch {
  }
  return n && n.value && (e.push(n.value), n.type && e.push(`${n.type}: ${n.value}`)), e;
}
function Hw(t) {
  try {
    return t.exception.values[0].type === "SentryError";
  } catch {
  }
  return !1;
}
function Ww(t = []) {
  for (let e = t.length - 1; e >= 0; e--) {
    const n = t[e];
    if (n && n.filename !== "<anonymous>" && n.filename !== "[native code]")
      return n.filename || null;
  }
  return null;
}
function _o(t) {
  try {
    let e;
    try {
      e = t.exception.values[0].stacktrace.frames;
    } catch {
    }
    return e ? Ww(e) : null;
  } catch {
    return K && I.error(`Cannot extract url for event ${pn(t)}`), null;
  }
}
const Vw = "Dedupe", Kw = () => {
  let t;
  return {
    name: Vw,
    processEvent(e) {
      if (e.type)
        return e;
      try {
        if (Gw(e, t))
          return K && I.warn("Event dropped due to being a duplicate of previously captured event."), null;
      } catch {
      }
      return t = e;
    }
  };
}, Jw = Kw;
function Gw(t, e) {
  return e ? !!(Qw(t, e) || Yw(t, e)) : !1;
}
function Qw(t, e) {
  const n = t.message, r = e.message;
  return !(!n && !r || n && !r || !n && r || n !== r || !vm(t, e) || !hm(t, e));
}
function Yw(t, e) {
  const n = sv(e), r = sv(t);
  return !(!n || !r || n.type !== r.type || n.value !== r.value || !vm(t, e) || !hm(t, e));
}
function hm(t, e) {
  let n = ov(t), r = ov(e);
  if (!n && !r)
    return !0;
  if (n && !r || !n && r || (n = n, r = r, r.length !== n.length))
    return !1;
  for (let s = 0; s < r.length; s++) {
    const o = r[s], a = n[s];
    if (o.filename !== a.filename || o.lineno !== a.lineno || o.colno !== a.colno || o.function !== a.function)
      return !1;
  }
  return !0;
}
function vm(t, e) {
  let n = t.fingerprint, r = e.fingerprint;
  if (!n && !r)
    return !0;
  if (n && !r || !n && r)
    return !1;
  n = n, r = r;
  try {
    return n.join("") === r.join("");
  } catch {
    return !1;
  }
}
function sv(t) {
  return t.exception && t.exception.values && t.exception.values[0];
}
function ov(t) {
  const e = t.exception;
  if (e)
    try {
      return e.values[0].stacktrace.frames;
    } catch {
      return;
    }
}
function Zw(t, e, n, r, s = "auto.http.browser") {
  if (!t.fetchData)
    return;
  const o = Ft() && e(t.fetchData.url);
  if (t.endTimestamp && o) {
    const v = t.fetchData.__span;
    if (!v)
      return;
    const g = r[v];
    g && (t1(g, t), delete r[v]);
    return;
  }
  const a = pe(), i = ne(), { method: c, url: u } = t.fetchData, p = e1(u), d = p ? vn(p).host : void 0, l = !!Xe(), h = o && l ? kn({
    name: `${c} ${u}`,
    attributes: {
      url: u,
      type: "fetch",
      "http.method": c,
      "http.url": p,
      "server.address": d,
      [xe]: s,
      [ps]: "http.client"
    }
  }) : new cr();
  if (t.fetchData.__span = h.spanContext().spanId, r[h.spanContext().spanId] = h, n(t.fetchData.url) && i) {
    const v = t.args[0];
    t.args[1] = t.args[1] || {};
    const g = t.args[1];
    g.headers = Xw(
      v,
      i,
      a,
      g,
      // If performance is disabled (TWP) or there's no active root span (pageload/navigation/interaction),
      // we do not want to use the span as base for the trace headers,
      // which means that the headers will be generated from the scope and the sampling decision is deferred
      Ft() && l ? h : void 0
    );
  }
  return h;
}
function Xw(t, e, n, r, s) {
  const o = wt(), { traceId: a, spanId: i, sampled: c, dsc: u } = {
    ...o.getPropagationContext(),
    ...n.getPropagationContext()
  }, p = s ? Yg(s) : ip(a, i, c), d = $g(
    u || (s ? Mn(s) : Va(a, e))
  ), l = r.headers || (typeof Request < "u" && Et(t, Request) ? t.headers : void 0);
  if (l)
    if (typeof Headers < "u" && Et(l, Headers)) {
      const h = new Headers(l);
      return h.append("sentry-trace", p), d && h.append(ou, d), h;
    } else if (Array.isArray(l)) {
      const h = [...l, ["sentry-trace", p]];
      return d && h.push([ou, d]), h;
    } else {
      const h = "baggage" in l ? l.baggage : void 0, v = [];
      return Array.isArray(h) ? v.push(...h) : h && v.push(h), d && v.push(d), {
        ...l,
        "sentry-trace": p,
        baggage: v.length > 0 ? v.join(",") : void 0
      };
    }
  else
    return { "sentry-trace": p, baggage: d };
}
function e1(t) {
  try {
    return new URL(t).href;
  } catch {
    return;
  }
}
function t1(t, e) {
  if (e.response) {
    Jg(t, e.response.status);
    const n = e.response && e.response.headers && e.response.headers.get("content-length");
    if (n) {
      const r = parseInt(n);
      r > 0 && t.setAttribute("http.response_content_length", r);
    }
  } else
    e.error && t.setStatus({ code: me, message: "internal_error" });
  t.end();
}
const $ = Y;
let hu = 0;
function fm() {
  return hu > 0;
}
function n1() {
  hu++, setTimeout(() => {
    hu--;
  });
}
function Yn(t, e = {}, n) {
  if (typeof t != "function")
    return t;
  try {
    const s = t.__sentry_wrapped__;
    if (s)
      return s;
    if (rp(t))
      return t;
  } catch {
    return t;
  }
  const r = function() {
    const s = Array.prototype.slice.call(arguments);
    try {
      const o = s.map((a) => Yn(a, e));
      return t.apply(this, o);
    } catch (o) {
      throw n1(), op((a) => {
        a.addEventProcessor((i) => (e.mechanism && (iu(i, void 0), cs(i, e.mechanism)), i.extra = {
          ...i.extra,
          arguments: s
        }, i)), uw(o);
      }), o;
    }
  };
  try {
    for (const s in t)
      Object.prototype.hasOwnProperty.call(t, s) && (r[s] = t[s]);
  } catch {
  }
  Ag(r, t), rt(t, "__sentry_wrapped__", r);
  try {
    Object.getOwnPropertyDescriptor(r, "name").configurable && Object.defineProperty(r, "name", {
      get() {
        return t.name;
      }
    });
  } catch {
  }
  return r;
}
const $e = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__;
function dp(t, e) {
  const n = lp(t, e), r = {
    type: e && e.name,
    value: a1(e)
  };
  return n.length && (r.stacktrace = { frames: n }), r.type === void 0 && r.value === "" && (r.value = "Unrecoverable error caught"), r;
}
function r1(t, e, n, r) {
  const s = ne(), o = s && s.getOptions().normalizeDepth, a = l1(e), i = {
    __serialized__: qg(e, o)
  };
  if (a)
    return {
      exception: {
        values: [dp(t, a)]
      },
      extra: i
    };
  const c = {
    exception: {
      values: [
        {
          type: Ua(e) ? e.constructor.name : r ? "UnhandledRejection" : "Error",
          value: p1(e, { isUnhandledRejection: r })
        }
      ]
    },
    extra: i
  };
  if (n) {
    const u = lp(t, n);
    u.length && (c.exception.values[0].stacktrace = { frames: u });
  }
  return c;
}
function kc(t, e) {
  return {
    exception: {
      values: [dp(t, e)]
    }
  };
}
function lp(t, e) {
  const n = e.stacktrace || e.stack || "", r = s1(e), s = o1(e);
  try {
    return t(n, r, s);
  } catch {
  }
  return [];
}
const i1 = /Minified React error #\d+;/i;
function s1(t) {
  return t && i1.test(t.message) ? 1 : 0;
}
function o1(t) {
  return typeof t.framesToPop == "number" ? t.framesToPop : 0;
}
function a1(t) {
  const e = t && t.message;
  return e ? e.error && typeof e.error.message == "string" ? e.error.message : e : "No error message";
}
function c1(t, e, n, r) {
  const s = n && n.syntheticException || void 0, o = hp(t, e, s, r);
  return cs(o), o.level = "error", n && n.event_id && (o.event_id = n.event_id), Cn(o);
}
function u1(t, e, n = "info", r, s) {
  const o = r && r.syntheticException || void 0, a = vu(t, e, o, s);
  return a.level = n, r && r.event_id && (a.event_id = r.event_id), Cn(a);
}
function hp(t, e, n, r, s) {
  let o;
  if (Tg(e) && e.error)
    return kc(t, e.error);
  if (Eh(e) || eT(e)) {
    const a = e;
    if ("stack" in e)
      o = kc(t, e);
    else {
      const i = a.name || (Eh(a) ? "DOMError" : "DOMException"), c = a.message ? `${i}: ${a.message}` : i;
      o = vu(t, c, n, r), iu(o, c);
    }
    return "code" in a && (o.tags = { ...o.tags, "DOMException.code": `${a.code}` }), o;
  }
  return Eg(e) ? kc(t, e) : Kn(e) || Ua(e) ? (o = r1(t, e, n, s), cs(o, {
    synthetic: !0
  }), o) : (o = vu(t, e, n, r), iu(o, `${e}`), cs(o, {
    synthetic: !0
  }), o);
}
function vu(t, e, n, r) {
  const s = {};
  if (r && n) {
    const o = lp(t, n);
    o.length && (s.exception = {
      values: [{ value: e, stacktrace: { frames: o } }]
    });
  }
  if (ep(e)) {
    const { __sentry_template_string__: o, __sentry_template_values__: a } = e;
    return s.logentry = {
      message: o,
      params: a
    }, s;
  }
  return s.message = e, s;
}
function p1(t, { isUnhandledRejection: e }) {
  const n = yT(t), r = e ? "promise rejection" : "exception";
  return Tg(t) ? `Event \`ErrorEvent\` captured as ${r} with message \`${t.message}\`` : Ua(t) ? `Event \`${d1(t)}\` (type=${t.type}) captured as ${r}` : `Object captured as ${r} with keys: ${n}`;
}
function d1(t) {
  try {
    const e = Object.getPrototypeOf(t);
    return e ? e.constructor.name : void 0;
  } catch {
  }
}
function l1(t) {
  for (const e in t)
    if (Object.prototype.hasOwnProperty.call(t, e)) {
      const n = t[e];
      if (n instanceof Error)
        return n;
    }
}
function h1(t, {
  metadata: e,
  tunnel: n,
  dsn: r
}) {
  const s = {
    event_id: t.event_id,
    sent_at: (/* @__PURE__ */ new Date()).toISOString(),
    ...e && e.sdk && {
      sdk: {
        name: e.sdk.name,
        version: e.sdk.version
      }
    },
    ...!!n && !!r && { dsn: Is(r) }
  }, o = v1(t);
  return ar(s, [o]);
}
function v1(t) {
  return [{
    type: "user_report"
  }, t];
}
class f1 extends Cw {
  /**
   * Creates a new Browser SDK instance.
   *
   * @param options Configuration options for this SDK.
   */
  constructor(e) {
    const n = {
      // We default this to true, as it is the safer scenario
      parentSpanIsAlwaysRootSpan: !0,
      ...e
    }, r = $.SENTRY_SDK_SOURCE || kT();
    bw(n, "browser", ["browser"], r), super(n), n.sendClientReports && $.document && $.document.addEventListener("visibilitychange", () => {
      $.document.visibilityState === "hidden" && this._flushOutcomes();
    });
  }
  /**
   * @inheritDoc
   */
  eventFromException(e, n) {
    return c1(this._options.stackParser, e, n, this._options.attachStacktrace);
  }
  /**
   * @inheritDoc
   */
  eventFromMessage(e, n = "info", r) {
    return u1(this._options.stackParser, e, n, r, this._options.attachStacktrace);
  }
  /**
   * Sends user feedback to Sentry.
   *
   * @deprecated Use `captureFeedback` instead.
   */
  captureUserFeedback(e) {
    if (!this._isEnabled()) {
      $e && I.warn("SDK not enabled, will not capture user feedback.");
      return;
    }
    const n = h1(e, {
      metadata: this.getSdkMetadata(),
      dsn: this.getDsn(),
      tunnel: this.getOptions().tunnel
    });
    this.sendEnvelope(n);
  }
  /**
   * @inheritDoc
   */
  _prepareEvent(e, n, r) {
    return e.platform = e.platform || "javascript", super._prepareEvent(e, n, r);
  }
  /**
   * Sends client reports as an envelope.
   */
  _flushOutcomes() {
    const e = this._clearOutcomes();
    if (e.length === 0) {
      $e && I.log("No outcomes to send");
      return;
    }
    if (!this._dsn) {
      $e && I.log("No dsn provided, will not send outcomes");
      return;
    }
    $e && I.log("Sending outcomes:", e);
    const n = tI(e, this._options.tunnel && Is(this._dsn));
    this.sendEnvelope(n);
  }
}
const Ke = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__, g1 = (t, e) => t > e[1] ? "poor" : t > e[0] ? "needs-improvement" : "good", ur = (t, e, n, r) => {
  let s, o;
  return (a) => {
    e.value >= 0 && (a || r) && (o = e.value - (s || 0), (o || s === void 0) && (s = e.value, e.delta = o, e.rating = g1(e.value, n), t(e)));
  };
}, z = Y, m1 = () => `v3-${Date.now()}-${Math.floor(Math.random() * (9e12 - 1)) + 1e12}`, Ka = () => z.performance && performance.getEntriesByType && performance.getEntriesByType("navigation")[0], Ja = () => {
  const t = Ka();
  return t && t.activationStart || 0;
}, pr = (t, e) => {
  const n = Ka();
  let r = "navigate";
  return n && (z.document && z.document.prerendering || Ja() > 0 ? r = "prerender" : z.document && z.document.wasDiscarded ? r = "restore" : n.type && (r = n.type.replace(/_/g, "-"))), {
    name: t,
    value: typeof e > "u" ? -1 : e,
    rating: "good",
    // If needed, will be updated when reported. `const` to keep the type from widening to `string`.
    delta: 0,
    entries: [],
    id: m1(),
    navigationType: r
  };
}, On = (t, e, n) => {
  try {
    if (PerformanceObserver.supportedEntryTypes.includes(t)) {
      const r = new PerformanceObserver((s) => {
        Promise.resolve().then(() => {
          e(s.getEntries());
        });
      });
      return r.observe(
        Object.assign(
          {
            type: t,
            buffered: !0
          },
          n || {}
        )
      ), r;
    }
  } catch {
  }
}, Ga = (t) => {
  const e = (n) => {
    (n.type === "pagehide" || z.document && z.document.visibilityState === "hidden") && t(n);
  };
  z.document && (addEventListener("visibilitychange", e, !0), addEventListener("pagehide", e, !0));
}, vp = (t) => {
  let e = !1;
  return (n) => {
    e || (t(n), e = !0);
  };
};
let ds = -1;
const S1 = () => {
  ds = z.document.visibilityState === "hidden" && !z.document.prerendering ? 0 : 1 / 0;
}, Ro = (t) => {
  z.document.visibilityState === "hidden" && ds > -1 && (ds = t.type === "visibilitychange" ? t.timeStamp : 0, removeEventListener("visibilitychange", Ro, !0), removeEventListener("prerenderingchange", Ro, !0));
}, y1 = () => {
  addEventListener("visibilitychange", Ro, !0), addEventListener("prerenderingchange", Ro, !0);
}, Qa = () => (z.document && ds < 0 && (S1(), y1()), {
  get firstHiddenTime() {
    return ds;
  }
}), As = (t) => {
  z.document && z.document.prerendering ? addEventListener("prerenderingchange", () => t(), !0) : t();
}, C1 = [1800, 3e3], _1 = (t, e = {}) => {
  As(() => {
    const n = Qa(), r = pr("FCP");
    let s;
    const a = On("paint", (i) => {
      i.forEach((c) => {
        c.name === "first-contentful-paint" && (a.disconnect(), c.startTime < n.firstHiddenTime && (r.value = Math.max(c.startTime - Ja(), 0), r.entries.push(c), s(!0)));
      });
    });
    a && (s = ur(t, r, C1, e.reportAllChanges));
  });
}, R1 = [0.1, 0.25], P1 = (t, e = {}) => {
  _1(
    vp(() => {
      const n = pr("CLS", 0);
      let r, s = 0, o = [];
      const a = (c) => {
        c.forEach((u) => {
          if (!u.hadRecentInput) {
            const p = o[0], d = o[o.length - 1];
            s && u.startTime - d.startTime < 1e3 && u.startTime - p.startTime < 5e3 ? (s += u.value, o.push(u)) : (s = u.value, o = [u]);
          }
        }), s > n.value && (n.value = s, n.entries = o, r());
      }, i = On("layout-shift", a);
      i && (r = ur(t, n, R1, e.reportAllChanges), Ga(() => {
        a(i.takeRecords()), r(!0);
      }), setTimeout(r, 0));
    })
  );
}, E1 = [100, 300], T1 = (t, e = {}) => {
  As(() => {
    const n = Qa(), r = pr("FID");
    let s;
    const o = (c) => {
      c.startTime < n.firstHiddenTime && (r.value = c.processingStart - c.startTime, r.entries.push(c), s(!0));
    }, a = (c) => {
      c.forEach(o);
    }, i = On("first-input", a);
    s = ur(t, r, E1, e.reportAllChanges), i && Ga(
      vp(() => {
        a(i.takeRecords()), i.disconnect();
      })
    );
  });
};
let gm = 0, Oc = 1 / 0, Gs = 0;
const I1 = (t) => {
  t.forEach((e) => {
    e.interactionId && (Oc = Math.min(Oc, e.interactionId), Gs = Math.max(Gs, e.interactionId), gm = Gs ? (Gs - Oc) / 7 + 1 : 0);
  });
};
let fu;
const w1 = () => fu ? gm : performance.interactionCount || 0, b1 = () => {
  "interactionCount" in performance || fu || (fu = On("event", I1, {
    type: "event",
    buffered: !0,
    durationThreshold: 0
  }));
}, A1 = [200, 500], M1 = 0, mm = () => w1() - M1, av = 10, Ct = [], Dc = {}, cv = (t) => {
  const e = Ct[Ct.length - 1], n = Dc[t.interactionId];
  if (n || Ct.length < av || t.duration > e.latency) {
    if (n)
      n.entries.push(t), n.latency = Math.max(n.latency, t.duration);
    else {
      const r = {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        id: t.interactionId,
        latency: t.duration,
        entries: [t]
      };
      Dc[r.id] = r, Ct.push(r);
    }
    Ct.sort((r, s) => s.latency - r.latency), Ct.splice(av).forEach((r) => {
      delete Dc[r.id];
    });
  }
}, k1 = () => {
  const t = Math.min(
    Ct.length - 1,
    Math.floor(mm() / 50)
  );
  return Ct[t];
}, O1 = (t, e = {}) => {
  As(() => {
    b1();
    const n = pr("INP");
    let r;
    const s = (a) => {
      a.forEach((c) => {
        c.interactionId && cv(c), c.entryType === "first-input" && !Ct.some((p) => p.entries.some((d) => c.duration === d.duration && c.startTime === d.startTime)) && cv(c);
      });
      const i = k1();
      i && i.latency !== n.value && (n.value = i.latency, n.entries = i.entries, r());
    }, o = On("event", s, {
      // Event Timing entries have their durations rounded to the nearest 8ms,
      // so a duration of 40ms would be any event that spans 2.5 or more frames
      // at 60Hz. This threshold is chosen to strike a balance between usefulness
      // and performance. Running this callback for any interaction that spans
      // just one or two frames is likely not worth the insight that could be
      // gained.
      durationThreshold: e.durationThreshold != null ? e.durationThreshold : 40
    });
    r = ur(t, n, A1, e.reportAllChanges), o && ("PerformanceEventTiming" in z && "interactionId" in PerformanceEventTiming.prototype && o.observe({ type: "first-input", buffered: !0 }), Ga(() => {
      s(o.takeRecords()), n.value < 0 && mm() > 0 && (n.value = 0, n.entries = []), r(!0);
    }));
  });
}, D1 = [2500, 4e3], uv = {}, N1 = (t, e = {}) => {
  As(() => {
    const n = Qa(), r = pr("LCP");
    let s;
    const o = (i) => {
      const c = i[i.length - 1];
      c && c.startTime < n.firstHiddenTime && (r.value = Math.max(c.startTime - Ja(), 0), r.entries = [c], s());
    }, a = On("largest-contentful-paint", o);
    if (a) {
      s = ur(t, r, D1, e.reportAllChanges);
      const i = vp(() => {
        uv[r.id] || (o(a.takeRecords()), a.disconnect(), uv[r.id] = !0, s(!0));
      });
      ["keydown", "click"].forEach((c) => {
        z.document && addEventListener(c, () => setTimeout(i, 0), !0);
      }), Ga(i);
    }
  });
}, L1 = [800, 1800], gu = (t) => {
  z.document && z.document.prerendering ? As(() => gu(t)) : z.document && z.document.readyState !== "complete" ? addEventListener("load", () => gu(t), !0) : setTimeout(t, 0);
}, z1 = (t, e = {}) => {
  const n = pr("TTFB"), r = ur(t, n, L1, e.reportAllChanges);
  gu(() => {
    const s = Ka();
    if (s) {
      const o = s.responseStart;
      if (o <= 0 || o > performance.now())
        return;
      n.value = Math.max(o - Ja(), 0), n.entries = [s], r(!0);
    }
  });
}, es = {}, Po = {};
let Sm, ym, Cm, _m, Rm;
function j1(t, e = !1) {
  return Ms("cls", t, $1, Sm, e);
}
function x1(t, e = !1) {
  return Ms("lcp", t, H1, Cm, e);
}
function B1(t) {
  return Ms("fid", t, U1, ym);
}
function q1(t) {
  return Ms("ttfb", t, W1, _m);
}
function F1(t) {
  return Ms("inp", t, V1, Rm);
}
function fp(t, e) {
  return Pm(t, e), Po[t] || (K1(t), Po[t] = !0), Em(t, e);
}
function dr(t, e) {
  const n = es[t];
  if (!(!n || !n.length))
    for (const r of n)
      try {
        r(e);
      } catch (s) {
        Ke && I.error(
          `Error while triggering instrumentation handler.
Type: ${t}
Name: ${Tt(r)}
Error:`,
          s
        );
      }
}
function $1() {
  return P1(
    (t) => {
      dr("cls", {
        metric: t
      }), Sm = t;
    },
    // We want the callback to be called whenever the CLS value updates.
    // By default, the callback is only called when the tab goes to the background.
    { reportAllChanges: !0 }
  );
}
function U1() {
  return T1((t) => {
    dr("fid", {
      metric: t
    }), ym = t;
  });
}
function H1() {
  return N1((t) => {
    dr("lcp", {
      metric: t
    }), Cm = t;
  });
}
function W1() {
  return z1((t) => {
    dr("ttfb", {
      metric: t
    }), _m = t;
  });
}
function V1() {
  return O1((t) => {
    dr("inp", {
      metric: t
    }), Rm = t;
  });
}
function Ms(t, e, n, r, s = !1) {
  Pm(t, e);
  let o;
  return Po[t] || (o = n(), Po[t] = !0), r && e({ metric: r }), Em(t, e, s ? o : void 0);
}
function K1(t) {
  const e = {};
  t === "event" && (e.durationThreshold = 0), On(
    t,
    (n) => {
      dr(t, { entries: n });
    },
    e
  );
}
function Pm(t, e) {
  es[t] = es[t] || [], es[t].push(e);
}
function Em(t, e, n) {
  return () => {
    n && n();
    const r = es[t];
    if (!r)
      return;
    const s = r.indexOf(e);
    s !== -1 && r.splice(s, 1);
  };
}
function Nc(t) {
  return typeof t == "number" && isFinite(t);
}
function Zn(t, e, n, { ...r }) {
  const s = te(t).start_timestamp;
  return s && s > e && typeof t.updateStartTime == "function" && t.updateStartTime(e), qI(t, () => {
    const o = kn({
      startTime: e,
      ...r
    });
    return o && o.end(n), o;
  });
}
function gp() {
  return z && z.addEventListener && z.performance;
}
function ge(t) {
  return t / 1e3;
}
const J1 = 2147483647;
let pv = 0, de = {}, ct, ts;
function G1() {
  const t = gp();
  if (t && Ze) {
    t.mark && z.performance.mark("sentry-tracing-init");
    const e = eb(), n = Z1(), r = X1(), s = tb();
    return () => {
      e(), n(), r(), s();
    };
  }
  return () => {
  };
}
function Q1() {
  fp("longtask", ({ entries: t }) => {
    for (const e of t) {
      if (!Xe())
        return;
      const n = ge(Ze + e.startTime), r = ge(e.duration), s = kn({
        name: "Main UI thread blocked",
        op: "ui.long-task",
        startTime: n,
        attributes: {
          [xe]: "auto.ui.browser.metrics"
        }
      });
      s && s.end(n + r);
    }
  });
}
function Y1() {
  fp("event", ({ entries: t }) => {
    for (const e of t) {
      if (!Xe())
        return;
      if (e.name === "click") {
        const n = ge(Ze + e.startTime), r = ge(e.duration), s = {
          name: Jn(e.target),
          op: `ui.interaction.${e.name}`,
          startTime: n,
          attributes: {
            [xe]: "auto.ui.browser.metrics"
          }
        }, o = wg(e.target);
        o && (s.attributes["ui.component_name"] = o);
        const a = kn(s);
        a && a.end(n + r);
      }
    }
  });
}
function Z1() {
  return j1(({ metric: t }) => {
    const e = t.entries[t.entries.length - 1];
    e && (Ke && I.log("[Measurements] Adding CLS"), de.cls = { value: t.value, unit: "" }, ts = e);
  }, !0);
}
function X1() {
  return x1(({ metric: t }) => {
    const e = t.entries[t.entries.length - 1];
    e && (Ke && I.log("[Measurements] Adding LCP"), de.lcp = { value: t.value, unit: "millisecond" }, ct = e);
  }, !0);
}
function eb() {
  return B1(({ metric: t }) => {
    const e = t.entries[t.entries.length - 1];
    if (!e)
      return;
    const n = ge(Ze), r = ge(e.startTime);
    Ke && I.log("[Measurements] Adding FID"), de.fid = { value: t.value, unit: "millisecond" }, de["mark.fid"] = { value: n + r, unit: "second" };
  });
}
function tb() {
  return q1(({ metric: t }) => {
    t.entries[t.entries.length - 1] && (Ke && I.log("[Measurements] Adding TTFB"), de.ttfb = { value: t.value, unit: "millisecond" });
  });
}
function nb(t) {
  const e = gp();
  if (!e || !z.performance.getEntries || !Ze)
    return;
  Ke && I.log("[Tracing] Adding & adjusting spans using Performance API");
  const n = ge(Ze), r = e.getEntries(), { op: s, start_timestamp: o } = te(t);
  if (r.slice(pv).forEach((a) => {
    const i = ge(a.startTime), c = ge(a.duration);
    if (!(s === "navigation" && o && n + i < o))
      switch (a.entryType) {
        case "navigation": {
          ib(t, a, n);
          break;
        }
        case "mark":
        case "paint":
        case "measure": {
          rb(t, a, i, c, n);
          const u = Qa(), p = a.startTime < u.firstHiddenTime;
          a.name === "first-paint" && p && (Ke && I.log("[Measurements] Adding FP"), de.fp = { value: a.startTime, unit: "millisecond" }), a.name === "first-contentful-paint" && p && (Ke && I.log("[Measurements] Adding FCP"), de.fcp = { value: a.startTime, unit: "millisecond" });
          break;
        }
        case "resource": {
          ob(t, a, a.name, i, c, n);
          break;
        }
      }
  }), pv = Math.max(r.length - 1, 0), ab(t), s === "pageload") {
    ub(de), ["fcp", "fp", "lcp"].forEach((i) => {
      if (!de[i] || !o || n >= o)
        return;
      const c = de[i].value, u = n + ge(c), p = Math.abs((u - o) * 1e3), d = p - c;
      Ke && I.log(`[Measurements] Normalized ${i} from ${c} to ${p} (${d})`), de[i].value = p;
    });
    const a = de["mark.fid"];
    a && de.fid && (Zn(t, a.value, a.value + ge(de.fid.value), {
      name: "first input delay",
      op: "ui.action",
      attributes: {
        [xe]: "auto.ui.browser.metrics"
      }
    }), delete de["mark.fid"]), "fcp" in de || delete de.cls, Object.keys(de).forEach((i) => {
      jI(i, de[i].value, de[i].unit);
    }), cb(t);
  }
  ct = void 0, ts = void 0, de = {};
}
function rb(t, e, n, r, s) {
  const o = s + n, a = o + r;
  return Zn(t, o, a, {
    name: e.name,
    op: e.entryType,
    attributes: {
      [xe]: "auto.resource.browser.metrics"
    }
  }), o;
}
function ib(t, e, n) {
  ["unloadEvent", "redirect", "domContentLoadedEvent", "loadEvent", "connect"].forEach((r) => {
    Qs(t, e, r, n);
  }), Qs(t, e, "secureConnection", n, "TLS/SSL", "connectEnd"), Qs(t, e, "fetch", n, "cache", "domainLookupStart"), Qs(t, e, "domainLookup", n, "DNS"), sb(t, e, n);
}
function Qs(t, e, n, r, s, o) {
  const a = o ? e[o] : e[`${n}End`], i = e[`${n}Start`];
  !i || !a || Zn(t, r + ge(i), r + ge(a), {
    op: "browser",
    name: s || n,
    attributes: {
      [xe]: "auto.ui.browser.metrics"
    }
  });
}
function sb(t, e, n) {
  e.responseEnd && (Zn(
    t,
    n + ge(e.requestStart),
    n + ge(e.responseEnd),
    {
      op: "browser",
      name: "request",
      attributes: {
        [xe]: "auto.ui.browser.metrics"
      }
    }
  ), Zn(
    t,
    n + ge(e.responseStart),
    n + ge(e.responseEnd),
    {
      op: "browser",
      name: "response",
      attributes: {
        [xe]: "auto.ui.browser.metrics"
      }
    }
  ));
}
function ob(t, e, n, r, s, o) {
  if (e.initiatorType === "xmlhttprequest" || e.initiatorType === "fetch")
    return;
  const a = vn(n), i = {
    [xe]: "auto.resource.browser.metrics"
  };
  Lc(i, e, "transferSize", "http.response_transfer_size"), Lc(i, e, "encodedBodySize", "http.response_content_length"), Lc(i, e, "decodedBodySize", "http.decoded_response_content_length"), "renderBlockingStatus" in e && (i["resource.render_blocking_status"] = e.renderBlockingStatus), a.protocol && (i["url.scheme"] = a.protocol.split(":").pop()), a.host && (i["server.address"] = a.host), i["url.same_origin"] = n.includes(z.location.origin);
  const c = o + r, u = c + s;
  Zn(t, c, u, {
    name: n.replace(z.location.origin, ""),
    op: e.initiatorType ? `resource.${e.initiatorType}` : "resource.other",
    attributes: i
  });
}
function ab(t) {
  const e = z.navigator;
  if (!e)
    return;
  const n = e.connection;
  n && (n.effectiveType && t.setAttribute("effectiveConnectionType", n.effectiveType), n.type && t.setAttribute("connectionType", n.type), Nc(n.rtt) && (de["connection.rtt"] = { value: n.rtt, unit: "millisecond" })), Nc(e.deviceMemory) && t.setAttribute("deviceMemory", `${e.deviceMemory} GB`), Nc(e.hardwareConcurrency) && t.setAttribute("hardwareConcurrency", String(e.hardwareConcurrency));
}
function cb(t) {
  ct && (Ke && I.log("[Measurements] Adding LCP Data"), ct.element && t.setAttribute("lcp.element", Jn(ct.element)), ct.id && t.setAttribute("lcp.id", ct.id), ct.url && t.setAttribute("lcp.url", ct.url.trim().slice(0, 200)), t.setAttribute("lcp.size", ct.size)), ts && ts.sources && (Ke && I.log("[Measurements] Adding CLS Data"), ts.sources.forEach(
    (e, n) => t.setAttribute(`cls.source.${n + 1}`, Jn(e.node))
  ));
}
function Lc(t, e, n, r) {
  const s = e[n];
  s != null && s < J1 && (t[r] = s);
}
function ub(t) {
  const e = Ka();
  if (!e)
    return;
  const { responseStart: n, requestStart: r } = e;
  r <= n && (Ke && I.log("[Measurements] Adding TTFB Request Time"), t["ttfb.requestTime"] = {
    value: n - r,
    unit: "millisecond"
  });
}
const pb = 1e3;
let dv, mu, Su;
function db(t) {
  const e = "dom";
  In(e, t), wn(e, lb);
}
function lb() {
  if (!z.document)
    return;
  const t = nt.bind(null, "dom"), e = lv(t, !0);
  z.document.addEventListener("click", e, !1), z.document.addEventListener("keypress", e, !1), ["EventTarget", "Node"].forEach((n) => {
    const r = z[n] && z[n].prototype;
    !r || !r.hasOwnProperty || !r.hasOwnProperty("addEventListener") || (Pe(r, "addEventListener", function(s) {
      return function(o, a, i) {
        if (o === "click" || o == "keypress")
          try {
            const c = this, u = c.__sentry_instrumentation_handlers__ = c.__sentry_instrumentation_handlers__ || {}, p = u[o] = u[o] || { refCount: 0 };
            if (!p.handler) {
              const d = lv(t);
              p.handler = d, s.call(this, o, d, i);
            }
            p.refCount++;
          } catch {
          }
        return s.call(this, o, a, i);
      };
    }), Pe(
      r,
      "removeEventListener",
      function(s) {
        return function(o, a, i) {
          if (o === "click" || o == "keypress")
            try {
              const c = this, u = c.__sentry_instrumentation_handlers__ || {}, p = u[o];
              p && (p.refCount--, p.refCount <= 0 && (s.call(this, o, p.handler, i), p.handler = void 0, delete u[o]), Object.keys(u).length === 0 && delete c.__sentry_instrumentation_handlers__);
            } catch {
            }
          return s.call(this, o, a, i);
        };
      }
    ));
  });
}
function hb(t) {
  if (t.type !== mu)
    return !1;
  try {
    if (!t.target || t.target._sentryId !== Su)
      return !1;
  } catch {
  }
  return !0;
}
function vb(t, e) {
  return t !== "keypress" ? !1 : !e || !e.tagName ? !0 : !(e.tagName === "INPUT" || e.tagName === "TEXTAREA" || e.isContentEditable);
}
function lv(t, e = !1) {
  return (n) => {
    if (!n || n._sentryCaptured)
      return;
    const r = fb(n);
    if (vb(n.type, r))
      return;
    rt(n, "_sentryCaptured", !0), r && !r._sentryId && rt(r, "_sentryId", se());
    const s = n.type === "keypress" ? "input" : n.type;
    hb(n) || (t({ event: n, name: s, global: e }), mu = n.type, Su = r ? r._sentryId : void 0), clearTimeout(dv), dv = z.setTimeout(() => {
      Su = void 0, mu = void 0;
    }, pb);
  };
}
function fb(t) {
  try {
    return t.target;
  } catch {
    return null;
  }
}
let Ys;
function mp(t) {
  const e = "history";
  In(e, t), wn(e, gb);
}
function gb() {
  if (!cI())
    return;
  const t = z.onpopstate;
  z.onpopstate = function(...n) {
    const r = z.location.href, s = Ys;
    if (Ys = r, nt("history", { from: s, to: r }), t)
      try {
        return t.apply(this, n);
      } catch {
      }
  };
  function e(n) {
    return function(...r) {
      const s = r.length > 2 ? r[2] : void 0;
      if (s) {
        const o = Ys, a = String(s);
        Ys = a, nt("history", { from: o, to: a });
      }
      return n.apply(this, r);
    };
  }
  Pe(z.history, "pushState", e), Pe(z.history, "replaceState", e);
}
const co = {};
function mb(t) {
  const e = co[t];
  if (e)
    return e;
  let n = z[t];
  if (nu(n))
    return co[t] = n.bind(z);
  const r = z.document;
  if (r && typeof r.createElement == "function")
    try {
      const s = r.createElement("iframe");
      s.hidden = !0, r.head.appendChild(s);
      const o = s.contentWindow;
      o && o[t] && (n = o[t]), r.head.removeChild(s);
    } catch (s) {
      Ke && I.warn(`Could not create sandbox iframe for ${t} check, bailing to window.${t}: `, s);
    }
  return n && (co[t] = n.bind(z));
}
function hv(t) {
  co[t] = void 0;
}
const qn = "__sentry_xhr_v3__";
function Tm(t) {
  const e = "xhr";
  In(e, t), wn(e, Sb);
}
function Sb() {
  if (!z.XMLHttpRequest)
    return;
  const t = XMLHttpRequest.prototype;
  Pe(t, "open", function(e) {
    return function(...n) {
      const r = Ue() * 1e3, s = Pt(n[0]) ? n[0].toUpperCase() : void 0, o = yb(n[1]);
      if (!s || !o)
        return e.apply(this, n);
      this[qn] = {
        method: s,
        url: o,
        request_headers: {}
      }, s === "POST" && o.match(/sentry_key/) && (this.__sentry_own_request__ = !0);
      const a = () => {
        const i = this[qn];
        if (i && this.readyState === 4) {
          try {
            i.status_code = this.status;
          } catch {
          }
          const c = {
            endTimestamp: Ue() * 1e3,
            startTimestamp: r,
            xhr: this
          };
          nt("xhr", c);
        }
      };
      return "onreadystatechange" in this && typeof this.onreadystatechange == "function" ? Pe(this, "onreadystatechange", function(i) {
        return function(...c) {
          return a(), i.apply(this, c);
        };
      }) : this.addEventListener("readystatechange", a), Pe(this, "setRequestHeader", function(i) {
        return function(...c) {
          const [u, p] = c, d = this[qn];
          return d && Pt(u) && Pt(p) && (d.request_headers[u.toLowerCase()] = p), i.apply(this, c);
        };
      }), e.apply(this, n);
    };
  }), Pe(t, "send", function(e) {
    return function(...n) {
      const r = this[qn];
      if (!r)
        return e.apply(this, n);
      n[0] !== void 0 && (r.body = n[0]);
      const s = {
        startTimestamp: Ue() * 1e3,
        xhr: this
      };
      return nt("xhr", s), e.apply(this, n);
    };
  });
}
function yb(t) {
  if (Pt(t))
    return t;
  try {
    return t.toString();
  } catch {
  }
}
function Cb() {
  if (gp() && Ze) {
    const e = _b();
    return () => {
      e();
    };
  }
  return () => {
  };
}
const vv = {
  click: "click",
  pointerdown: "click",
  pointerup: "click",
  mousedown: "click",
  mouseup: "click",
  touchstart: "click",
  touchend: "click",
  mouseover: "hover",
  mouseout: "hover",
  mouseenter: "hover",
  mouseleave: "hover",
  pointerover: "hover",
  pointerout: "hover",
  pointerenter: "hover",
  pointerleave: "hover",
  dragstart: "drag",
  dragend: "drag",
  drag: "drag",
  dragenter: "drag",
  dragleave: "drag",
  dragover: "drag",
  drop: "drag",
  keydown: "press",
  keyup: "press",
  keypress: "press",
  input: "press"
};
function _b() {
  return F1(({ metric: t }) => {
    const e = ne();
    if (!e || t.value == null)
      return;
    const n = t.entries.find((y) => y.duration === t.value && vv[y.name]);
    if (!n)
      return;
    const r = vv[n.name], s = e.getOptions(), o = ge(Ze + n.startTime), a = ge(t.value), i = pe(), c = Xe(), u = c ? He(c) : void 0, p = u ? te(u).description : void 0, d = i.getUser(), l = e.getIntegrationByName("Replay"), h = l && l.getReplayId(), v = d !== void 0 ? d.email || d.id || d.ip_address : void 0, g = aI([i, "access", (y) => y.getScopeData, "call", (y) => y(), "access", (y) => y.contexts, "optionalAccess", (y) => y.profile, "optionalAccess", (y) => y.profile_id]), f = Jn(n.target), m = ze({
      release: s.release,
      environment: s.environment,
      transaction: p,
      [Vg]: t.value,
      user: v || void 0,
      profile_id: g || void 0,
      replay_id: h || void 0
    }), S = kn({
      name: f,
      op: `ui.interaction.${r}`,
      attributes: m,
      startTime: o,
      experimental: {
        standalone: !0
      }
    });
    S.addEvent("inp", {
      [ap]: "millisecond",
      [cp]: t.value
    }), S.end(o + a);
  });
}
function Rb(t, e = mb("fetch")) {
  let n = 0, r = 0;
  function s(o) {
    const a = o.body.length;
    n += a, r++;
    const i = {
      body: o.body,
      method: "POST",
      referrerPolicy: "origin",
      headers: t.headers,
      // Outgoing requests are usually cancelled when navigating to a different page, causing a "TypeError: Failed to
      // fetch" error and sending a "network_error" client-outcome - in Chrome, the request status shows "(cancelled)".
      // The `keepalive` flag keeps outgoing requests alive, even when switching pages. We want this since we're
      // frequently sending events right before the user is switching pages (eg. whenfinishing navigation transactions).
      // Gotchas:
      // - `keepalive` isn't supported by Firefox
      // - As per spec (https://fetch.spec.whatwg.org/#http-network-or-cache-fetch):
      //   If the sum of contentLength and inflightKeepaliveBytes is greater than 64 kibibytes, then return a network error.
      //   We will therefore only activate the flag when we're below that limit.
      // There is also a limit of requests that can be open at the same time, so we also limit this to 15
      // See https://github.com/getsentry/sentry-javascript/pull/7553 for details
      keepalive: n <= 6e4 && r < 15,
      ...t.fetchOptions
    };
    if (!e)
      return hv("fetch"), yo("No fetch implementation available");
    try {
      return e(t.url, i).then((c) => (n -= a, r--, {
        statusCode: c.status,
        headers: {
          "x-sentry-rate-limits": c.headers.get("X-Sentry-Rate-Limits"),
          "retry-after": c.headers.get("Retry-After")
        }
      }));
    } catch (c) {
      return hv("fetch"), n -= a, r--, yo(c);
    }
  }
  return ww(t, s);
}
const Pb = 30, Eb = 50;
function Im(t, e, n, r) {
  const s = {
    filename: t,
    function: e === "<anonymous>" ? or : e,
    in_app: !0
    // All browser frames are considered in_app
  };
  return n !== void 0 && (s.lineno = n), r !== void 0 && (s.colno = r), s;
}
const Tb = /^\s*at (?:(.+?\)(?: \[.+\])?|.*?) ?\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\/)?.*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i, Ib = /\((\S*)(?::(\d+))(?::(\d+))\)/, wb = (t) => {
  const e = Tb.exec(t);
  if (e) {
    if (e[2] && e[2].indexOf("eval") === 0) {
      const o = Ib.exec(e[2]);
      o && (e[2] = o[1], e[3] = o[2], e[4] = o[3]);
    }
    const [r, s] = wm(e[1] || or, e[2]);
    return Im(s, r, e[3] ? +e[3] : void 0, e[4] ? +e[4] : void 0);
  }
}, bb = [Pb, wb], Ab = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:[-a-z]+)?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i, Mb = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i, kb = (t) => {
  const e = Ab.exec(t);
  if (e) {
    if (e[3] && e[3].indexOf(" > eval") > -1) {
      const o = Mb.exec(e[3]);
      o && (e[1] = e[1] || "eval", e[3] = o[1], e[4] = o[2], e[5] = "");
    }
    let r = e[3], s = e[1] || or;
    return [s, r] = wm(s, r), Im(r, s, e[4] ? +e[4] : void 0, e[5] ? +e[5] : void 0);
  }
}, Ob = [Eb, kb], Db = [bb, Ob], Nb = Og(...Db), wm = (t, e) => {
  const n = t.indexOf("safari-extension") !== -1, r = t.indexOf("safari-web-extension") !== -1;
  return n || r ? [
    t.indexOf("@") !== -1 ? t.split("@")[0] : or,
    n ? `safari-extension:${e}` : `safari-web-extension:${e}`
  ] : [t, e];
}, Zs = 1024, Lb = "Breadcrumbs", zb = (t = {}) => {
  const e = {
    console: !0,
    dom: !0,
    fetch: !0,
    history: !0,
    sentry: !0,
    xhr: !0,
    ...t
  };
  return {
    name: Lb,
    setup(n) {
      e.console && PT(qb(n)), e.dom && db(Bb(n, e.dom)), e.xhr && Tm(Fb(n)), e.fetch && Lg($b(n)), e.history && mp(Ub(n)), e.sentry && n.on("beforeSendEvent", xb(n));
    }
  };
}, jb = zb;
function xb(t) {
  return function(n) {
    ne() === t && Rn(
      {
        category: `sentry.${n.type === "transaction" ? "transaction" : "event"}`,
        event_id: n.event_id,
        level: n.level,
        message: pn(n)
      },
      {
        event: n
      }
    );
  };
}
function Bb(t, e) {
  return function(r) {
    if (ne() !== t)
      return;
    let s, o, a = typeof e == "object" ? e.serializeAttribute : void 0, i = typeof e == "object" && typeof e.maxStringLength == "number" ? e.maxStringLength : void 0;
    i && i > Zs && ($e && I.warn(
      `\`dom.maxStringLength\` cannot exceed ${Zs}, but a value of ${i} was configured. Sentry will use ${Zs} instead.`
    ), i = Zs), typeof a == "string" && (a = [a]);
    try {
      const u = r.event, p = Hb(u) ? u.target : u;
      s = Jn(p, { keyAttrs: a, maxStringLength: i }), o = wg(p);
    } catch {
      s = "<unknown>";
    }
    if (s.length === 0)
      return;
    const c = {
      category: `ui.${r.name}`,
      message: s
    };
    o && (c.data = { "ui.component_name": o }), Rn(c, {
      event: r.event,
      name: r.name,
      global: r.global
    });
  };
}
function qb(t) {
  return function(n) {
    if (ne() !== t)
      return;
    const r = {
      category: "console",
      data: {
        arguments: n.args,
        logger: "console"
      },
      level: BT(n.level),
      message: Th(n.args, " ")
    };
    if (n.level === "assert")
      if (n.args[0] === !1)
        r.message = `Assertion failed: ${Th(n.args.slice(1), " ") || "console.assert"}`, r.data.arguments = n.args.slice(1);
      else
        return;
    Rn(r, {
      input: n.args,
      level: n.level
    });
  };
}
function Fb(t) {
  return function(n) {
    if (ne() !== t)
      return;
    const { startTimestamp: r, endTimestamp: s } = n, o = n.xhr[qn];
    if (!r || !s || !o)
      return;
    const { method: a, url: i, status_code: c, body: u } = o, p = {
      method: a,
      url: i,
      status_code: c
    }, d = {
      xhr: n.xhr,
      input: u,
      startTimestamp: r,
      endTimestamp: s
    };
    Rn(
      {
        category: "xhr",
        data: p,
        type: "http"
      },
      d
    );
  };
}
function $b(t) {
  return function(n) {
    if (ne() !== t)
      return;
    const { startTimestamp: r, endTimestamp: s } = n;
    if (s && !(n.fetchData.url.match(/sentry_key/) && n.fetchData.method === "POST"))
      if (n.error) {
        const o = n.fetchData, a = {
          data: n.error,
          input: n.args,
          startTimestamp: r,
          endTimestamp: s
        };
        Rn(
          {
            category: "fetch",
            data: o,
            level: "error",
            type: "http"
          },
          a
        );
      } else {
        const o = n.response, a = {
          ...n.fetchData,
          status_code: o && o.status
        }, i = {
          input: n.args,
          response: o,
          startTimestamp: r,
          endTimestamp: s
        };
        Rn(
          {
            category: "fetch",
            data: a,
            type: "http"
          },
          i
        );
      }
  };
}
function Ub(t) {
  return function(n) {
    if (ne() !== t)
      return;
    let r = n.from, s = n.to;
    const o = vn($.location.href);
    let a = r ? vn(r) : void 0;
    const i = vn(s);
    (!a || !a.path) && (a = o), o.protocol === i.protocol && o.host === i.host && (s = i.relative), o.protocol === a.protocol && o.host === a.host && (r = a.relative), Rn({
      category: "navigation",
      data: {
        from: r,
        to: s
      }
    });
  };
}
function Hb(t) {
  return !!t && !!t.target;
}
const Wb = [
  "EventTarget",
  "Window",
  "Node",
  "ApplicationCache",
  "AudioTrackList",
  "BroadcastChannel",
  "ChannelMergerNode",
  "CryptoOperation",
  "EventSource",
  "FileReader",
  "HTMLUnknownElement",
  "IDBDatabase",
  "IDBRequest",
  "IDBTransaction",
  "KeyOperation",
  "MediaController",
  "MessagePort",
  "ModalWindow",
  "Notification",
  "SVGElementInstance",
  "Screen",
  "SharedWorker",
  "TextTrack",
  "TextTrackCue",
  "TextTrackList",
  "WebSocket",
  "WebSocketWorker",
  "Worker",
  "XMLHttpRequest",
  "XMLHttpRequestEventTarget",
  "XMLHttpRequestUpload"
], Vb = "BrowserApiErrors", Kb = (t = {}) => {
  const e = {
    XMLHttpRequest: !0,
    eventTarget: !0,
    requestAnimationFrame: !0,
    setInterval: !0,
    setTimeout: !0,
    ...t
  };
  return {
    name: Vb,
    // TODO: This currently only works for the first client this is setup
    // We may want to adjust this to check for client etc.
    setupOnce() {
      e.setTimeout && Pe($, "setTimeout", fv), e.setInterval && Pe($, "setInterval", fv), e.requestAnimationFrame && Pe($, "requestAnimationFrame", Gb), e.XMLHttpRequest && "XMLHttpRequest" in $ && Pe(XMLHttpRequest.prototype, "send", Qb);
      const n = e.eventTarget;
      n && (Array.isArray(n) ? n : Wb).forEach(Yb);
    }
  };
}, Jb = Kb;
function fv(t) {
  return function(...e) {
    const n = e[0];
    return e[0] = Yn(n, {
      mechanism: {
        data: { function: Tt(t) },
        handled: !1,
        type: "instrument"
      }
    }), t.apply(this, e);
  };
}
function Gb(t) {
  return function(e) {
    return t.apply(this, [
      Yn(e, {
        mechanism: {
          data: {
            function: "requestAnimationFrame",
            handler: Tt(t)
          },
          handled: !1,
          type: "instrument"
        }
      })
    ]);
  };
}
function Qb(t) {
  return function(...e) {
    const n = this;
    return ["onload", "onerror", "onprogress", "onreadystatechange"].forEach((s) => {
      s in n && typeof n[s] == "function" && Pe(n, s, function(o) {
        const a = {
          mechanism: {
            data: {
              function: s,
              handler: Tt(o)
            },
            handled: !1,
            type: "instrument"
          }
        }, i = rp(o);
        return i && (a.mechanism.data.handler = Tt(i)), Yn(o, a);
      });
    }), t.apply(this, e);
  };
}
function Yb(t) {
  const e = $, n = e[t] && e[t].prototype;
  !n || !n.hasOwnProperty || !n.hasOwnProperty("addEventListener") || (Pe(n, "addEventListener", function(r) {
    return function(s, o, a) {
      try {
        typeof o.handleEvent == "function" && (o.handleEvent = Yn(o.handleEvent, {
          mechanism: {
            data: {
              function: "handleEvent",
              handler: Tt(o),
              target: t
            },
            handled: !1,
            type: "instrument"
          }
        }));
      } catch {
      }
      return r.apply(this, [
        s,
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        Yn(o, {
          mechanism: {
            data: {
              function: "addEventListener",
              handler: Tt(o),
              target: t
            },
            handled: !1,
            type: "instrument"
          }
        }),
        a
      ]);
    };
  }), Pe(
    n,
    "removeEventListener",
    function(r) {
      return function(s, o, a) {
        const i = o;
        try {
          const c = i && i.__sentry_wrapped__;
          c && r.call(this, s, c, a);
        } catch {
        }
        return r.call(this, s, i, a);
      };
    }
  ));
}
const Zb = "GlobalHandlers", Xb = (t = {}) => {
  const e = {
    onerror: !0,
    onunhandledrejection: !0,
    ...t
  };
  return {
    name: Zb,
    setupOnce() {
      Error.stackTraceLimit = 50;
    },
    setup(n) {
      e.onerror && (tA(n), gv("onerror")), e.onunhandledrejection && (nA(n), gv("onunhandledrejection"));
    }
  };
}, eA = Xb;
function tA(t) {
  zg((e) => {
    const { stackParser: n, attachStacktrace: r } = bm();
    if (ne() !== t || fm())
      return;
    const { msg: s, url: o, line: a, column: i, error: c } = e, u = sA(
      hp(n, c || s, void 0, r, !1),
      o,
      a,
      i
    );
    u.level = "error", am(u, {
      originalException: c,
      mechanism: {
        handled: !1,
        type: "onerror"
      }
    });
  });
}
function nA(t) {
  jg((e) => {
    const { stackParser: n, attachStacktrace: r } = bm();
    if (ne() !== t || fm())
      return;
    const s = rA(e), o = tp(s) ? iA(s) : hp(n, s, void 0, r, !0);
    o.level = "error", am(o, {
      originalException: s,
      mechanism: {
        handled: !1,
        type: "onunhandledrejection"
      }
    });
  });
}
function rA(t) {
  if (tp(t))
    return t;
  try {
    if ("reason" in t)
      return t.reason;
    if ("detail" in t && "reason" in t.detail)
      return t.detail.reason;
  } catch {
  }
  return t;
}
function iA(t) {
  return {
    exception: {
      values: [
        {
          type: "UnhandledRejection",
          // String() is needed because the Primitive type includes symbols (which can't be automatically stringified)
          value: `Non-Error promise rejection captured with value: ${String(t)}`
        }
      ]
    }
  };
}
function sA(t, e, n, r) {
  const s = t.exception = t.exception || {}, o = s.values = s.values || [], a = o[0] = o[0] || {}, i = a.stacktrace = a.stacktrace || {}, c = i.frames = i.frames || [], u = isNaN(parseInt(r, 10)) ? void 0 : r, p = isNaN(parseInt(n, 10)) ? void 0 : n, d = Pt(e) && e.length > 0 ? e : uT();
  return c.length === 0 && c.push({
    colno: u,
    filename: d,
    function: or,
    in_app: !0,
    lineno: p
  }), t;
}
function gv(t) {
  $e && I.log(`Global Handler attached: ${t}`);
}
function bm() {
  const t = ne();
  return t && t.getOptions() || {
    stackParser: () => [],
    attachStacktrace: !1
  };
}
const oA = () => ({
  name: "HttpContext",
  preprocessEvent(t) {
    if (!$.navigator && !$.location && !$.document)
      return;
    const e = t.request && t.request.url || $.location && $.location.href, { referrer: n } = $.document || {}, { userAgent: r } = $.navigator || {}, s = {
      ...t.request && t.request.headers,
      ...n && { Referer: n },
      ...r && { "User-Agent": r }
    }, o = { ...t.request, ...e && { url: e }, headers: s };
    t.request = o;
  }
}), aA = "cause", cA = 5, uA = "LinkedErrors", pA = (t = {}) => {
  const e = t.limit || cA, n = t.key || aA;
  return {
    name: uA,
    preprocessEvent(r, s, o) {
      const a = o.getOptions();
      sT(
        // This differs from the LinkedErrors integration in core by using a different exceptionFromError function
        dp,
        a.stackParser,
        a.maxValueLength,
        n,
        e,
        r,
        s
      );
    }
  };
}, dA = pA;
function lA(t) {
  return [
    zw(),
    Ow(),
    Jb(),
    jb(),
    eA(),
    dA(),
    Jw(),
    oA()
  ];
}
function hA(t = {}) {
  return { ...{
    defaultIntegrations: lA(),
    release: typeof __SENTRY_RELEASE__ == "string" ? __SENTRY_RELEASE__ : $.SENTRY_RELEASE && $.SENTRY_RELEASE.id ? $.SENTRY_RELEASE.id : void 0,
    autoSessionTracking: !0,
    sendClientReports: !0
  }, ...t };
}
function vA() {
  const t = $, e = t && t.chrome && t.chrome.runtime && t.chrome.runtime.id, n = $;
  return !!(n && n.browser && n.browser.runtime && n.browser.runtime.id) || !!e;
}
function fA(t = {}) {
  const e = hA(t);
  if (vA()) {
    Ts(() => {
      console.error(
        "[Sentry] You cannot run Sentry this way in a browser extension, check: https://docs.sentry.io/platforms/javascript/best-practices/browser-extensions/"
      );
    });
    return;
  }
  $e && (Dg() || I.warn(
    "No Fetch API detected. The Sentry SDK requires a Fetch API compatible environment to send events. Please add a Fetch API polyfill."
  ));
  const n = {
    ...e,
    stackParser: _T(e.stackParser || Nb),
    integrations: mw(e),
    transport: e.transport || Rb
  };
  Pw(f1, n), e.autoSessionTracking && gA();
}
function gA() {
  if (typeof $.document > "u") {
    $e && I.warn("Session tracking in non-browser environment with @sentry/browser is not supported.");
    return;
  }
  Qh({ ignoreDuration: !0 }), Yh(), mp(({ from: t, to: e }) => {
    t !== void 0 && t !== e && (Qh({ ignoreDuration: !0 }), Yh());
  });
}
const yu = {
  traceFetch: !0,
  traceXHR: !0,
  enableHTTPTimings: !0
};
function mA(t) {
  const { traceFetch: e, traceXHR: n, shouldCreateSpanForRequest: r, enableHTTPTimings: s, tracePropagationTargets: o } = {
    traceFetch: yu.traceFetch,
    traceXHR: yu.traceXHR,
    ...t
  }, a = typeof r == "function" ? r : (u) => !0, i = (u) => _A(u, o), c = {};
  e && Lg((u) => {
    const p = Zw(u, a, i, c);
    if (p) {
      const d = Am(u.fetchData.url), l = d ? vn(d).host : void 0;
      p.setAttributes({
        "http.url": d,
        "server.address": l
      });
    }
    s && p && mv(p);
  }), n && Tm((u) => {
    const p = RA(u, a, i, c);
    s && p && mv(p);
  });
}
function SA(t) {
  return t.entryType === "resource" && "initiatorType" in t && typeof t.nextHopProtocol == "string" && (t.initiatorType === "fetch" || t.initiatorType === "xmlhttprequest");
}
function mv(t) {
  const { url: e } = te(t).data || {};
  if (!e || typeof e != "string")
    return;
  const n = fp("resource", ({ entries: r }) => {
    r.forEach((s) => {
      SA(s) && s.name.endsWith(e) && (CA(s).forEach((a) => t.setAttribute(...a)), setTimeout(n));
    });
  });
}
function yA(t) {
  let e = "unknown", n = "unknown", r = "";
  for (const s of t) {
    if (s === "/") {
      [e, n] = t.split("/");
      break;
    }
    if (!isNaN(Number(s))) {
      e = r === "h" ? "http" : r, n = t.split(r)[1];
      break;
    }
    r += s;
  }
  return r === t && (e = r), { name: e, version: n };
}
function at(t = 0) {
  return ((Ze || performance.timeOrigin) + t) / 1e3;
}
function CA(t) {
  const { name: e, version: n } = yA(t.nextHopProtocol), r = [];
  return r.push(["network.protocol.version", n], ["network.protocol.name", e]), Ze ? [
    ...r,
    ["http.request.redirect_start", at(t.redirectStart)],
    ["http.request.fetch_start", at(t.fetchStart)],
    ["http.request.domain_lookup_start", at(t.domainLookupStart)],
    ["http.request.domain_lookup_end", at(t.domainLookupEnd)],
    ["http.request.connect_start", at(t.connectStart)],
    ["http.request.secure_connection_start", at(t.secureConnectionStart)],
    ["http.request.connection_end", at(t.connectEnd)],
    ["http.request.request_start", at(t.requestStart)],
    ["http.request.response_start", at(t.responseStart)],
    ["http.request.response_end", at(t.responseEnd)]
  ] : r;
}
function _A(t, e) {
  const n = $.location && $.location.href;
  if (n) {
    let r, s;
    try {
      r = new URL(t, n), s = new URL(n).origin;
    } catch {
      return !1;
    }
    const o = r.origin === s;
    return e ? hn(r.toString(), e) || o && hn(r.pathname, e) : o;
  } else {
    const r = !!t.match(/^\/(?!\/)/);
    return e ? hn(t, e) : r;
  }
}
function RA(t, e, n, r) {
  const s = t.xhr, o = s && s[qn];
  if (!s || s.__sentry_own_request__ || !o)
    return;
  const a = Ft() && e(o.url);
  if (t.endTimestamp && a) {
    const l = s.__sentry_xhr_span_id__;
    if (!l)
      return;
    const h = r[l];
    h && o.status_code !== void 0 && (Jg(h, o.status_code), h.end(), delete r[l]);
    return;
  }
  const i = Am(o.url), c = i ? vn(i).host : void 0, u = !!Xe(), p = a && u ? kn({
    name: `${o.method} ${o.url}`,
    attributes: {
      type: "xhr",
      "http.method": o.method,
      "http.url": i,
      url: o.url,
      "server.address": c,
      [xe]: "auto.http.browser",
      [ps]: "http.client"
    }
  }) : new cr();
  s.__sentry_xhr_span_id__ = p.spanContext().spanId, r[s.__sentry_xhr_span_id__] = p;
  const d = ne();
  return s.setRequestHeader && n(o.url) && d && PA(
    s,
    d,
    // If performance is disabled (TWP) or there's no active root span (pageload/navigation/interaction),
    // we do not want to use the span as base for the trace headers,
    // which means that the headers will be generated from the scope and the sampling decision is deferred
    Ft() && u ? p : void 0
  ), p;
}
function PA(t, e, n) {
  const r = pe(), s = wt(), { traceId: o, spanId: a, sampled: i, dsc: c } = {
    ...s.getPropagationContext(),
    ...r.getPropagationContext()
  }, u = n && Ft() ? Yg(n) : ip(o, a, i), p = $g(
    c || (n ? Mn(n) : Va(o, e))
  );
  EA(t, u, p);
}
function EA(t, e, n) {
  try {
    t.setRequestHeader("sentry-trace", e), n && t.setRequestHeader(ou, n);
  } catch {
  }
}
function Am(t) {
  try {
    return new URL(t, $.location.origin).href;
  } catch {
    return;
  }
}
function TA() {
  $ && $.document ? $.document.addEventListener("visibilitychange", () => {
    const t = Xe();
    if (!t)
      return;
    const e = He(t);
    if ($.document.hidden && e) {
      const n = "cancelled", { op: r, status: s } = te(e);
      $e && I.log(`[Tracing] Transaction: ${n} -> since tab moved to the background, op: ${r}`), s || e.setStatus({ code: me, message: n }), e.setAttribute("sentry.cancellation_reason", "document.hidden"), e.end();
    }
  }) : $e && I.warn("[Tracing] Could not set up background tab detection due to lack of global document");
}
const IA = "BrowserTracing", wA = {
  ...ao,
  instrumentNavigation: !0,
  instrumentPageLoad: !0,
  markBackgroundSpan: !0,
  enableLongTask: !0,
  enableInp: !0,
  _experiments: {},
  ...yu
}, bA = (t = {}) => {
  wI();
  const {
    enableInp: e,
    enableLongTask: n,
    _experiments: { enableInteractions: r },
    beforeStartSpan: s,
    idleTimeout: o,
    finalTimeout: a,
    childSpanTimeout: i,
    markBackgroundSpan: c,
    traceFetch: u,
    traceXHR: p,
    shouldCreateSpanForRequest: d,
    enableHTTPTimings: l,
    instrumentPageLoad: h,
    instrumentNavigation: v
  } = {
    ...wA,
    ...t
  }, g = G1();
  e && Cb(), n && Q1(), r && Y1();
  const f = {
    name: void 0,
    source: void 0
  };
  function m(S, y) {
    const P = y.op === "pageload", C = s ? s(y) : y, _ = C.attributes || {};
    y.name !== C.name && (_[Lt] = "custom", C.attributes = _), f.name = C.name, f.source = _[Lt];
    const w = om(C, {
      idleTimeout: o,
      finalTimeout: a,
      childSpanTimeout: i,
      // should wait for finish signal if it's a pageload transaction
      disableAutoFinish: P,
      beforeSpanEnd: (O) => {
        g(), nb(O);
      }
    });
    function T() {
      ["interactive", "complete"].includes($.document.readyState) && S.emit("idleSpanEnableAutoFinish", w);
    }
    return P && $.document && ($.document.addEventListener("readystatechange", () => {
      T();
    }), T()), w;
  }
  return {
    name: IA,
    afterAllSetup(S) {
      let y, P = $.location && $.location.href;
      S.on("startNavigationSpan", (C) => {
        ne() === S && (y && ($e && I.log(`[Tracing] Finishing current root span with op: ${te(y).op}`), y.end()), y = m(S, {
          op: "navigation",
          ...C
        }));
      }), S.on("startPageLoadSpan", (C, _ = {}) => {
        if (ne() !== S)
          return;
        y && ($e && I.log(`[Tracing] Finishing current root span with op: ${te(y).op}`), y.end());
        const w = _.sentryTrace || Sv("sentry-trace"), T = _.baggage || Sv("baggage"), O = KT(w, T);
        pe().setPropagationContext(O), y = m(S, {
          op: "pageload",
          ...C
        });
      }), S.on("spanEnd", (C) => {
        const _ = te(C).op;
        if (C !== He(C) || _ !== "navigation" && _ !== "pageload")
          return;
        const w = pe(), T = w.getPropagationContext();
        w.setPropagationContext({
          ...T,
          sampled: T.sampled !== void 0 ? T.sampled : An(C),
          dsc: T.dsc || Mn(C)
        });
      }), $.location && (h && AA(S, {
        name: $.location.pathname,
        // pageload should always start at timeOrigin (and needs to be in s, not ms)
        startTime: Ze ? Ze / 1e3 : void 0,
        attributes: {
          [Lt]: "url",
          [xe]: "auto.pageload.browser"
        }
      }), v && mp(({ to: C, from: _ }) => {
        if (_ === void 0 && P && P.indexOf(C) !== -1) {
          P = void 0;
          return;
        }
        _ !== C && (P = void 0, MA(S, {
          name: $.location.pathname,
          attributes: {
            [Lt]: "url",
            [xe]: "auto.navigation.browser"
          }
        }));
      })), c && TA(), r && kA(o, a, i, f), mA({
        traceFetch: u,
        traceXHR: p,
        tracePropagationTargets: S.getOptions().tracePropagationTargets,
        shouldCreateSpanForRequest: d,
        enableHTTPTimings: l
      });
    }
  };
};
function AA(t, e, n) {
  t.emit("startPageLoadSpan", e, n), pe().setTransactionName(e.name);
  const r = Xe();
  return (r && te(r).op) === "pageload" ? r : void 0;
}
function MA(t, e) {
  pe().setPropagationContext(yv()), wt().setPropagationContext(yv()), t.emit("startNavigationSpan", e), pe().setTransactionName(e.name);
  const n = Xe();
  return (n && te(n).op) === "navigation" ? n : void 0;
}
function Sv(t) {
  const e = pT(`meta[name=${t}]`);
  return e ? e.getAttribute("content") : void 0;
}
function kA(t, e, n, r) {
  let s;
  const o = () => {
    const a = "ui.action.click", i = Xe(), c = i && He(i);
    if (c) {
      const u = te(c).op;
      if (["navigation", "pageload"].includes(u)) {
        $e && I.warn(`[Tracing] Did not create ${a} span because a pageload or navigation span is in progress.`);
        return;
      }
    }
    if (s && (s.setAttribute(uu, "interactionInterrupted"), s.end(), s = void 0), !r.name) {
      $e && I.warn(`[Tracing] Did not create ${a} transaction because _latestRouteName is missing.`);
      return;
    }
    s = om(
      {
        name: r.name,
        op: a,
        attributes: {
          [Lt]: r.source || "url"
        }
      },
      {
        idleTimeout: t,
        finalTimeout: e,
        childSpanTimeout: n
      }
    );
  };
  $.document && addEventListener("click", o, { once: !1, capture: !0 });
}
function yv() {
  return {
    traceId: se(),
    spanId: se().substring(16)
  };
}
function OA(t, e) {
  if (e)
    return fA({
      dsn: cy,
      integrations: [bA()],
      tracesSampleRate: 1e-3,
      enabled: !0,
      environment: uy,
      initialScope: {
        tags: {
          agentId: t
        }
      }
    }), {
      populateWithAgent: (n) => {
        var r;
        Hg().setTags({
          owner: n.owner_id,
          plan: (r = n.metadata) == null ? void 0 : r.plan
        });
      },
      onErrorSendAlert: (n, r) => {
        op((s) => {
          s.setExtra("error data", r), pw(n);
        });
      }
    };
}
function Cv(t) {
  window.DID_AGENTS_API = {}, window.dataLayer = window.dataLayer || [];
  const {
    isOwner: e,
    enabled: n,
    onError: r,
    onClose: s,
    styles: o,
    didSocketApiUrl: a,
    didApiUrl: i,
    customMixpanelKey: c,
    offline: u,
    monitor: p = !0,
    ...d
  } = t;
  if (!t.targetElement && d.mode === "full")
    throw new Error("No target element provided for full mode");
  if (d.agentId) {
    if (!d.auth)
      throw new Error("No auth provider");
  } else
    throw new Error("No agent provider ");
  const l = typeof t.targetElement == "string" ? document.getElementById(t.targetElement) : t.targetElement, h = document.createElement("div");
  h.className = "didagent_target", document.body.appendChild(h);
  const {
    populateWithAgent: v,
    onErrorSendAlert: g
  } = OA(d.agentId, p) ?? {}, f = (S, y) => {
    g == null || g(S.message, y), r == null || r(S, y);
  }, m = setInterval(() => {
    l && !document.body.contains(l) && (fo(null, h), h.remove(), clearInterval(m));
  }, 2e3);
  fo(E(Cy, {
    initialConfigurations: {
      ...d,
      targetElement: l
    },
    children: E(XE, {
      isOwner: e,
      onClose: s,
      onAgentReady: v,
      styles: o,
      offline: u,
      didApiUrl: i,
      didSocketApiUrl: a,
      customMixpanelKey: c,
      enabled: n,
      onError: f
    })
  }), h);
}
function _v(t) {
  const {
    token: e,
    username: n,
    password: r,
    clientKey: s
  } = t;
  if (!s) {
    if (!e) {
      if (!n || !r)
        throw new Error("Failed to load agent. No auth method provided");
      return {
        type: "basic",
        username: n,
        password: r
      };
    }
    return {
      type: "bearer",
      token: e
    };
  }
  return {
    type: "key",
    clientKey: s
  };
}
const qe = document.querySelector('script[data-name="did-agent"]');
if (qe) {
  const t = new URLSearchParams(""), e = t.get("agent_id"), n = t.get("key"), r = qe.getAttribute("data-mode") ?? "fabio", s = qe.getAttribute("data-target-id"), o = e || qe.getAttribute("data-agent-id"), a = qe.getAttribute("data-api-url"), i = qe.getAttribute("data-token"), c = qe.getAttribute("data-username"), u = qe.getAttribute("data-password"), p = n || qe.getAttribute("data-client-key"), d = qe.getAttribute("data-chat-mode") ?? M.Functional, l = qe.getAttribute("data-track") !== "false", h = qe.getAttribute("data-monitor") !== "false", v = qe.getAttribute("data-position") ?? "right", g = qe.getAttribute("data-orientation") ?? "vertical";
  if (o) {
    if (!Object.values(M).includes(d))
      throw new Error(`Invalid chat mode, must be one of: ${Object.values(M).join(", ")}`);
  } else
    throw new Error("No agent id");
  window.DID_AGENTS_API = {};
  const f = {
    didApiUrl: a,
    monitor: h
  }, m = {
    mode: r,
    targetElement: s,
    auth: _v({
      token: i,
      username: c,
      password: u,
      clientKey: p
    }),
    agentId: o,
    track: l,
    chatMode: d,
    position: v,
    orientation: g
  };
  Cv({
    ...m,
    ...f
  });
} else
  window.DID_AGENT_INIT = ({
    token: t,
    username: e,
    password: n,
    clientKey: r,
    ...s
  }) => {
    Cv({
      ...s,
      auth: _v({
        token: t,
        username: e,
        password: n,
        clientKey: r
      })
    });
  };
